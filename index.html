<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
 <title>Digital Audio Workstation</title>
 <link rel="stylesheet" href="index.css" type="text/css" media="screen" title="Shrewm"/ >
</head>
<body>

<h1>Digital Audio Workstation</h1>
<hr/>
<p class="mainNav">
 <a href="http://webaudio.github.io/web-audio-api/">[WebAudio]</a>
 <a href="http://validator.w3.org/check/referer">[XHTML 1.0]</a>
 <a href="http://jigsaw.w3.org/css-validator/check/referer/">[CSS 2.1]</a>
</p>

<div class="piano">
 <div><p>C1</p><p>#</p></div>
 <div><p>D</p><p>#</p></div>
 <div><p>E</p></div>
 <div><p>F</p><p>#</p></div>
 <div><p>G</p><p>#</p></div>
 <div><p>A</p><p>#</p></div>
 <div><p>B</p></div>
 <div><p>C2</p><p>#</p></div>
 <div><p>D</p><p>#</p></div>
 <div><p>E</p></div>
 <div><p>F</p><p>#</p></div>
 <div><p>G</p><p>#</p></div>
 <div><p>A</p><p>#</p></div>
 <div><p>B</p></div>
 <div><p>C3</p><p>#</p></div>
 <div><p>D</p><p>#</p></div>
 <div><p>E</p></div>
 <div><p>F</p><p>#</p></div>
 <div><p>G</p><p>#</p></div>
 <div><p>A</p><p>#</p></div>
 <div><p>B</p></div>
 <div><p>C4</p><p>#</p></div>
 <div><p>D</p><p>#</p></div>
 <div><p>E</p></div>
 <div><p>F</p><p>#</p></div>
 <div><p>G</p><p>#</p></div>
 <div><p>A</p><p>#</p></div>
 <div><p>B</p></div>
 <div><p>C5</p></div>
</div>

<!-- each track gets a bunch of beats -->
<div class="rythm">
  <div class="track"></div>
  <div class="track"></div>
  <div class="track"></div>
  <div class="track"></div>
  <div class="track"></div>
  <div class="track"></div>
  <div class="track"></div>
  <div class="track"></div>
  <div class="track"></div>
  <div class="track"></div>
  <div class="track"></div>
  <div class="track"></div>
</div>
<p style="display:inline-block; background:#080"  onmousedown="pause=!pause; this.style.background=pause?'red':'green'; Beat = Math.floor(ctx.currentTime / BeatDuration)">pause</p>

<p id="DB"></p>

<script type="text/javascript">//<![CDATA[


/******************************************************************************
  Debug message console
  Usage::
    <p id="DB"></p> -- Create this element.
    DB("string")    -- Send string to info window.  Behaves like a pre element.
    DB.clear()      -- Clear the window of all text
******************************************************************************/
var DB = (function () {
  var _DBelement = document.getElementById('DB');
  var _self;

  // Create the instance or, if the DOM element doesn't exist, a null object.
  if (!_DBelement) {
    _self =  function (s) { console.log(s);}
    _self.clear = function () { }
  } else {
    _DBelement.style.border = "solid thin green";
    _DBelement.style.whiteSpace = "pre";
    _DBelement.style.overflow = "auto";
    _DBelement.style.maxHeight = "20em";
    _self = function (s) {
      _DBelement.innerHTML += "\n" + s;
      _DBelement.scrollTop = _DBelement.scrollHeight;
    }

    _self.clear = function () { _DBelement.innerHTML = ""; }
  }

  return _self;

})();


/******************************************************************************
  Database of Web Audio audio buffers.  It will download and convert raw audio
  files into ready to use AudioBuffers.

  USAGE::
    var noises = new AudioBuffersDB(["song1.raw", "song2.raw"]);
    noises.status()       If valid, an empty strings.  Otherwise a non-empty
                          string with error message.
    noises.count          Number of files loaded.
    noises.fileName(i)    Get a filename.
    noises.audioBuffer(i) Get an audio buffer.
******************************************************************************/
var AudioBuffersDB = function (fileNames) {
  DB("::AudioBuffersDB");

  // Private

  var _errorStatus = ""
  var _samplesSet = [];

  function _Validate () {
    if ((!fileNames) || (0 == fileNames.length)) {
      _errorStatus += "WARNING: AudioBuffersDB fileNames was passed no array of strings.\n"
      fileNames = [];
    }
  }

  function _loadRawAudioFiles () {
    fileNames.forEach(function (fn, i) { // forEach passes in each ary element and the index.
      var client = new XMLHttpRequest();
      client.open('GET', fn);
      client.responseType = "arraybuffer";
      client.onreadystatechange = // Callback after remote file has been loaded
        function () {
          if (4 != client.readyState) return;
          if (200 != client.status) {
            var msg = "WARNING: problem with file '" + client.responseURL + "'";
            DB(msg);
            _errorStatus += msg + "\n";
          }
          if (200 == client.status) {
            var samples = new Int16Array(client.response); // Consider u8 ary as s16 ary.
            // Normalized each s16 sample to f32 between -1 and 1.
            var Noise =  new Float32Array(samples.length);
            for (var j=0; j<samples.length; ++j) {
              Noise[j] = samples[j]/32768;
            }
            // Create and set the audio buffer
            _samplesSet[i] = ctx.createBuffer(1, samples.length, 44100);
            _samplesSet[i].getChannelData(0).set(Noise);
          } // if
        } // function()
      client.send();
    }); // forEach function
  } // function

  // Construct

  _Validate();
  _loadRawAudioFiles();

  // Public

  this.count = fileNames ? fileNames.length : 0;
  this.fileName = function (i) { return fileNames[i]; }
  this.audioBuffer = function (i) { return _samplesSet[i]; }
  this.setAudioBuffer = function (i, o) { _samplesSet[i] = o; } // TODO: get rid of this
  this.status = function () { return _errorStatus; }

  DB(_errorStatus + "--AudioBuffersDB");
}


var KeysDOM;
var PianoTypeDOM; // sine, square, etc
var PianoNotes = []; // Sixteenth count array of note indices
var CurrentPianoNote = 0;

var pause=false;
var ctx = new AudioContext();

 // Object containg AudioBuffers derived from remote files
var Noises = new AudioBuffersDB(
 ["808.bass.raw",
  "808.snare.noise.raw",
  "808.maracas.raw",
  "808.cowbell.raw",
  "808.rim.raw",
  "808.highhat.closed.raw",
  "808.claves.raw",
  "808.clap.raw",
  "808.highhat.opened.raw",
  "808.cymbal.raw",
  "909.thump.raw",
  "909.snare.noise.raw"]);

var MouseIsDown = false;

var OriginalBackgrounds = [];
var ToggleButtonState = 0;

var TrackCount = 0;
var BeatCount = 16;
var TracksBeats = []; // Each entry will be an array of beats [{color, element}, ...]
var BeatDuration = .25 + /*0.0625 + */ 0.03125; // Keep timing binary friendly.
var Beat = 0; // Forever incrementing

window.onmouseup = function () { MouseIsDown = false; }
window.onkeydown = function () { if (event.keyCode == 191) DB.clear(); }

/* Play a one shot noise.  TODO: handle looped sound.

  Currently:

  [AudioBuffer]--->[AudioBufferSourceNode]--O[Destination]
                         .
                         |
                  start--+
*/
function play (noise, when) {
  var source;
  var now = when==0 ? ctx.currentTime : when; // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when

  if (999 <= noise) {
    if (noise == 999) return;
    var freq = 130.813;
    var release=0.5
    var osc = ctx.createOscillator(); // Create and add to table if not already
    noise = freq * Math.pow(2, (noise-1000)/12); 
    osc.frequency.value = noise; // The frequency is encoded as 1000+freq in parameter noise.
    osc.type = PianoTypeDOM.innerText;
    osc.start(now);
    osc.stop(now + release);
    osc.onended = (function(osc){ return function() { osc.disconnect(); }})(osc);

    var gain = ctx.createGain();
    gain.gain.setValueAtTime(0.4, now);
    gain.gain.linearRampToValueAtTime(0, now + release);

    osc.connect(gain);
    source = gain;
  } else {
    source = ctx.createBufferSource();
    source.buffer = Noises.audioBuffer(noise);
    source.start(when);
    source.onended = (function(source){ return function() { source.disconnect(); }})(source);
  
    if (noise == 0) { // Loop the bass noise for one second
      var release=0.5
      //source.playbackRate.value = 0.5;
      source.playbackRate.setValueAtTime(0.4, now);
      source.playbackRate.linearRampToValueAtTime(0.35, now+release);
      source.loop = true;
      source.stop(now + release);
  
      var lp = ctx.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 120;
      lp.Q.value = 0.5;
  
      var gain = ctx.createGain();
      //gain.gain.value = 1.0; // default
      //gain.gain.cancelScheduledValues(now);
      gain.gain.setValueAtTime(0.7, now);
      //gain.gain.exponentialRampToValueAtTime(0.00001, now+release);
      gain.gain.linearRampToValueAtTime(0, now+release);
  
      source.connect(lp);
      lp.connect(gain);
      source = gain;
    }
  }

  source.connect(ctx.destination);
}



function PreparePianoKeys () {
  var PianoDOM = document.getElementsByClassName("piano")[0];
  KeysDOM = PianoDOM.getElementsByTagName('p');
  var note = 0;
  for (var i=0; i<KeysDOM.length; ++i) {
    KeysDOM[i].onmousedown =
      (function(note) { // I can has a let?
         return function(){
          MouseIsDown=true;
          play(1000+note, 0);
          KeysDOM[PianoNotes[CurrentPianoNote]].style.backgroundColor=""; // Reset current key hilight
          KeysDOM[note].style.backgroundColor="yellow"; // Set current key hilight
          PianoNotes[CurrentPianoNote] = note;
         }
       })(note);
    KeysDOM[i].onmouseover =
      (function(note) { // I can has a let?
         return function() {
           if (MouseIsDown) {
             play(1000+note, 0);
             KeysDOM[PianoNotes[CurrentPianoNote]].style.backgroundColor=""; // Reset current key hilight
             KeysDOM[note].style.backgroundColor="yellow"; // Set current key hilight
             PianoNotes[CurrentPianoNote] = note;
           }
         }
       })(note);
    ++note;
  }
}


var beatCounter = 0;
var hoverHilight = 0;
function domCreate16th (track, beat) {
  var p;
  var d = document.createElement('div');

  d.className = "beat";
  d.style.backgroundColor = ["#333", "#222", "#222", "#222"][beatCounter++%4];
  for (var i=0; i<4; ++i) {
    p = document.createElement('p');
    p.className = "tick"
    if (track == TrackCount) { // synth track
      p.onmouseover = (function(beat, i){return function (event) {
        if (0 == ToggleButtonState) {
          ToggleButtonState = this.innerText == "." ? 1 : 2;
        }
        if (MouseIsDown) this.innerText = ToggleButtonState == 1 ? "X" : "."
        TracksBeats[TrackCount-1][Math.floor(CurrentPianoNote/4)].element.children[CurrentPianoNote%4].style.backgroundColor="";
        KeysDOM[PianoNotes[CurrentPianoNote]].style.backgroundColor="";
        hoverHilight = beat*4 + i;
        KeysDOM[PianoNotes[hoverHilight]].style.backgroundColor="yellow";
      }})(beat, i);
      p.onmouseleave = function (event) {
        this.style.backgroundColor="";
        KeysDOM[PianoNotes[hoverHilight]].style.backgroundColor="";
        KeysDOM[PianoNotes[CurrentPianoNote]].style.backgroundColor="yellow";
        TracksBeats[TrackCount-1][Math.floor(CurrentPianoNote/4)].element.children[CurrentPianoNote%4].style.backgroundColor="yellow";
      }
      p.onmousedown = (function(beat,i){return function (event) {
        MouseIsDown = true;
        ToggleButtonState = this.innerText == "." ? 1 : 2;
        this.innerText = ToggleButtonState == 1 ? "X" : "."
        KeysDOM[PianoNotes[CurrentPianoNote]].style.backgroundColor="";
        CurrentPianoNote = beat*4+i;
        KeysDOM[PianoNotes[CurrentPianoNote]].style.backgroundColor="yellow";
      }})(beat, i);
      var j = 1+(TrackCount+1)*BeatCount; // Start of the 2 hex character note indices
      j += 2*(beat*4 + i);
      PianoNotes[beat*4 + i] = parseInt(window.location.search.substring(j, j+2), 16)|0;
    } else { // drum track
      p.onmouseover = function (event) {
        if (0 == ToggleButtonState) {
          ToggleButtonState = this.innerText == "." ? 1 : 2;
        }
        if (MouseIsDown) this.innerText = ToggleButtonState == 1 ? "X" : "."
      }
      p.onmousedown = function (event) {
        MouseIsDown = true;
        ToggleButtonState = this.innerText == "." ? 1 : 2;
        this.innerText = ToggleButtonState == 1 ? "X" : "."
      }
    }
    var v = parseInt(window.location.search[1+track+(TrackCount+1)*beat], 16) // Consider prexisting beat state
    p.innerText = (v & 1<<i)? "X" : ".";
    d.appendChild(p);
  }

  return d;
}

function main () {
DB("::main");
  var o, b, t, TracksDOM=document.getElementsByClassName("track"); // Consider beat elements in the DOM.
  TrackCount = TracksDOM.length;
  
  // Create the DOM that represents the drum machine
  for (t=0; t<TrackCount; ++t) {
    TracksBeats[t] = new Array();
    // Add beat elements to DOM
    for (b=0; b<BeatCount; ++b) {
      p = domCreate16th(t, b);
      TracksDOM[t].appendChild(p);
      o= new Object();
      o.element = p;
      o.color = p.style.backgroundColor;
      TracksBeats[t][b] = o; // Set the global grid for easy access
    }
    // Add sound name elements to DOM
    var p = document.createElement('p');
    p.className = "name"
    p.innerText = Noises.fileName(t);
    p.onmousedown = (function (noise) {return function () { play(noise, 0); }})(t);
    TracksDOM[t].appendChild(p);
  }

  // Create the DOM that represents the synth track.  It's logically at the end but at the top onscreen.
  var RythmDOM = document.getElementsByClassName("rythm")[0];
  var Track = document.createElement('div');
  RythmDOM.insertBefore(Track, RythmDOM.firstChild);
  TracksBeats[TrackCount] = new Array();
  for (b=0; b<BeatCount; ++b) {
    p = domCreate16th(TrackCount, b);
    Track.appendChild(p);
    o = new Object();
    o.element = p;
    o.color = p.style.backgroundColor;
    TracksBeats[TrackCount][b] = o; // Set the global grid for easy access
  }

  // Add sound name elements to DOM
  var p = document.createElement('p');
  p.className = "name";
  p.innerText = "sawtooth"
  PianoTypeDOM = p;
  PianoTypeDOM.onmousedown =
    (function(note) { // I can has a let?
       return function(){ PianoTypeDOM.innerText = ["sine", "square", "sawtooth", "triangle"][++note%4] }
     })(0);
  Track.appendChild(p);
  Noises.setAudioBuffer(TrackCount, "synth"); // HACK
  ++TrackCount;


  // A beat used to be the smallest tick length but I've since added 16th notes (4 more beats per beat).
  var LastRenderedTick = -1;
  var BeatLast = 0; // Quarter beat
  var SBeatLast = 0; // Sixteenth beat
  function rendererLoop () {
    if (pause) return;
    var t;
    var tick = Math.floor(ctx.currentTime / (BeatDuration/4)) % (BeatCount*4);
    var beat = Math.floor(tick/4);
    var sbeat = [0,2,3,1][tick%4];

    if (LastRenderedTick == tick) return;

    for (t=0; t<TrackCount; ++t) {
      // 16th beat rendering
      // 1/4th beat rendering
      TracksBeats[t][BeatLast].element.style.backgroundColor = TracksBeats[t][BeatLast].color;
      TracksBeats[t][beat].element.style.backgroundColor = 'green';//"rgb("+Math.floor(Math.random()*256)+","+Math.floor(Math.random()*256)+","+Math.floor(Math.random()*256)+")";
    }
    LastRenderedTick = tick;
    BeatLast = beat;
    SBeatLast = sbeat;
    //setTimeout(rendererLoop, 100);
  }

  var pattern="";
  var sum = 0;
  function sequencerLoop () {
    var t, pre='', ret='';
    if (pause) return;
    while ((Beat * BeatDuration) <= (ctx.currentTime + 1.0)) {
      if (0 == (Beat % BeatCount)) {
        for (i=0; i<PianoNotes.length; ++i) // Add the note values for the synth track
           pattern += (PianoNotes[i]<16?"0":"") + PianoNotes[i].toString(16);
        window.history.replaceState("ohhai", "Digital Audio Workstation", document.location.href.split('?')[0] + '?'  + pattern);
        pattern="";
      }
      for (t=0; t<TrackCount; ++t) {
        sum = 0;
        for (s=0; s<4; ++s) {
          var note = TracksBeats[t][Beat % BeatCount].element.children[s].innerText;
          if (('.' != note) && Noises.audioBuffer(t)) { // If the noise actually exists (has been loaded)...
            if (t == TrackCount-1)
              play(1000 + PianoNotes[(Beat%BeatCount)*4 + s], Beat * BeatDuration + (s*BeatDuration)/4);
            else
              play(t, Beat * BeatDuration + (s*BeatDuration)/4);
            sum += 1<<s;
          } //if
        } // sub beats
        pattern = pattern + sum.toString(16);
      } // beats
      Beat += 1.0;
    } // while
    //setTimeout(sequencerLoop, 100);  // This is not a proper way of handling timing.  Temporary hack!
  }

  setInterval(rendererLoop, 10);
  setInterval(sequencerLoop, 10);
DB("--main");
}



/* Main
*/
window.onload = function () {
  DB("::window.onload");
  PreparePianoKeys();
  main();
  DB("--window.onload");
}

//]]></script>


</body></html>
