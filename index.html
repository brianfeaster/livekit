<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
 <title>Digital Audio Workstation</title>
 <link rel="stylesheet" href="index.css" type="text/css" media="screen" title="Shrewm"/ >
</head>
<body>

<h1>Digital Audio Workstation</h1>
<hr/>
<p id="noDB" style="width:20em; background:black; z-index:1; border:solid thin green; white-space:pre; overflow:auto; max-height:20em; position:fixed; right:0; top:0"></p>
<p class="mainNav">
 <a href="http://webaudio.github.io/web-audio-api/">[WebAudio]</a>
 <a href="http://validator.w3.org/check/referer">[XHTML 1.0]</a>
 <a href="http://jigsaw.w3.org/css-validator/check/referer/">[CSS 2.1]</a>
</p>

<div id="piano"></div>
<br/>
<!-- each track gets a bunch of beats -->
<div id="rythm">
</div>
<p style="display:inline-block; background:#080"  onmousedown="pause=!pause; this.style.background=pause?'red':'green'; Beat = Floor(ctx.currentTime / BeatDuration)">pause</p>


<script type="text/javascript">//<![CDATA[

/******************************************************************************
  Useful aliases
******************************************************************************/
var Floor = Math.floor;
var Pow   = Math.pow;
var CreateAppendChild = function (name, element) { return element.appendChild(document.createElement(name)); }
var CreateInsertBefore = function (name, element) { return element.insertBefore(document.createElement(name), element.firstChild); }

/******************************************************************************
  Debug message console and error checking
  Usage::
    <p id="DB"></p> -- Create the console element.  If nonexistent, this object will revert to using the browser's console.
    DB("string")    -- Send string to info window.  Behaves like a pre element.
    DB.clear()      -- Clear the window of all text
    DB.check(expr, string) -- If expr is false, send string to console.  status() will return false after an error checked.
    DB.status()     -- False if check ever failed.
******************************************************************************/
var DB = (function () {
  var consoleElement = document.getElementById('DB');
  var self;
  var status = true;

  var setStyles = function (e) {
    return;
    e.style.border = "solid thin green";
    e.style.whiteSpace = "pre";
    e.style.overflow = "auto";
    e.style.maxHeight = "20em";
  }

  // Create the instance which is a function.  Also create the clear function.
  if (!consoleElement) {
    self = function (s) { console.log(s);}
    self.clear = function () { }
  } else {
    setStyles(consoleElement);
    self = function (s) {
      consoleElement.innerHTML += "\n" + s;
      consoleElement.scrollTop = consoleElement.scrollHeight;
    }
    self.clear = function () { consoleElement.innerHTML = ""; }
  }

  self.check = function (expr, msg) {
    status = status && expr;
    return expr || self(msg) && false;
  }

  self.status = function () { return status; }

  return self;
})(); // DB


/******************************************************************************
  Database of Web Audio audio buffers.  It will download and convert raw audio
  files into ready to use AudioBuffers.

  USAGE::
    var noises = new AudioBuffersDB(["song1.raw", "song2.raw"]);
    noises.length         Number of files loaded.
    noises.fileName(i)    Get a filename.
    noises.audioBuffer(i) Get an audio buffer or undefined.
******************************************************************************/
var AudioBuffersDB = function (fileNames) {

  // Private

  var _audioBuffers = [];

  function _Validate () {
    if (!DB.check(fileNames && Array.isArray(fileNames), "ERROR: AudioBuffersdb: Invalid fileNames ary.")) {
      fileNames = [];
    }
  }

  function _loadRawAudioFiles () {
    fileNames.forEach(function (fn, i) { // forEach passes in each ary element and the index.
      var client = new XMLHttpRequest();
      client.open('GET', fn);
      client.responseType = "arraybuffer";
      client.onreadystatechange = // Callback after remote file has been loaded
        function () {
          if (4 != client.readyState) return;
          DB.check(200 == client.status, "ERROR: AudioBuffersDB._loadRawAudioFiles:  Problem with file '" + client.responseURL + "'");
          if (200 == client.status) {
            var samples = new Int16Array(client.response); // Consider u8 ary as s16 ary.
            // Normalized each s16 sample to f32 between -1 and 1.
            var Noise =  new Float32Array(samples.length);
            for (var j=0; j<samples.length; ++j) {
              Noise[j] = samples[j]/32768;
            }
            // Create and set the audio buffer
            _audioBuffers[i] = ctx.createBuffer(1, samples.length, 44100);
            _audioBuffers[i].getChannelData(0).set(Noise);
          } // if
        } // function()
      client.send();
    }); // forEach function
  } // function

  // Construct

  _Validate();
  _loadRawAudioFiles();

  // Public

  this.length = fileNames ? fileNames.length : 0;
  this.fileName = function (i) { return fileNames[i]; }
  this.audioBuffer = function (i) { return _audioBuffers[i]; }
  this.setAudioBuffer = function (i, o) { _audioBuffers[i] = o; } // TODO: get rid of this
} // AudioBuffersDB 


/******************************************************************************
  Create a piano keyboard in the DOM.  It emulates a keyboard controlled an
  oscillator.

  USAGE::
    var Keyboard = new PianoKeyboard('piano', 37, 0, 1, 130.813);

  CONSTRUCTOR PARAMETERS::
    DOM element id
    number of keys
    starting key (0==C, 1==C#, ... 11=B)
    octave
    first specified key's frequency

  METHODS::
    Keyboard.keyElements     All key DOM elements in an array
    Keyboard.keyElement      Get the DOM element representing the white or black key
    Keyboard.freq(key)       Frequency of key.  Indexed between 0 and number of keys (36 in this example).
******************************************************************************/
var PianoKeyboard = function (id, keyCount, startKey, startOctave, startFrequency) {

  //// Private

  var _pianoDOM = document.getElementById(id);
  DB.check(_pianoDOM, "ERROR: PianoKeyboard: Element id=" + id + " not found in DOM.");

  var _keysDOM = []; // Keeps track of the DOM elements which represent the white and black keys in order.

  var _createDOM = function () {
    var notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    var sharps = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0]; // Bool table of sharps in an octave, starting at C
    var newKey, keyPair = false; // The piano DOM is composed of divs containing either just a div (white key) or div and p (white and black key)
    startKey += startOctave*12; // Adjust initial key to account for octave
    for (var i=0; (i < keyCount); ++i) {

      if (sharps[(i + startKey)%12]) {
        // Create the sharp key.  If this is the first key (corner case), the key pair element needs to also be created.
        keyPair || (keyPair = CreateAppendChild('div', _pianoDOM));
        newKey = CreateAppendChild('p', keyPair);
      } else {
        // Create the natural key.
        keyPair = CreateAppendChild('div', _pianoDOM);
        var note   = (i + startKey) % 12;
        var octave = Floor((i + startKey) / 12);
        newKey = CreateAppendChild('div', keyPair)
        newKey.innerText = notes[note] + (note==0?octave:'');
      }

      _keysDOM.push(newKey); // Keep track of each created key.
    }
  }

  // Construct

  _createDOM();
  DB.check(keyCount == _keysDOM.length, "ERROR: PianoKeyboard: Created incorrect number of keys.");

  // Public

  this.keyElements = _keysDOM;
  this.keyElement = function (i) { return _keysDOM[i]; }
  this.freq = function (k) { return startFrequency * Pow(2, k/12.0);  }
} // PianoKeyboard 


/******************************************************************************
  Create a playable drumkit.  Expects a webaudio context and Audio Buffers DB.

  USAGE::
    var DrumKit = new Drumkit(ctx, audioBufers);

  CONSTRUCTOR PARAMETERS::
    An web audio context and audio buffers object.

  METHODS::
    DrumKit.play(soundIdx, when)  Plays key specified by the Keyboard object at
                                  webaudio context time 'when' or immediately if
                                  when==0.
******************************************************************************/
var Drumkit = function (ctx, audioBuffers) {
  //// Local
  var release = 0.5; // Release time in seconds for both the filter and gain.
  //// Public
  this.play = function (drum, when) {
    var audioBuffer = audioBuffers.audioBuffer(drum);
    if (!audioBuffer) return; // Do nothing if no audio buffer.
    var now = when==0 ? ctx.currentTime : when; // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
    var source = ctx.createBufferSource();
    source.buffer = audioBuffer;
    source.start(when);
    source.onended = function() { source.disconnect(); } // When the audio stops, remove it from the graph.
  
    if (drum == 0) { // HACK: need to generalize a sound pipeline
      // Loop the bass noise for one second with a LPF and gain ramp.
      var release=0.9
      source.playbackRate.setValueAtTime(0.4, now);
      source.playbackRate.linearRampToValueAtTime(0.37, now+release);
      source.loop = true;
      source.stop(now + release);
  
      var lp = ctx.createBiquadFilter(); // LPF
      lp.type = "lowpass";
      lp.frequency.value = 120;
      lp.Q.value = 0.5;
  
      var gain = ctx.createGain(); // Ramp
      gain.gain.setValueAtTime(0.7, now);
      gain.gain.linearRampToValueAtTime(0, now+release);
  
      source.connect(lp);
      lp.connect(gain);
      source = gain;
    }

    source.connect(ctx.destination);
  }
} // Drumkit


/******************************************************************************
  Create a playable synthesizer.

  USAGE::
    var Synth = new Synthesizer(ctx, Keyboard);

  CONSTRUCTOR PARAMETERS::
    A web audio context.
    An instantiated playable object.

  METHODS::
    Synth.play(key, when)  Plays key specified by the Keyboard object at
                           webaudio context time 'when' or immediately if
                           when==0.
    Synth.waveform()       Get current waveform string.
    Synth.waveformNext()   Select the next waveform.
******************************************************************************/
var Synthesizer = function (ctx, keyboard) {
  //// Local
  var _release = 0.5; // Release time in seconds for both the filter and gain.
  var _waveforms = ["sine", "square", "sawtooth", "triangle"];
  var _waveformIdx = 0;

  var _play = function (key, when) {
    var now = when==0 ? ctx.currentTime : when; // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
    var osc = ctx.createOscillator(); // Create and add to table if not already
    osc.frequency.value = keyboard.freq(key); // Ask the keyboard object for the frequency of this key
    osc.type = _waveforms[_waveformIdx];
    osc.start(now);
    osc.stop(now + _release);
    osc.onended = (function(osc){ return function() { osc.disconnect(); }})(osc);

    var gain = ctx.createGain();
    gain.gain.setValueAtTime(0.4, now);
    gain.gain.linearRampToValueAtTime(0, now + _release);

    osc.connect(gain);
    gain.connect(ctx.destination);

  }

  //// Public
  this.play = _play;
  this.waveform = function () { return _waveforms[_waveformIdx]; }
  this.waveformNext = function () {
    if (_waveforms.length == ++_waveformIdx) _waveformIdx=0;
  }
} // Synthesizer


/******************************************************************************
  Creates and maintains a sequence of keys to send a playable object over time.

  USAGE::
    var track = new Track(playableObject, defaultNote);

  CONSTRUCTOR PARAMETERS::

  METHODS::
    track.playable          Get the playable object
    track.element           Get the DOM element
    track.elementBeat(i)    Get the ith beat element
    track.elementTicks      get array of all tick elements.
    track.elementTick(i)    Get the ith tick element
    track.elementName       Get the DOM name element for this track
    track.backgroundBeat(i) Get ith beat's original background.
    track.backgroundTick(i) Get ith tick's original background.
    track.tickLength        Get number of ticks (notes, keys, whatever) this track contains.
    track.key(i)            Get the key at tick i.
    track.setKey(i, key)    Set the ith tick's key.
    track.setAllKeys        Set the default key or drum index.
    track.cursor()          Get the "cursor" representing one of the tick indice.
    track.setCursor(i)      Set the "cursor" tick index.
    track.play(tick, when)  Play the note at sequence 'tick'
    //track.tick(time)        Sequences all sounds from the web audio's context
                            current time through the specified 'time' parameter.
******************************************************************************/
var Track = function (ctx, beatCount, subBeatCount, playable) {
  //// Local
  var _beatCounter = 0;
  var _element; // The DOM element
  var _elementBeats = [];
  var _elementTicks = [];
  var _elementName;
  var _notes = []; // Each tick (beatCount * subBeatCount) gets its own key.
  var _beatOriginalBackground = [];
  var _tickOriginalBackground = [];
  var _cursor = -1;

  var _createElements = function () {
    var p;
    _element = document.createElement('div'); // Track element
    _element.className = "track";
    // Add beat elements to DOM
    for (b=0; (b < BeatCount); ++b) {
      var beatElement = CreateAppendChild('div', _element); // Beat element added to track element
      beatElement.className = "beat";
      beatElement.style.backgroundColor = ["#333", "#222", "#222", "#222"][_beatCounter++ % subBeatCount];
      // Keep track of the beat DOM element and its default background color.
      _elementBeats.push(beatElement);
      _beatOriginalBackground.push(beatElement.style.backgroundColor);
      for (t=0; (t < subBeatCount); ++t) {
        var tickElement = CreateAppendChild('p', beatElement); // Four tick elements added to each beat element
        tickElement.className = "tick"
        //var v = parseInt(window.location.search[1+track+(TrackCount+1)*beat], 16) // Consider prexisting beat state
        //tickElement.innerText = (v & 1<<i)? "X" : ".";
        tickElement.innerText = '.';
        // Keep track of the track DOM element and its default background color.
        _elementTicks.push(tickElement);
        _tickOriginalBackground.push(tickElement.style.backgroundColor); // Cache original background color of beat element
        _notes.push(b); // Build up the tick's key values.
      }
    }
    // Add sound name element to this track DOM element
    _elementName = CreateAppendChild('p', _element);
    _elementName.className = "name"
  }

  var _setAllKeys = function (key) {
    for (var t=0; t<_notes.length; ++t) { _notes[t] = key; }
  }

  // Construct
  _createElements();

  //// Public
  this.playable = playable;
  this.element = _element;
  this.elementBeat = function (i) { return _elementBeats[i]; }
  this.elementTicks = _elementTicks;
  this.elementTick = function (i) { return _elementTicks[i]; }
  this.elementName = _elementName;
  this.backgroundBeat = function (i) { return _beatOriginalBackground[i]; }
  this.backgroundTick = function (i) { return _tickOriginalBackground[i]; }
  this.tickLength = _notes.length;
  this.key = function (k) { return _notes[k]; }
  this.setKey = function (tick, key) { _notes[tick] = key; }
  this.setAllKeys = function (key) { _setAllKeys(key); }
  this.cursor = function () {return _cursor; }
  this.setCursor = function (i) { _cursor = i; }
  this.play = function (tick, when) { playable.play(_notes[tick], when); }
  //this.tick = function (time) { }
} // Track


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


DB.check((window.AudioContext || window.webkitAudioContext), "Audio context not found.");
var ctx = new (window.AudioContext || window.webkitAudioContext)();

var Noises = new AudioBuffersDB( // Object containg AudioBuffers derived from remote files
 ["808.bass.raw",
  "mom.raw",
  "808.snare.noise.raw",
  "808.maracas.raw",
  "808.cowbell.raw",
  "808.rim.raw",
  "808.highhat.closed.raw",
  "808.claves.raw",
  "808.clap.raw",
  "808.highhat.opened.raw",
  "808.cymbal.raw",
  "909.thump.raw",
  "909.snare.noise.raw"]);

var Keyboard;
var Synth; // The synthesizer object
var Drumkit; // The drumkit object
var Tracks = [];

var currentActiveTrack = false;  // This is the last track acted upon.
var setTrackTickKey = false; // HACK: This becomes a function that sets the key of some track.  Move this functionality into the piano keyboard object.

var ToggleButtonState = 0;
var TrackCount = Noises.length;
var BeatCount = 16;
var BeatDuration = .125  /* + 0.0625 +  0.03125;*/ // Keep timing binary friendly.


var pause = false;

var MouseIsDown = false;
window.onmouseup = function () { MouseIsDown = false; }
window.onkeydown = function () { if (event.keyCode == 191) DB.clear(); }



/******************************************************************************

 Keyboard, Synthesizer, and Tracks

******************************************************************************/

var setupKeyboard = function (keyboard) {
  // Register mouse event handlers for every DOM keyboard element representing a key.
  keyboard.keyElements.map(function (keyElement, key) {
    var _keyAction = function () {
      keyElement.style.backgroundColor="#0af"; // Set current key hilight
      currentActiveTrack.playable.play(key, 0);
    }
    keyElement.onmouseover = function() { if (MouseIsDown) { _keyAction(); } };
    keyElement.onmousedown = function() { MouseIsDown=true; _keyAction(); };
    keyElement.onmouseleave = function () {
      if (MouseIsDown) keyElement.style.backgroundColor="";
    }
    keyElement.onmouseup = function (event) {
      if (setTrackTickKey) setTrackTickKey(key);  // Evaluate the track callback passing the key/note index.  Generally this will be used to set the key/note in the track at its cursor position.
      else if (MouseIsDown) keyElement.style.backgroundColor="";
    }
  });//map function
} // setupKeyboard()


/* The synth tracks all share one cursor for the keyboard.  It could be the case that there are multiple keyboards.  This means the keyboard should keep track of which track and tick the cursor is.
*/

  var currentMouseOverElement = false; // For some reason, mouseleave can occur after mouseover.  This is used to ignore mouseover should it be on an element the mouse is not on any more.
  var currentPianoKey = -1;
function setupSynthTrack (track) {

  track.elementTicks.map(function (tickElement, t) {

    tickElement.onmouseover = function (event) { // TODO move this elsewhere just like onmousedown
      currentMouseOverElement = event.srcElement;
      currentPianoKey = track.key(t);
      Keyboard.keyElement(track.key(t)).style.backgroundColor="yellow";
      if (0 == ToggleButtonState) {
        ToggleButtonState = this.innerText == "." ? 1 : 2;
      }
      if (MouseIsDown) this.innerText = ToggleButtonState == 1 ? "X" : "."
      if (this.innerText=="X") track.playable.play(track.key(t), 0);
    }

    tickElement.onmouseleave = function (event) { // TODO move this elsewhere just like onmousedown
      if (event.srcElement == currentMouseOverElement) {
        currentMouseOverElement = false;
        currentPianoKey = -1;
        Keyboard.keyElement(track.key(t)).style.backgroundColor = "";
        if (currentActiveTrack && 0 <= currentActiveTrack.cursor()) Keyboard.keyElement(currentActiveTrack.key(currentActiveTrack.cursor())).style.background = "blue";
      } else if (track.key(t) != currentPianoKey) {
        Keyboard.keyElement(track.key(t)).style.backgroundColor = "";
      }
    }

    tickElement.onmousedown = function (event) {
      var c;
      MouseIsDown = true;

      if (currentActiveTrack && 0 <= currentActiveTrack.cursor()) Keyboard.keyElement(currentActiveTrack.key(currentActiveTrack.cursor())).style.background = ""; // Erase old keyboard active tick key

      if (currentActiveTrack != track) { // A different track has been acted on.  This will be the new target for the keyboard programming event.
        if (currentActiveTrack && 0 <= currentActiveTrack.cursor()) { // The cursor exists and needs to be removed from the old track.
          c = currentActiveTrack.cursor();
          currentActiveTrack.elementTick(c).style.backgroundColor = currentActiveTrack.backgroundTick(c);
          currentActiveTrack.setCursor(-1);
        }
        currentActiveTrack = track; // Update last track to this new one
      }

      c = track.cursor();

      // Set keyboard key for new current track tick
      Keyboard.keyElement(currentActiveTrack.key(t)).style.background = "blue"; // Set keyboard key to this active track's tick

      if (c == t) { // Current cursor is this tick, just toggle the tick's status on/off.
        ToggleButtonState = this.innerText == "." ? 1 : 2;
        this.innerText = ToggleButtonState == 1 ? "X" : "."
      } else {
        if (0 <= track.cursor()) {
          track.elementTick(c).style.backgroundColor = track.backgroundTick(c);
        }
        tickElement.style.backgroundColor = "blue";
        // If the note is active, keep it active, otherwise active it
        if (this.innerText  == "X") {
          ToggleButtonState = 1;
        } else {
          ToggleButtonState = 1;
          this.innerText = "X";
        }
        track.setCursor(t);
      }
 
      // Callback for the keyboard to set this current new track's tick's key/note value.
      setTrackTickKey = function (k) {
        if (currentActiveTrack && 0 <= currentActiveTrack.cursor()) Keyboard.keyElement(currentActiveTrack.key(currentActiveTrack.cursor())).style.background = ""; // Erase old keyboard active tick key
        track.setKey(t, k);
        Keyboard.keyElement(currentActiveTrack.key(t)).style.background = "blue"; // Set keyboard key to this active track's tick
      }

      // Play the note
      if (this.innerText=="X") track.playable.play(track.key(t), 0);
    };

    tickElement.onmouseup = function (event) {
    }

    //var j = 1+(TrackCount+1)*BeatCount; // Start of the 2 hex character note indices
    //j += 2*(beat*4 + i);
    //PianoSequencerNotes[beat*4 + i] = parseInt(window.location.search.substring(j, j+2), 16)|0;
    //var v = parseInt(window.location.search[1+track+(TrackCount+1)*beat], 16) // Consider prexisting beat state
    //tickElement.innerText = (v & 1<<i)? "X" : ".";
  }); // map function
}

function setupDrumTrack (track) {
  track.elementTicks.map(function (tickElement, t) {

    tickElement.onmousedown = function (event) {
      MouseIsDown = true;
      ToggleButtonState = this.innerText == "." ? 1 : 2;
      this.innerText = ToggleButtonState == 1 ? "X" : "."
      if (this.innerText=="X") track.playable.play(track.key(t), 0);
    }

    tickElement.onmouseover = function (event) {
      if (0 == ToggleButtonState) {
        ToggleButtonState = this.innerText == "." ? 1 : 2;
      }
      if (MouseIsDown) this.innerText = ToggleButtonState == 1 ? "X" : "."
      else if (this.innerText=="X") track.playable.play(track.key(t), 0);
    }
  }); // map function
}

var createTracks = function (synths, drumKit) {
  var rythmDOM = document.getElementById("rythm"); // Consider the rythm block where the tracks will live.
  var track;

  // Create synth tracks which are kept track of in global 'Tracks'
  for (c=0; (c < synths.length); ++c) {
    Tracks.push(track = new Track(ctx, 16, 4, synths[c]));
    track.elementName.innerText = track.playable.waveform();
    track.elementName.onmousedown = (function (track) { return function () {
      track.playable.waveformNext();
      track.elementName.innerText = track.playable.waveform();
    }})(track);
    rythmDOM.appendChild(track.element);
    setupSynthTrack(track);
  }

  currentActiveTrack = Tracks[0]; // Make sure the keyboard can make sounds initially.

  // Create beat tracks which are kept track of in global 'Tracks'
  for (i=0; (i < Noises.length); ++i) {
    Tracks.push(track = new Track(ctx, 16, 4, drumKit));
    track.elementName.innerText = Noises.fileName(i);
    track.setAllKeys(i);
    track.elementName.onmousedown = (function(track, key) { return function () { track.play(key, 0); }})(track, i);
    rythmDOM.appendChild(track.element);
    setupDrumTrack(track);
  }
} // createTracks



/******************************************************************************

 Event loops

******************************************************************************/
var LastRenderedTick = -1;
var BeatLast = 0; // Quarter beat
var Beat = 0; // Forever incrementing
var pattern="";
var sum = 0;


/* Periodically highlight whatever beat (and all sub-beats) should be playing
   currently.  It uses the web audio context's currentTime as a time reference.
*/
var rendererLoop = function () {
    if (pause) return;
    var t;
    var tick = Floor(ctx.currentTime / (BeatDuration/4)) % (BeatCount*4); // Realtime tick (16th beat)
    var beat = Floor(tick/4); // 1/4 beat

    if (LastRenderedTick == tick) return;

    for (t=0; (t < Tracks.length); ++t) {
      // 1/4th beat rendering
      Tracks[t].elementBeat(BeatLast).style.backgroundColor = Tracks[t].backgroundBeat(BeatLast);
      Tracks[t].elementBeat(beat).style.backgroundColor = "green";
    }
    LastRenderedTick = tick;
    BeatLast = beat;
}

/* Periodically tell the various tracks to send their audio out to the audio
   context.
*/
var sequencerLoop = function () { // HACK: The sequencer
  if (pause) return;
  while ((Beat * BeatDuration) <= (ctx.currentTime + 1.0)) { // Perform up to one second in the future

/*
    if (0 == (Beat % BeatCount)) { //  On the initial beat, upate the URL's get string.
      for (i=0; i<PianoSequencerNotes.length; ++i) // Add the note values for the synth track
         pattern += (PianoSequencerNotes[i]<16?"0":"") + PianoSequencerNotes[i].toString(16);
      window.history.replaceState("ohhai", "Digital Audio Workstation", document.location.href.split('?')[0] + '?'  + pattern);
      pattern="";
    }
*/
    for (var t=0; (t < Tracks.length); ++t) {
      sum = 0;
      for (s=0; s<4; ++s) {
        var note = Tracks[t].elementTick(4*(Beat%BeatCount) + s).innerText;
        if ('.' != note ) {
            Tracks[t].play((Beat%BeatCount)*4 + s, Beat * BeatDuration + (s*BeatDuration)/4);
          sum += 1<<s; // Add the 16th notes giving a value between 0x0 and 0xf (used in the URL's get string);
        } //if
      } // sub beats
      pattern = pattern + sum.toString(16);
    } // beats
    Beat += 1.0;
  } // while
}



/******************************************************************************

 Main

******************************************************************************/
window.onload = function () {
  DB("::onload");

  Keyboard = new PianoKeyboard("piano", 39, 0, 1, 130.813); // Create a piano in the dom.  SID 4 EVR
  Synth    = new Synthesizer(ctx, Keyboard);
  Synth2   = new Synthesizer(ctx, Keyboard);
  Synth3   = new Synthesizer(ctx, Keyboard);
  DrumKit  = new Drumkit(ctx, Noises);
  setupKeyboard(Keyboard); // Give the piano immediate playing capability
  createTracks([Synth, Synth2, Synth3], DrumKit);
  setInterval(rendererLoop, 50);
  setInterval(sequencerLoop, 50);

  DB("--onload [" + DB.status() + "]");
}



//]]></script>

</body></html>
