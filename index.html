<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
 <title>Digital Audio Workstation bEtA</title>
 <link rel="stylesheet" href="index.css" type="text/css" media="screen" title="Shrewm"/>
</head>
<body Zoncontextmenu="return false;">

<p id="noDB" style="width:30em; background:black; z-index:2; border:solid 1px green; white-space:pre; overflow:auto; max-height:20em; position:fixed; right:0; bottom:0"></p>

<h1>Digital Audio Workstation bEtA &#x2669; &#x266b; &#x266a; &#x266c; &#x266d; &#x266e; &#x266f;</h1>
<hr/>
<p class="mainNav">
 <a href="http://webaudio.github.io/web-audio-api/">[WebAudio]</a>
 <a href="http://validator.w3.org/check/referer">[XHTML 1.0]</a>
 <a href="http://jigsaw.w3.org/css-validator/check/referer/">[CSS 2.1]</a>
</p>

<div class="window">
  <div><p style="background:#088">TIMING</p></div>
  <div class="knobs">
	<p id="speed" Ztabindex="0" contenteditable="true">120</p>
	<p class="reset" onmousedown="reset(event)">|&lt;</p>
	<p class="pause" onmousedown="pause(event)">||</p>
  </div>
</div>

<div class="window">
  <div><p style="background:#888">KEYBOARD</p></div>
  <div style="display:inline-block; margin-left:1em; margin-top:-2px; border:solid 2px #888">
    <p id="freq" Ztabindex="0" style="display:inline-block; background:#00a; color:#eee" contenteditable="true">65.4064</p>
    <div>
      <div id="piano1" class="piano" style="white-space:nowrap"></div>
    </div>
  </div>
</div>

<div><div class="window">
  <div>
    <p>MAIN SHEET</p>
  </div>
  <div id="sheet" class="sheet">
    <div class="addphrase">
      <div onmousedown="addphrase(event)">add</div>
      <div>
        <p contenteditable="true">4</p>
        <p contenteditable="true">4</p>
        <p contenteditable="true">4</p>
      </div>
    </div>
  </div>
</div></div>

<div><div class="window">
  <div><p>PHRASE EDITOR</p></div>
  <div id="phrases" class="phrases"></div>
</div></div>

<div id="save" style="width:320ch; overflow-wrap:break-word"></div>

<img id="pauseicon" style="display:none; position:fixed; border-radius:50%" src="catpause.gif"/>

<script type="text/javascript">//<![CDATA[
"use strict"

/******************************************************************************
  Useful aliases and objects
******************************************************************************/
var Floor = Math.floor;
var Ceil  = Math.ceil;
var Pow   = Math.pow;
var Abs   = Math.abs;
var Rnd   = Math.random;
var Mod   = function (n,d) { return n - d * Math.floor(n/d); }
var CreateAppendChild = function (name, element) { return element.appendChild(document.createElement(name)); }
var CreateInsertBefore = function (name, element) { return element.insertBefore(document.createElement(name), element.firstChild); }
var toggleElementDisplay = function (e1, e2) {
  // Toggle e1's display:none style
  e1.style.display = (e1.style.display=="none" ? "" : "none");
  // e2's style is opposite.
  if (e2) { e2.style.display = (e1.style.display == "none" ? "" : "none"); }
}


/******************************************************************************
  Debug message console and error checking

  DOM requirements::
    <p id="DB"></p>        -- If nonexistent, the DB object will revert to using the browser's console.

  Usage::
    DB("string")           -- Send string to info window.  Behaves like a pre element.
    DB.log("string")       -- Send string to console.log.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.clear()             -- Empty the entire DB element.
    DB.check(expr, string) -- If expr is false, send string to console.  status() will then always return false.
    DB.status()            -- Returns false if check ever failed.
******************************************************************************/
var DB = (function () {
  var consoleElement = document.getElementById('DB');
  var self;
  var status = true;
  var shouldNewline = true; // Want to prepend a newline when the last message was plain text.
  var lastPostType = false;

  var setStyles = function (e) {
    return;
    e.style.border = "solid 1px green";
    e.style.whiteSpace = "pre";
    e.style.overflow = "auto";
    e.style.maxHeight = "20em";
  }

  // Create the instance which is a function.  Also create the clear function.
  if (!consoleElement) {
    self = function (s) { console.log(s); lastPostType = false;}
    self.log = self;
    self.post  = function (t, s) { // For the console, only the first post type is displayed.
      if (t != lastPostType) {
        console.log("[" + t + "]" + s);
        lastPostType = t;
      }
    }
    self.clear = function () { lastPostType = false; }
  } else {
    setStyles(consoleElement);
    self = function (s) {
      consoleElement.innerHTML += (shouldNewline ? "" : "\n") + s;
      consoleElement.scrollTop = consoleElement.scrollHeight;
      shouldNewline = lastPostType = false;
    }
    self.log = function (s) { console.log(s); }
    self.post = function (t, s) {
      if (t == lastPostType) {
        consoleElement.lastChild.innerText = "[" + t + "]" + s;
      } else {
        consoleElement.appendChild(document.createElement('p')).innerText = "[" + t + "]" + s; 
        consoleElement.scrollTop = consoleElement.scrollHeight;
        lastPostType = t;
      }
      shouldNewline = true;
    }
    self.clear = function () {
       consoleElement.innerHTML = "";
      shouldNewline = lastPostType = true;
    }
  }

  self.check = function (expr, msg) {
    status = status && expr;
    return expr || self(msg) && false;
  }

  self.status = function () { return status; }

  return self;
})(); // DB


/******************************************************************************
  Base64 encoder and decoder

  USAGE::
    Base64([1,2,3])  Returns a base64 encoded string of the byte (0..255)
                     values in the array.
    Base64("0G83")   Returns a decoded base64 string as an array of bytes
                     values.

    Base64.encode()  Explicit call.
    Base64.decode()  Explicit call.
    Base64.test(ary) Runs an internal test.  Calls DB.check(ary) on the
                     comparision of the output of the encoding then decoding
                     of the passed byte array.
  ALGORITHM NOTES::
    An incomplete octet will be correctly created because
       emptyArray[0]      => undefined
       undefined >> num   => 0
******************************************************************************/
var Base64 = (function () {
  // Private
  var self;
  var base64table = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','-','_'];

  var _encode = function (ary) {
    var ary1 = ary.slice(0); // Copy the array since I shift the elements off.
    var octet=0;     // Which octet to create
    var str = ""; // The encoded string
    while (ary1.length) {
      str +=
        base64table[(0 == octet) ? ary1[0] >> 2 :                              // [000000..]
                    (1 == octet) ? ((ary1.shift() & 3) << 4) + (ary1[0] >> 4) :// [......00][1111....]
                    (2 == octet) ? ((ary1.shift() & 15) << 2) + (ary1[0] >> 6) //           [....1111][22......]
                   /*3 == octet*/: ary1.shift() & 63];                         //                     [..222222]
      octet = ++octet & 3;
    }
    return str;
  }

  var _decode = function (str) {
    var ary=[];
    var i=0, byte;
    while (i < str.length) {
      ary.push((base64table.indexOf(str[i]) << 2) + (base64table.indexOf(byte=str[++i]) >> 4)); // [000000][00....]
      if (++i == str.length) break;
      ary.push(((base64table.indexOf(byte)&15) << 4) + (base64table.indexOf(byte=str[i]) >> 2));//         [..1111][1111..]
      if (++i == str.length) break;
      ary.push(((base64table.indexOf(byte)&3) << 6) + (base64table.indexOf(str[i])));           //                 [....22][222222]
      if (++i == str.length) break;
    }
    return ary;
  }

  var _test1 = function (ary) {
    str = Base64(ary);
    ary2 = Base64(str);
    DB.check((ary.toString() == ary2.toString()), ary + " != " + ary2);
  }

  var _test = function () {
    _test1([]);
    _test1([0]);
    _test1([1]);
    _test1([2]);
    _test1([255]);
    _test1([1,255]);
    _test1([255,1]);
    _test1([255,1]);
    _test1([255,1,255]);
    _test1([255,1,255]);
    _test1([1,255,1]);
    _test1([0,0,0,0,0]);
    _test1([0,0,0,0,255]);
    _test1([255,0,0,0,0]);
    _test1([1,1,1,1,1]);
    _test1([255,255,255,255,255]);
  }

  //// Public
  self = function (o) {
    if (Array.isArray(o)) return _encode(o);
    else if (typeof o == "string") return _decode(o);
    else return false;
  }
  self.encode = _encode;
  self.decode = _decode;
  self.test = _test;

  return self;
})();



/******************************************************************************
  Create a piano keyboard in the DOM.  It emulates a keyboard controlled
  oscillator.

  USAGE::
    var Keyboard = new PianoKeyboard(id, keyCount, startKey, startOctave, startFrequency);

  CONSTRUCTOR PARAMETERS::
    id             DOM element id to add the new piano element.
    keyCount       Number of keys
    startKey       Initial key (0==C, 1==C#, ... 11=B)
    startOctave    Initial octave
    startFrequency First specified key's frequency

  METHODS::
    Keyboard.keyElements           All key DOM elements in an array
    Keyboard.keyElement(key)       Get the DOM element representing the white or black key  Indexed between 0 and number of keys-1.
    Keyboard.freq(key)             Frequency of key.
    Keyboard.setStartFrequency(f)  Reset the base frequencies of the keyboard (first note's frequency)
    Keyboard.highlight(key, color);Highlight the key using color.  Overrides its last color, if any.
    Keyboard.unhighlight(key);     Removes last/top highlighted color and reverts to its previous color (if any)
******************************************************************************/
var PianoKeyboard = function (id, keyCount, startKey, startOctave, startFrequency) {

  //// Private

  var _pianoDOM = document.getElementById(id);
  DB.check(_pianoDOM, "ERROR: PianoKeyboard: Element id=" + id + " not found in DOM.");

  var _keysDOM = []; // Keeps track of the DOM elements which represent the white and black keys in order.
  var _frequencies = [];
  var _highlights = []; // Array of stacks.  An empty stack implies no high-light.

  var _createDOM = function () {
    var notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    var sharps = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0]; // Bool table of sharps in an octave, starting at C
    var newKey, keyPair = false; // The piano DOM is composed of divs containing either just a div (white key) or div and p (white and black key)
    startKey += startOctave * 12; // Adjust initial key to account for octave
    for (var k=0; (k < keyCount); ++k) {

      if (sharps[(k + startKey)%12]) {
        // Create the sharp key
        newKey = CreateAppendChild('p', _pianoDOM);
      } else {
        // Create the natural key
        var note   = (k + startKey) % 12;
        var octave = Floor((k + startKey) / 12);
        newKey = CreateAppendChild('div', _pianoDOM)
        // add the note's textual label including the octave number.
        newKey.innerText = notes[note] + (note==0?octave:'');
      }

      _keysDOM.push(newKey); // Keep track of each created key.
      _frequencies.push(startFrequency * Pow(2, k/12.0));
      _highlights.push([]);
    }
  }

  // Construct

  _createDOM();
  DB.check(keyCount == _keysDOM.length, "ERROR: PianoKeyboard: Created incorrect number of keys.");
  DB.check(keyCount == _frequencies.length, "ERROR: PianoKeyboard: Created incorrect number of frequencies.");

  // Public

  this.keyElements = _keysDOM;
  this.keyElement = function (i) { return _keysDOM[i]; }
  this.freq = function (k) { return _frequencies[k] + Rnd(); } // Adding a random [0..1] value to the freq in an attempt to get rid of beating.  Ended up with a phaser effect when equal notes are played instead.
  this.setStartFrequency = function (newStartFrequency) {
    for (var i=0; (i < keyCount); ++i) _frequencies[i] = newStartFrequency * Pow(2, i/12.0);
  }
  this.highlight = function (key, color)  {
    if ((0 <= key) && (key < keyCount)) {
      _highlights[key].push(color);
      _keysDOM[key].style.backgroundColor = color;
    }
  }
  this.unhighlight = function (key, color) {
    var i;
    var stk = _highlights[key];
    if (!stk) return; // If invalid key, retutn
    if (color) { // Remove color from stack (could be anywhere)
      i = stk.indexOf(color);
      if (-1 < i) { stk.splice(i, 1); }
    } else {
      stk.pop(); // If no color passe, pop last color
    }
    // Set the key's color to the top of the stack
    i = stk.length;
    _keysDOM[key].style.backgroundColor = (0 < i) ? stk[i-1] : "";
  }
} // PianoKeyboard 


/******************************************************************************
  Database of Web Audio audio buffers.  It will download and convert raw audio
  files into ready to use AudioBuffers.

  USAGE::
    var noises = new AudioBuffers(filenames)

  METHODS::
    noises.length          Number of files loaded.
    noises.fileName(i)     Get a filename.
    noises.audioBuffer(i)  Get an audio buffer or undefined.
******************************************************************************/
var AudioBuffers = function (ctx, filenames) {
  // Private
  var _audioBuffers = [];

  function _Validate () {
    if (!DB.check(filenames && Array.isArray(filenames), "ERROR: AudioBuffersdb: Invalid filenames ary.")) {
      filenames = [];
    }
  }

  function _loadRawAudioFiles () {
    filenames.forEach(function (fn, i) { // forEach passes in each ary element and the index.
      var client = new XMLHttpRequest();
      client.open('GET', fn);
      client.responseType = "arraybuffer";
      client.onreadystatechange = // Callback after remote file has been loaded
        function (e) {
          if (4 != client.readyState) return;
          var statusState = ((200 == client.status) || (0 == client.status) && (null != client.response)); // When loaded locally with --allow-file-access-from-files, status is 0 so must check client.response instead
          DB.check(statusState, "ERROR: AudioBuffers: " + client.status + " '" + (client.responseURL || fn) + "'");
          if (statusState) {
            //DB.log("LOADED " + fn);
            var samples = new Int16Array(client.response); // Consider u8 ary as s16 ary.
            // Normalized each s16 sample to f32 between -1 and 1.
            var Noise =  new Float32Array(samples.length);
            for (var j=0; j<samples.length; ++j) {
              Noise[j] = samples[j]/32768;
            }
            // Create and set the audio buffer
            _audioBuffers[i] = ctx.createBuffer(1, samples.length, 44100);
            _audioBuffers[i].getChannelData(0).set(Noise);
          } // if
        } // function()
      client.send();
    }); // forEach function
  } // function

  // Construct

  _Validate();
  _loadRawAudioFiles();

  // Public

  this.length = filenames ? filenames.length : 0;
  this.fileName = function (i) { return filenames[i]; }
  this.audioBuffer = function (i) { return _audioBuffers[i]; }
} // AudioBuffers 


/******************************************************************************
  Create a playable drumkit.  Expects a webaudio context and Audio Buffers DB.

  USAGE::
    var DrumKit = new Drumkit(ctx, color, audioBuffers);

  CONSTRUCTOR PARAMETERS::
    An web audio context and audio buffers object.

  METHODS::
    Drumkit.color                 Color associated with this object
    Drumkit.name(pad)             String describing the pad.  Usually the drum sound.
    DrumKit.play(pad, vol, when)  Plays an audiobuffer sample specified by pad at
                                  volume vol at time when or now if when==0.
******************************************************************************/
var Drumkit = function (ctx, color, audioBuffers) {
  //// Local
  var bassReleaseTime = 0.8; // Release time in seconds for both the filter and gain.
  //// Public
  this.name = function (pad) {
    return (undefined == pad) ? "TR-808" : audioBuffers.fileName(pad);
   }
  this.color = color
  this.play = function (pad, vol, when) {
    var audioBuffer = audioBuffers.audioBuffer(pad);
    if (!audioBuffer) return; // Do nothing if no audio buffer.
    var gain;
    var now = (when || ctx.currentTime); // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
    var source = ctx.createBufferSource();
    source.buffer = audioBuffer;
    source.onended = function() { source.disconnect(); } // When the audio stops, remove it from the graph.
    var gain = ctx.createGain(); // Ramp

    if (pad == 0) { // HACK: need to generalize a sound pipeline
      // Loop the bass noise for one second with a LPF and gain ramp.
      source.playbackRate.setValueAtTime(0.39, now);
      source.playbackRate.linearRampToValueAtTime(0.37, now+bassReleaseTime);
      source.loop = true;
      source.start(when);
      source.stop(now + bassReleaseTime);

      var lp = ctx.createBiquadFilter(); // LPF
      lp.type = "lowpass";
      lp.frequency.value = 120;
      lp.Q.value = 0.5;

      gain.gain.setValueAtTime(vol, now);
      gain.gain.linearRampToValueAtTime(0, now+bassReleaseTime);

      source.connect(lp);
      lp.connect(gain);
    } else {
      gain.gain.value = vol;
      source.connect(gain);
      source.start(when);
    }

    gain.connect(ctx.destination);
  }
} // Drumkit


/******************************************************************************
  Create a playable synthesizer.

  USAGE::
    var Synth = new Synthesizer(ctx, keyboard, color);

  CONSTRUCTOR PARAMETERS::
    A web audio context.
    An instantiated playable object.

  METHODS::
    Synth.color                Color associated with this object
    Synth.name(key)            Name associated with this key.  Default is the synth waveform name, each key.
    Synth.play(key, vol, when) Plays a waveform at a freq determined by the Keyboard object at the
                               specified key, at webaudio context time 'when' or immediately if when==0.
    Synth.waveform()           Get current waveform string.
    Synth.waveformNext()       Select the next waveform.
    Synth.highlight(key)       Highlight the keyboard object's key with my color.
    Synth.unhighlight()        Remove my highlight from the keyboard object.
******************************************************************************/
var Synthesizer = function (ctx, type, keyboard, color) {
  //// Local
  var _release = 0.5; // Release time in seconds for both the filter and gain.
  var _waveforms = ["sine", "square", "sawtooth", "triangle"];
  var _waveformIdx = type;

  var _play = function (key, vol, when) {
    var now = when==0 ? ctx.currentTime : when; // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
    var osc = ctx.createOscillator(); // Create and add to table if not already
    osc.frequency.value = keyboard.freq(key); // Ask the keyboard object for the frequency of this key
    osc.type = _waveforms[_waveformIdx];
    osc.start(now);
    osc.stop(now + _release);
    osc.onended = (function(osc){ return function() { osc.disconnect(); }})(osc);

    var gain = ctx.createGain();
    gain.gain.setValueAtTime(vol*0.5, now);
    gain.gain.linearRampToValueAtTime(0, now + _release);

    osc.connect(gain);
    gain.connect(ctx.destination);
  }

  //// Public
  this.color = color
  this.name = function (note) { return this.waveform(); }
  this.play = _play;
  this.waveform = function () { return _waveforms[_waveformIdx]; }
  this.waveformNext = function () {
    if (_waveforms.length == ++_waveformIdx) _waveformIdx=0;
  }
  var lastKey = -1;
  this.highlight = function (key) {
      keyboard.unhighlight(lastKey, color); // Remove last high-light
      keyboard.highlight(key, color); // Set new high-light
      lastKey = key
  };
  this.unhighlight = function () {
    keyboard.unhighlight(lastKey, color); // Remove last high-light
  };
} // Synthesizer


/******************************************************************************
  Creates and maintains a sequence of notes to send a playable object over time.
  The phrase objects are the usual holder of parts.

  USAGE::
    var part = new Part(idElement, beatCount, subBeatCount, beatsPerMeasure, playableObject);

  CONSTRUCTOR PARAMETERS::
    idElement        ID string
    beatCount        Number of total beats (measures * beatspermeasure)
    subBeatCount     Number of subbeats per beat
    beatsPerMeasure  Length of measure.  Used to determine beat highlighing in the tracks.
    playableObject   An object that makes sound

  METHODS::
    .playable          Get the playable object
    .element           Get the part's full DOM element
    .elementBeat(i)    Get the ith beat element
    .ticksPerBeat      Return ticks per beat count / subBeatCount
    .elementTicks      get array of all tick elements.
    .elementTick(i)    Get the ith tick element
    .elementName       Get the name element for this part
    .backgroundBeat(i) Get ith beat's original background.
    .backgroundColor(i)Get ith tick's original background color.
    .tickLength        Get number of ticks (notes, keys, whatever) this part contains.
    .key(i)            Get the key at tick i.
    .setKey(i, key)    Set the ith tick's key.
    .setAllKeys        Set the default key or drum index.
    .cursor()          Get the "cursor" representing one of the tick indices.
    .setCursor(i)      Set the "cursor" tick index.
    .vol()             Get volume (default = 0.5).
    .setVol(v)         Get volume.
    .play(tick, when)  Play the key or pad at tick 'tick'
    .playTicks(beat, when) Play the ticks at the specified beat starting at when.
******************************************************************************/
var Part = function (idElement, beatCount, subBeatCount, beatsPerMeasure, playable) {
  //// Local
  var _beatCounter = 0;
  var _element; // The DOM element  TODO rename this
  var _elementBeats = [];
  var _elementTicks = [];
  var _volPad, _elementVolume, _elementName;
  var _notes = []; // Each tick (beatCount * subBeatCount) gets its own key.
  var _beatOriginalBackground = [];
  var _tickOriginalBackground = [];
  var _cursor = -1;
  var _vol = 0.4;

  var _createPhraseElement = function () {
    var p;
    _element = document.createElement('div'); // DOM element
    _element.className = "part";
    // Add beat elements to DOM

    if (idElement) { _element.appendChild(idElement); }

    for (var b=0; (b < beatCount); ++b) {
      var beatElement = CreateAppendChild('div', _element); // Beat element added to part element
      beatElement.className = "beat";
      beatElement.style.backgroundColor = (0 == (_beatCounter++ % beatsPerMeasure)) ? "#333" : "#222";
      // Keep track of the beat DOM element and its default background color.
      _elementBeats.push(beatElement);
      _beatOriginalBackground.push(beatElement.style.backgroundColor);
      for (var t=0; (t < subBeatCount); ++t) {
        var tickElement = CreateAppendChild('p', beatElement); // Four tick elements added to each beat element
        tickElement.className = "tick"
        tickElement.innerText = '.';
        // Keep track of the part DOM element and its default background color.
        _elementTicks.push(tickElement);
        _tickOriginalBackground.push(tickElement.style.backgroundColor); // Cache original background color of beat element
        _notes.push(b); // Build up the tick's key values.
      }
    }
    // Add an edit/menu element.
    _elementVolume = CreateAppendChild('p', _element);
    _elementVolume.className = "menu"
    _elementVolume.style.position = "relative"
    _elementVolume.innerText = "[V]"

    _volPad = CreateAppendChild('p', _elementVolume);
    _volPad.style.position = "absolute"
    _volPad.style.top = 0;
    _volPad.style.left = 0;
    _volPad.innerText = " .,.....\n,,......\n........\n........\n........\n........\n.......@\n......@@";
    _volPad.style.display="none";
    _volPad.style.background="#242";
    _volPad.style.zIndex = "1";
    _elementVolume.onmousedown = function () {
      MouseIsDown = true;
      _volPad.style.display="block";
    }
    _volPad.onmousemove = function (event) {
      var mx = (event.clientX - event.target.getBoundingClientRect().left) / 87;
      var my = (event.clientY - event.target.getBoundingClientRect().top) / 183;
      _vol = my * 0.9 + mx * 0.1;
    }
    _volPad.onmouseleave  = function () { _volPad.style.display="none"; }
    _volPad.onmousedown = function () { event.stopPropagation(); }
    _volPad.onmouseup = function () { if (!MouseIsDown) { event.stopPropagation(); _volPad.style.display="none";} }
    
    // Add sound name element to this part DOM element
    _elementName = CreateAppendChild('p', _element);
    _elementName.className = "name"
  }

  var _setAllKeys = function (key) {
    for (var t=0; t<_notes.length; ++t) { _notes[t] = key; }
  }

  // Construct
  _createPhraseElement();

  //// Public
  this.playable = playable;
  this.element = _element;
  this.elementBeat = function (i) { return _elementBeats[i]; }
  this.ticksPerBeat = subBeatCount;
  this.elementTicks = _elementTicks;
  this.elementTick = function (i) { return _elementTicks[i]; }
  this.elementName = _elementName;
  this.backgroundBeat = function (i) { return _beatOriginalBackground[i]; }
  this.backgroundColor = function (i) { return _tickOriginalBackground[i]; }
  this.tickLength = _notes.length;
  this.key = function (k) { return _notes[k]; }
  this.setKey = function (tick, key) { _notes[tick] = key; }
  this.setAllKeys = function (key) { _setAllKeys(key); }
  this.cursor = function () {return _cursor; }
  this.vol = function () {return _vol; }
  this.setVol = function (v) {_vol = v; }
  this.setCursor = function (i) { _cursor = i; }
  this.play = function (tick, when) { playable.play(_notes[tick], _vol, when); }
  this.playTicks = function (beat, when) {
    if (0 == when) when = ctx.currentTime; // If someone wants this beat played now, compensate otherwise it will be "played in the past".
    for (var t=0; (t < subBeatCount); ++t) {
      var _tick = subBeatCount * beat + t; // Compute the tick offset.
      if ('.' == _elementTicks[_tick].innerText) continue;
      this.play(_tick, when + (t * BeatDuration / subBeatCount)); // Play each tick's note in succeeding tick durations.
    }
  }
} // Part



/******************************************************************************
 keyboard, synthesizer, and phrases
******************************************************************************/

var setupKeyboard = function (keyboard) {
  var _pressedColor = "#0af"
  // Register mouse event handlers for every DOM keyboard element representing a key.
  keyboard.keyElements.map(function(keyElement, key){
    var _setHighlight = function(){
      keyboard.highlight(key, _pressedColor); // Set current key hilight
      currentActiveSynthPart.playable.play(key, currentActiveSynthPart.vol(), 0);
    }
    var _unsetHighlight = function(){
      keyboard.unhighlight(key, _pressedColor);
    }
    keyElement.onmouseover  = function(){ if (MouseIsDown) { _setHighlight(); } };
    keyElement.onmousedown  = function(){ MouseIsDown=true; _setHighlight(); };
    keyElement.onmouseleave = function(){ _unsetHighlight(); }
    keyElement.onmouseup = function (event) {
      _unsetHighlight();
      if (SetPartTick) SetPartTick(key);  // Evaluate the part callback passing the key/note index.  Generally this will be used to set the key/note in the part at its cursor position.
    }
  }); //map function
} // setupKeyboard()


/* The synth tracks all share one cursor for the keyboard.  It could be the case that there are multiple keyboards.  This means the keyboard should keep track of which part and tick the cursor is.
*/
var currentMouseOverElement = false; // For some reason, mouseleave can occur after mouseover.  This is used to ignore mouseover should it be on an element the mouse is not on any more.
var currentPianoKey = -1;

function setupSynthPart (part, keyboard) {

  part.elementTicks.map(function (tickElement, t) {

    tickElement.onmouseover = function (event) {
      // If mousing over a key but still on another key, remove other key's high-light
      if (currentMouseOverElement) {
        keyboard.unhighlight(currentPianoKey, "yellow")
      }
      // Set this key's high-light
      currentMouseOverElement = event.target;
      currentPianoKey = part.key(t);
      keyboard.highlight(currentPianoKey, "yellow")

      if (MouseIsDown) this.innerText = ToggleButtonState == 1 ? "X" : "." // If dragging mouse while down, set note
      if (this.innerText=="X") part.playable.play(currentPianoKey, part.vol(), 0); // Play note if on
    }

    tickElement.onmouseleave = function (event) {
      if (event.target == currentMouseOverElement) { // Leaving a tick that we are still on.
        keyboard.unhighlight(currentPianoKey, "yellow")
        currentMouseOverElement = false;
        currentPianoKey = -1;
      }
    }

    tickElement.onmousedown = function (event) {
      MouseIsDown = true; // Set global state

      // Unset keyboard key and part cursor (if active)
      if (0 <= currentActiveSynthPart.cursor()) {
        var c = currentActiveSynthPart.cursor();
        keyboard.unhighlight(currentActiveSynthPart.key(c), "blue"); // Erase keyboard's tick high-light
        currentActiveSynthPart.elementTick(c).style.backgroundColor = currentActiveSynthPart.backgroundColor(c); // Erase tick's high-light.
      }

      // At this point, no tick nor keyboard key is high-lighted with the blue

      var sameHighlight = (currentActiveSynthPart == part) && (part.cursor() == t); // Is the same tick selected?

      // Set keyboard key and part's tick cursor
      keyboard.highlight(part.key(t), "blue")
      this.style.backgroundColor = "blue";
      part.setCursor(t)

      // Flip a tick's note if it's not selected or already highlighted.  That way an already selected note can be slected and immediately edited in the keybard.
      if (sameHighlight || this.innerText==".") {
        ToggleButtonState = this.innerText == "." ? 1 : 2;
        this.innerText = ToggleButtonState == 1 ? "X" : "."
      }

      // Update Callback for the keyboard to set this current new part's tick's key/note value.
      SetPartTick = function (k) {
        keyboard.unhighlight(part.key(part.cursor()), "blue") // Erase old keyboard active tick key
        part.setKey(t, k);
        keyboard.highlight(part.key(t), "blue") // Set keyboard key to this active part's tick
      }

      // Play the note
      if (this.innerText=="X") part.playable.play(part.key(t), part.vol(), 0);

      // Make sure the rest of the world knows about the latest part
      currentActiveSynthPart = part;
    };

    tickElement.onmouseup = function (event) { }

  }); // map function
}

function setupDrumTrack (part) {
  part.elementTicks.map(function (tickElement, t) {

    tickElement.onmousedown = function (event) {
      MouseIsDown = true;
      ToggleButtonState = this.innerText == "." ? 1 : 2;
      this.innerText = ToggleButtonState == 1 ? "X" : "."
      if (this.innerText=="X") part.playable.play(part.key(t), part.vol(), 0);
    }

    tickElement.onmouseover = function (event) {
      if (MouseIsDown) { this.innerText = (ToggleButtonState == 1 ? "X" : ".") }
      else if (this.innerText == "X") part.playable.play(part.key(t), part.vol(), 0);
    }
  }); // map function
}


/******************************************************************************
  Creates and maintains a set of parts/voices divided into measures of beats of notes.
  A two measure 4/4 would be initilzed with 4,4,4.

  USAGE::
    var phrase = new Phrase(measures, beatsper, ticksper, keyboard)

  CONSTRUCTOR PARAMETERS::
    measures  Number of measures
    beatsper  Beats per measure
    ticksper  Notes per beat
    keyboard  The keyboard object used by synths

  METHODS::
    .id                      Identification
    .elementIcon             The DOM element representing a minimized view.
    .element                 The main DOM element representing this phrase.
    .measureCount            Number of measures of each part.
    .beatCount               Number of beats of each part.
    .tickCount               Number of ticks of each part.
    .partCount()             Return number of parts
    .parts                   Return all parts in an array.
    .part(p)                 Return part p.
    .addPart(playable)       Appends a new part to the phrase and associates it with a playable object which implements .play(note, vol, when).
    .addPartFixed(playable,  Appends a new part to the phrase and associates it with a playable object that will be called with a fixedNote.
                  fixedNote)

  NOTES::

    Calls:              Sets:
      setupSynthPart()    window.currentActiveSynthPart
      setupDrumTrack()

******************************************************************************/
var Phrase = function (id, measures, beatsper, ticksper, keyboard) {
  //// Local
  var _partlistDOM, _partsDOM, _parts = [];

  // Create the iconified view DOM element
  var elementIcon = document.createElement('div');
  var _e = CreateAppendChild('div', elementIcon);
  _e.innerText = id;
  _e = CreateAppendChild('div', elementIcon);
  _e.innerText = measures + " " + beatsper + " " + ticksper;
  _e.style.width = measures*beatsper + "ch";

  // Create the DOM element representing this object.
  var _element = document.createElement('div');
  var _elementId = CreateAppendChild('p', _element);
  _elementId.innerText = id;
  _partlistDOM = CreateAppendChild('div', _element);
  _partlistDOM.className = "partlist";
  _partsDOM = CreateAppendChild('div', _element);

  // When the phase icon element or phase element itself is clicked on, toggle the main editable element.
  elementIcon.onmousedown =
  _elementId.onmousedown = function () {
    toggleElementDisplay(_element);
    if (_element.style.display == "none") {
      elementIcon.children[0].style.background = "#440";
    } else {
      elementIcon.children[0].style.background = "";
    }
  }

  // [TODO: remove eventually] Automatically insert into DOM.
  document.getElementById('sheet').appendChild(elementIcon);
  document.getElementById('phrases').appendChild(_element);

  // Add a new part to this phrase object. It requires a playable object
  var _createPart = function (playable, idx) { // idx can be undefined
    // The part toggle button
    var id = document.createElement('b');
    id.className = "trackid";
    id.innerText = _parts.length;
    id.style.fontWeight = "normal";
    // Create new part/voice object
    var _part = new Part(id, measures*beatsper, ticksper, beatsper, playable);
    _parts.push(_part);
    _part.elementName.innerText = playable.name(idx);
    _partsDOM.appendChild(_part.element);
    // Clicking on the part button will toggle the part's DOM element
    var b = CreateAppendChild('b', _partlistDOM);
    b.innerText =  id.innerText;
    b.style.fontWeight = "normal";
    b.style.display = "none";
    b.onmousedown = function(e, be){ toggleElementDisplay(e, be);}.bind(null, _part.element, b);
    id.onmousedown = function(e, be){ toggleElementDisplay(e, be);}.bind(null, _part.element, b);
    return _part;
  }

  //// Public
  this.id        = id;
  this.element   = _element;
  this.elementIcon = elementIcon;
  this.measureCount = measures;
  this.beatCount = measures * beatsper;
  this.tickCount = measures * beatsper * ticksper;
  this.partCount = function () { return _parts.length; }
  this.parts     = _parts;
  this.part      = function (p) { return _parts[p]; }
  this.addPart = function (playable) {
    var _part = _createPart(playable);
    _part.elementName.onmousedown = function () {
      _part.playable.waveformNext();
      _part.elementName.innerText = _part.playable.waveform();
    }
    setupSynthPart(_part, keyboard);
    currentActiveSynthPart = _part; // Make sure the keyboard can make sounds initially so assign it the last instantiate part.
  } // addPart

  this.addPartFixed = function (drumKit, fixedNote) {
    var _part = _createPart(drumKit, fixedNote);
    _part.setAllKeys(fixedNote);
    _part.elementName.onmousedown = function () {
      _part.play(fixedNote, 0);
      _part.elementName.style.color = "white";
    }
    _part.elementName.onmouseup = function () {
      _part.elementName.style.color = "";
    }
    setupDrumTrack(_part);
  } // addPartFixed

} // Phrase


// TODO New save mechanism
var saveSong = function () {

  var pattern = "daw0\n";

  for (var i=0; i<Sheet0.length(); ++i) {
    var phrase = Sheet0.phrase(i);
    pattern += phrase.id + " " + phrase.measureCount + " " + phrase.beatCount + " " + phrase.tickCount;
    phrase.parts.map(function(part, i){
      pattern += "\n" + part.elementName.innerText + " ";

      var byte=0;
      part.elementTicks.map(function (te, i) {
        byte = (byte >> 1) + ("." == te.innerText ? 0 : 128);
        if (7==i%8) {
          pattern += ("0"+byte.toString(16)).slice(-2);
          byte=0;
        }
      });

      pattern += " ";

      if (part.playable instanceof Synthesizer) {
        for (var i=0; i<part.tickLength; ++i) { 
          pattern += ("0"+part.key(i).toString(16)).slice(-2);
        }
      } else {
        pattern += part.key(0);
      }
    });
    pattern += "\n";
  }

  document.getElementById('save').innerText = pattern;

}

var saveSongAlpha = function () {
  var pattern=[];
  var synthParts=[]; 

  // Over each part...
  Sheet0.phrase(0).parts.map(function (part) {
    var byte=0;
    if (part.playable instanceof Synthesizer) synthParts.push(part); // Keep track of synth parts.
    part.elementTicks.map(function (te, i) {
      byte = (byte >> 1) + ("." == te.innerText ? 0 : 128);
      if (7==i%8) {
        pattern.push(byte);
        byte=0;
      }
    });
  });

  // The synth part's tick keys
  synthParts.map(function (part) {
    for (var i=0; i<part.tickLength; ++i) {
      pattern.push(part.key(i))
    }
  });

  window.history.replaceState("ohhai", "Digital Audio Workstation", document.location.href.split('?')[0] + '?'  + Base64(pattern));
}


/* Parse GET string
*/
var restoreTicksAlpha = function () {
  var ary = Base64(window.location.search.substring(1));
  if (320 != ary.length) {
    if (0 < ary.length) DB("WARNING: restoreTicksAlpha: GET string phrase not detected.");
    return;
  }
  DB("Scanning phrase via GET string...");
  var bit = 0;
  var synthParts=[];

  Sheet0.phrase(0).parts.map(function (part) {
    if (part.playable instanceof Synthesizer) synthParts.push(part); // Keep part of synth parts.
    part.elementTicks.map(function (te, i) {
      bit = i%8;
      te.innerText = ((ary[0]>>bit) & 1) ? "X" : ".";
      if (7==bit) ary.shift();
    });
  });

  synthParts.map(function (part) {
    for (var i=0; i<part.tickLength; ++i) {
      part.setKey(i, ary.shift());
    }
  });
}

/******************************************************************************
  Creates and maintains a set of phrases.

  USAGE::
    var sheet = new Sheet()

  METHODS::
    .length()    Get number of phraes (actual and referenced)
    .beatCount() Get number of total playable beats
    .add(p)      Append phrase p
    .phrase(i)   Get indexed phrase
******************************************************************************/
var Sheet = function () {
  //// Local
  var _phrases = [];
  var _beatCount = 0;
  //// Public
  this.length    = function ()  { return _phrases.length; }
  this.beatCount = function ()  { return _beatCount; }
  this.add       = function (p) {
    _beatCount += p.beatCount;
    DB.post("beatCount", _beatCount);
    return _phrases.push(p);
  }
  this.phrase    = function (i) { return _phrases[i]; }
} // Sheet


var setupControls = function (keyboard) {
  //document.getElementById('speed').onmouseenter = function (event) { event.target.focus(); }
  //document.getElementById('speed').onmouseleave = function (event) { event.target.blur(); }

  document.getElementById('speed').onkeydown = function (event) {
      //DB("onkeydown speed: " + event.keyCode);
      if (event.keyCode == 38) {
        var newDuration = parseInt(event.target.innerText.replace("\n",""))+1;
        event.target.innerText = newDuration;
        BeatDuration = 60/newDuration;
      } // if
      if (event.keyCode == 40) {
        var newDuration = parseInt(event.target.innerText.replace("\n",""))-1;
        event.target.innerText = newDuration;
        BeatDuration = 60/newDuration;
      } // if
  }

  document.getElementById('speed').onkeypress = function (event) {
    //DB("onkeypress speed: " + event.keyCode);
    setTimeout(function() { // The GUI is slower than this event handler which ends up adding the newline after this code removes it.  So delay this code a bit.
      if (event.keyCode == 13) {
        var newDuration = parseInt(event.target.innerText.replace("\n",""));
        event.target.innerText = newDuration;
        BeatDuration = 60/newDuration;
      } // if
    }); // function
  } // function


  document.getElementById('freq').onmouseenter = function (event) { event.target.focus(); }
  document.getElementById('freq').onmouseleave = function (event) { event.target.blur(); }
  document.getElementById('freq').onkeypress = function (event) {
    setTimeout(function () { // The GUI is slower than this event handler which ends up adding the newline after this code removes it.  So delay this code a bit.
      if (event.keyCode == 13) {
       keyboard.setStartFrequency(event.target.innerText = parseFloat(event.target.innerText.replace("\n","")));
      } // if
    }); // function
  } // function

  // Let's make a few elements moveable between each other

  /* I Shift has been pressed over a moveable block
       * position:absolute  
       * 
       event.target.parentElement
            .clientX/Y
                       .getBoundingClientRect().left/right
  */
  var ShiftClientX = 0;
  var ShiftClientY = 0;
  var Slots = [];
  var tempElem = false;

  /* As the mouse moves around the element, keep track of its relative location */
  var createMover = function (moverId) {

    document.getElementById(moverId).onmousemove = function (event) {
      if (!ShiftIsDown) {
        event.target.focus();
        // The moveable element's offset from the mouse.
        ShiftClientX = Floor(event.clientX - event.target.getBoundingClientRect().left);
        ShiftClientY = Floor(event.clientY - event.target.getBoundingClientRect().top);
        //DB("event.clientXY " + ShiftClientX + " " + ShiftClientY);
      }
    }

    document.getElementById(moverId).onkeydown = function (event) {
      if (ShiftClientX && !ShiftIsDown && event.shiftKey) {
        var elem = event.target;
        var parent = elem.parentElement;
        ShiftClientX += parent.getBoundingClientRect().left;
        ShiftClientY += parent.getBoundingClientRect().top;
        ShiftIsDown = true;
        //DB(ShiftIsDown);
        event.tabindex=1;
        event.target.style.left = event.offsetLeft + "px"
        event.target.style.top = event.offsetTop + "px"
        event.target.style.position = 'absolute'
        event.target.style.opacity = 0.7
        event.target.style.border = "solid 1px white";

        // Create the slots this element can be moved to.
        for (var i=0; (i < parent.children.length); i++) {
          var child = parent.children[i];
          if (child != elem) Slots.push(child);
        }
        // Create the placeholder
        tempElem = elem.cloneNode(true);
        tempElem.style.position = 'static';

        //event.target.style.border = "solid thin white";
        ShiftCallback = function (event) { // What to do when the mouse moves while shift is held down.
          var shiftX = event.clientX - ShiftClientX;
          var shiftY = event.clientY - ShiftClientY;
          elem.style.left =  shiftX + "px";
          elem.style.top =  shiftY + "px";
          //DB("global:" + event.clientX + " " + event.clientY);
          //Where to insert the place holder
          for (var i=0; (i < Slots.length); ++i) {
            if (20 > Abs(Slots[i].offsetLeft - shiftX)) {
              parent.insertBefore(tempElem, Slots[i]);
            }
          }
        }
        ShiftCallbackDone = function (event) {
          event.target.style.left = "";
          event.target.style.top = "";
          event.target.style.position = "";
          event.target.style.opacity = "";
          event.target.style.border = "";
          ShiftClientX = ShiftClientY = false;
          parent.insertBefore(elem, tempElem);
          parent.removeChild(tempElem);
          elem.outerHTML += " ";
          createMover(moverId);
          Slots = [];
        }
        ShiftCallback(event);
      } // if
    } // function
  } // createMover

  //createMover('freq');
  //createMover('speed');
} // setupControls ()


/******************************************************************************

 Event loops

******************************************************************************/
var Pause = false;
var Beat = 0; // Forever incrementing but resetting to 0 after all beats sent to audio context.
var nextBeatTime = 0.00; // This should be initialized a bit beyond whatever ctx.currentTime is to allow for ramp-up of the code.

// Show an image for a bit in the center of the screen.  Presented after hitting 'pause'.
var pauseFeedback = function () {
  var icon = document.getElementById('pauseicon');
  var opacity=1.0;
  icon.style.top = (window.innerHeight/2 - icon.height/2) + "px";
  icon.style.left = (window.innerWidth/2 - icon.width/2) + "px";
  icon.style.display = "";
  icon.style.opacity = opacity;
  var fn = function() {
    icon.style.opacity = opacity;
    if (opacity <= 0.0) {
      opacity = 1.0;
      icon.style.display="none";
      icon.style.opacity = opacity;
      return;
    } else {
      opacity-=0.05;
      setTimeout(fn, 50);
    }
  }
  setTimeout(fn, 500);
}

var pause = function (event) {
  var highlight = true;
  var id = false; 
  var color = '#f00';
  var e = document.getElementsByClassName('pause')[0];
  if (Pause = !Pause) {
    DB.post('pause', 'suspend');
    // Show a pause icon.  Currently a psychedelic kitteh.
    pauseFeedback();
    e.style.backgroundColor = color;
    // Blink the pause button.
    id = setInterval(function(){
                       e.style.backgroundColor = (Pause && (highlight =! highlight)) ? color : '';
                       if (!Pause) { clearInterval(id); }
                     },
                     500);
  } else {
    DB.post('pause', 'resume');
    e.style.backgroundColor = '';
    clearInterval(id);
    if (nextBeatTime <= ctx.currentTime) { nextBeatTime = ctx.currentTime + 0.25; }
  }
}

var reset = function (event) {
  if (Pause) {
    Pause = false;
    DB.post('pause', 'resume');
  }
  Beat = 0;
  nextBeatTime = ctx.currentTime + 0.25;
}

/* Periodically high-light whatever beat is currently being heard.
   It uses the web audio context's currentTime as a time reference.

                         v--nextBeatTime
                         | Beat | = [0..Sheet0.beatCount()]
 ----->----------------------------------------------
  currentTime------^
                | beatf |
              | beat |
   TODO:
     TWo sections to highlight:  Sheet and Phrase
     Phrase objects shold have a method for highlighting beats
*/
var rendererLoop = (function (_lastPhrase, _lastBeat, _lastTick) { return function () {
    if (nextBeatTime <= ctx.currentTime) return;

    // Adjust the beat by the distance between the actual time and nextBeatTime assuming a beat duration is fixed.
    // Changing it will upset this equation until the next rendering.
    var beatf = (Beat - (nextBeatTime - ctx.currentTime) / BeatDuration);
    var beat = Mod(Floor(beatf), Sheet0.beatCount());

    // Determine the realtime phrase and beat for the sheet (only one sheet for now TODO)
    var beatTally = 0;
    var phrase;
    for (var p=0; p<Sheet0.length(); ++p) {
      phrase = Sheet0.phrase(p);
      beatTally +=  phrase.beatCount;
      if (beat < beatTally) {
        beatTally -= phrase.beatCount;
        break;
      }
      phrase = false;
    }
    if (!phrase) { // If beat is beyond the last phrase's last beat, reset beat and select the first phrase.
      phrase = Sheet0.phrase(0);
      beatTally = 0;
      beat = 0; // Reset beat
    }
    beat -= beatTally; // beat within this phrase

    var ticksper = phrase.tickCount / phrase.beatCount;
    var tick = (beat * ticksper) + Floor((beatf - Floor(beatf)) * ticksper);

    // Unhighlight the last beats in the last phrase highlighted.
    if (_lastBeat != beat && _lastPhrase) {
      for (var p=0; (p < _lastPhrase.partCount()); ++p) {
        var part = _lastPhrase.part(p);
        part.elementBeat(_lastBeat).style.backgroundColor = part.backgroundBeat(_lastBeat);
      }
    }

    // Over all parts highlight beat and part labels
    for (var p=0; (p < phrase.partCount()); ++p) {
      var part = phrase.part(p);
      if (_lastBeat != beat) { // Highlight the current active beat
        part.elementBeat(beat).style.backgroundColor = "green";
      }

      if (_lastTick != tick) {
        // Highlight the part name
        if ('.' != part.elementTick(tick).innerText) {
          part.elementName.style.color = part.playable.color // Update part name's high-light every tick

          if (part.playable instanceof Synthesizer) { // Highlight this part's keyboard with it's synth's color
            part.playable.highlight(part.key(tick));
          }
        } else {
          part.elementName.style.color = "" // Unhighlight part's name every tick
          if (part.playable instanceof Synthesizer) { // Unhighlight this part's keyboard highlight (if any)
            part.playable.unhighlight();
          }
        }
      }
    }

    _lastPhrase = phrase;
    _lastBeat = beat;
    _lastTick = tick;
};})(0, 0,0);


/*
  Periodically tell each part in the current phrase to send their notes
  out to the audio context.  Called eveyr 50ms from onload.

  Beat is increment and all of it's ticks rendered each call.
  nextBeatTimeis also incremented.  They form an invariant.

  Render a beat at a time which means each tick in each part at this beat moment are written.
  nextBeatTime is the cursor in time delimiting audio written and audio to be written.

  A quasi-realtime cursor that needs to stay ahead of the audio context's time.  This cursor represents the next beat/tick to render
  and the beat/ticks that have already been rendered.

  nextBeatTime incremented each time a beat is rendered. initially == ctx.currentTime

  The rendering loop needs to:
   * Iterate over each sheet (multiple sheets?).
   * Determine the current phrase based on the global beat counter.  Each phrase will have a fixed max beat count.
   * Over each part, determine the current beat and render the ticks
   * Increment the global beat index
*/
var sequencerLoop = function () {
  if (Pause) return;

  while (nextBeatTime <= (ctx.currentTime + 1.0)) { // Try to keep 1 second of audio rendered ahead of the current time.

    // Discover which phrase in the curren sheet (only one sheet for now) that the current beat is on.
    var beatTally = 0;
    var phrase;
    for (var p=0; p<Sheet0.length(); ++p) {
      phrase = Sheet0.phrase(p);
      beatTally +=  phrase.beatCount;
      if (Beat < beatTally) {
        beatTally -= phrase.beatCount;
        break;
      }
      phrase = false;
    }
    if (!phrase) { // If Beat is beyond the last phrase's last beat, reset beat and select the first phrase.
      phrase = Sheet0.phrase(0);
      beatTally = 0;
      Beat = 0; // Reset beat
    }

    // Now have a phrase.  Tell each part to play the all ticks in the current beat.

    var _beat = (Beat - beatTally);

    if (0 == _beat) { saveSong(); } // On the initial beat, upate the URL's get string.  TODO: Storage to be rewritten.

    // Over each part in the current phrase, play the ticks associated with specific phrase-beat.
    for (var i=0; (i < phrase.partCount()); ++i) {
      var _part = phrase.part(i);
      _part.playTicks(_beat, nextBeatTime);
    }

    Beat += 1;
    nextBeatTime += BeatDuration;
  } // while
} // sequencerLoop()



/******************************************************************************

 MAIN

 CONCEPTS

 Pressing a physical key/pad creates a note message/event.

 Sheet      >Arrangement of phrases
  Phrase    >Contains multiple parts
   Measure  >Logical division of parts
    Beat    >Physical division of Parts
     Tick   >Physical division of Beats which contain notes to play


  Sheet of one phrase.  Phrase of parts visually divided into two measures,
  measures/bars of four beats, beats divided into X number of ticks.
    x, xx x. .. x, x. xx x.       Tick order:  1 3 
    ,, .. x. .. ,, .. .x .x                    |/| 
                                               2 4 
  Official      Me
  ------------- --------
  Measure / Bar
  Part / Voice
  Quarter note  Beat
  Shortest note Tick

3/4 song -- paste the following into daw07 console
[18, 21, 25, 18, 21, 25, 18, 21, 26, 16, 20, 23, 16, 20, 23, 16, 20, 25, 13, 18, 20, 13, 18, 20, 13, 17, 20, 18, 21, 25, 18, 21, 25, 18, 25, 30, 25, 29, 32, 30, 33, 37, 30, 37, 41, 42, 45, 30].map(function(n,i){Sheet0.phrase(0).part(2).setKey(i,n-12);})

******************************************************************************/
DB.check((window.AudioContext || window.webkitAudioContext), "Audio context not found.  Use Chrome browser.");
var ctx = new (window.AudioContext || window.webkitAudioContext)();

var Sheet0; // New hotness

var currentActiveSynthPart = false;  // This is the last track acted upon.  Should be initialied at some point.
vaa SetPartTick = false; // HACK: This becomes a function that sets the key in some synth phrase.  Move this functionality into the piano keyboard object.

var ToggleButtonState = 1;
var BeatDuration = 0.25; // .5 .25 .125 .0625 .03125  Keep timing binary friendly.  Inverted BPM.

// It's nice to keep track of the user's mouse button state.  The window element will always catch this event and handle it.
var MouseIsDown = false;
window.onmouseup = function () { MouseIsDown = false; }

// It's nice to keep track of the user's shift state.
var ShiftIsDown = false;
var ShiftCallback = false; // Called when mouse moves and shift is down
var ShiftCallbackDone  = false;

window.onkeyup = function (event) {
  if (ShiftIsDown && !event.shiftKey) {
    if (ShiftCallbackDone) ShiftCallbackDone(event);
    ShiftIsDown = ShiftCallback = ShiftCallbackDone = false;
    DB(ShiftIsDown);
  }
}

window.onkeydown = function (event) {
  //DB("onkeydown global: " + event.keyCode)
  if (event.keyCode == 191) DB.clear(); // Pressing '/' will clear the DB (debug console) element.
  if (event.keyCode == 82) {
    reset(event); // Pressing 'r' will rewind the playback.
  }
  if (event.keyCode == 80) {
    pause(event); // Pressing 'p' will pause the playback.
    event.stopPropagation(); // TODO This doesn't prevent space from scrolling the main window so for now 'p' will pause the sequencer.
  }
}

window.onmousemove = function (event) {
  if (ShiftCallback) ShiftCallback(event);
}

// Stop tablets and phones from scrolling and resizing?
document.body.addEventListener('touchstart', function (event) {if (event.touches.length=='fack') event.preventDefault(); DB(event.touches);}, true);


/******************************************************************************
  onload
Phrase0 4 16 64
0:30 33 37 30 33 37 30 33 38 28 32 35 28 32 35 28 32 37 25 30 32 25 30 32 25 29 32 30 33 37 30 33 37 30 37 42 37 41 44 42 45 49 42 49 53 54 57 42 37 33 32 30 33 35 37 38 40 41 42 37 33 30 25 21
1:18 21 25 18 21 25 18 21 26 16 20 23 16 20 23 16 20 25 13 18 20 13 18 20 13 17 20 18 21 25 18 21 25 18 25 30 25 29 32 30 33 37 30 37 41 42 45 30 25 21 25 23 20 23 25 18 23 14 14 14 15 15 15 15
2:6 9 13 6 9 13 6 9 14 4 8 11 4 8 11 4 8 13 1 6 8 1 6 8 1 5 8 6 9 13 6 9 13 6 13 18 13 17 20 18 21 25 18 25 29 30 33 18 12 12 12 12 13 13 13 13 14 14 14 14 15 15 15 60
******************************************************************************/
var addphrase;

window.onload = function () {
  DB("::onload");

  Sheet0 = new Sheet(); // Global sheet object

  // Create a piano in the dom.  61 keys, starting at C in octave 2.
  var keyboard = new PianoKeyboard("piano1", 61, 0, 1, 65.4064);
  //var keyboard = new PianoKeyboard("piano1", 88, 9, 0, 27.5); // 88-key piano: A0 A# B C1 C# D ...
  setupKeyboard(keyboard); // Give the piano immediate playing capability

  // Create a phrase with 4 measures, 4 beats per measure, and 4 ticks per beat.
  var phrase = new Phrase("Phrase0", 4, 4, 4, keyboard);
  Sheet0.add(phrase);

  // Add synth parts to the phrase
  phrase.addPart(new Synthesizer(ctx, 1, keyboard, "red"));
  phrase.addPart(new Synthesizer(ctx, 2, keyboard, "green"));
  phrase.addPart(new Synthesizer(ctx, 3, keyboard, "cyan"));

  // Add drum parts to the phrase
  var filenames = ["808.bass.raw", "808.snare.drum.raw", "808.snare.noise.raw", "808.maracas.raw", "808.cowbell.raw", "808.rim.raw", "808.highhat.closed.raw", "808.claves.raw", "808.clap.raw", "808.highhat.opened.raw", "808.cymbal.raw", "909.thump.raw", "909.snare.noise.raw"];
  var DrumKit = new Drumkit(ctx, "orange", new AudioBuffers(ctx, filenames));
  for (var n=0; n<filenames.length; ++n) { phrase.addPartFixed(DrumKit, n) }

  restoreTicksAlpha(); // Parse get string

  /////////////////////////////////////////////////////////////////////////////
  // A second phrase for fun
  //var phrase2 = new Phrase("End Phrase", 2, 4, 3, keyboard);
  //phrase2.addPart(new Synthesizer(ctx, 0, keyboard, "magenta"));
  //phrase2.addPartFixed(DrumKit, 4);
  //Sheet0.add(phrase2);

  // Setup menus and moveable buttons.
  setupControls(keyboard);

  // Begin event loops
  setInterval(rendererLoop, 50);
  setInterval(sequencerLoop, 50);

  nextBeatTime = ctx.currentTime+0.25;

  //Base64.test();

  // TODO Global hack mechanism to create a new phrase.
  addphrase = function (e) {
    var measures = e.target.parentElement.children[1].children[0].innerText;
    var beats    = e.target.parentElement.children[1].children[1].innerText;
    var ticks    = e.target.parentElement.children[1].children[2].innerText;
    var phrase = new Phrase("Phrase" + Sheet0.length(), measures, beats, ticks, keyboard);
    phrase.addPart(new Synthesizer(ctx, 0, keyboard, "magenta"));
    phrase.addPartFixed(DrumKit, 6);
    Sheet0.add(phrase);
  }

  DB("--onload [" + DB.status() + "]");
}

//]]></script>

</body></html>
