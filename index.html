<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
 <title>Digital Audio Workstation bEtA</title>
 <link rel="stylesheet" href="index.css" type="text/css" media="screen" title="Shrewm"/>
</head>
<body Xoncontextmenu="return false;">

<p id="DB" style="width:20em; background:black; z-index:2; border:solid 1px green; white-space:pre; overflow:auto; max-height:20em; position:fixed; right:0; bottom:0"></p>

<h1>Digital Audio Workstation bEtA &#x2669; &#x266a; &#x266b; &#x266c; &#x266d; &#x266e; &#x266f;</h1>
<hr/>
<p class="mainNav">
 <a href="http://webaudio.github.io/web-audio-api/">[WebAudio]</a>
 <a href="http://validator.w3.org/check/referer">[XHTML 1.0]</a>
 <a href="http://jigsaw.w3.org/css-validator/tabindex="1" check/referer/">[CSS 2.1]</a>
</p>

<div class="knobs">
 <p id="speed" ttabindex="0" contenteditable="true">120</p>
 <p class="reset" onmousedown="reset(event)">|&lt;</p>
 <p class="pause" onmousedown="pause(event)">||</p>
</div>

<div style="display:inline-block">
  <div style="display:inline-block; border:0; background:#888">
    KEYBOARD
  </div>
<br/>
  <div style="display:inline-block; margin-left:1em; margin-top:-2px; border:solid 2px #888">
  <p id="freq" ttabindex="0" style="display:inline-block; background:#00a; color:#eee" contenteditable="true">65.4064</p>
    <div>
      <div id="piano1" class="piano"></div>
    </div>
  </div>
</div>

<div>
  <div style="display:inline-block; background:#00f">
    SHEET
  </div>
<br/>
  <div id="sheet" class="sheet">

    <div>
     <div>phrase1</div>
     <div><p>1/0</p><p>phrase1</p></div>
    </div>

    <div>
     <div>phrase2</div>
     <div><p>1/1</p><p>phrase1</p></div>
    </div>

  </div>
</div>

<div>
  <div style="display:inline-block; background:#880" onmousedown="hide(event, 'rythm')">
    PHRASE
  </div>
<br/>
  <div id="phraseMain" class="phrase">
    <div class="partlist">_</div>
    <div class="rythm"></div>
  </div>
</div>

<script type="text/javascript">//<![CDATA[
"use strict"

/******************************************************************************
  Useful aliases and objects
******************************************************************************/
var Floor = Math.floor;
var Pow   = Math.pow;
var Abs   = Math.abs;
var Rnd   = Math.random;
var CreateAppendChild = function (name, element) { return element.appendChild(document.createElement(name)); }
var CreateInsertBefore = function (name, element) { return element.insertBefore(document.createElement(name), element.firstChild); }


/******************************************************************************
  Debug message console and error checking

  DOM requirements::
    <p id="DB"></p>        -- If nonexistent, the DB object will revert to using the browser's console.

  Usage::
    DB("string")           -- Send string to info window.  Behaves like a pre element.
    DB.log("string")       -- Send string to console.log.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.clear()             -- Empty the entire DB element.
    DB.check(expr, string) -- If expr is false, send string to console.  status() will then always return false.
    DB.status()            -- Returns false if check ever failed.
******************************************************************************/
var DB = (function () {
  var consoleElement = document.getElementById('DB');
  var self;
  var status = true;
  var shouldNewline = true; // Want to prepend a newline when the last message was plain text.
  var lastPostType = false;

  var setStyles = function (e) {
    return;
    e.style.border = "solid 1px green";
    e.style.whiteSpace = "pre";
    e.style.overflow = "auto";
    e.style.maxHeight = "20em";
  }

  // Create the instance which is a function.  Also create the clear function.
  if (!consoleElement) {
    self = function (s) { console.log(s); lastPostType = false;}
    self.log = self;
    self.post  = function (t, s) { // For the console, only the first post type is displayed.
      if (t != lastPostType) {
        console.log("[" + t + "]" + s);
        lastPostType = t;
      }
    }
    self.clear = function () { lastPostType = false; }
  } else {
    setStyles(consoleElement);
    self = function (s) {
      consoleElement.innerHTML += (shouldNewline ? "" : "\n") + s;
      consoleElement.scrollTop = consoleElement.scrollHeight;
      shouldNewline = lastPostType = false;
    }
    self.log = function (s) { console.log(s); }
    self.post = function (t, s) {
      if (t == lastPostType) {
        consoleElement.lastChild.innerText = "[" + t + "]" + s;
      } else {
        CreateAppendChild('p', consoleElement).innerText = "[" + t + "]" + s;
        consoleElement.scrollTop = consoleElement.scrollHeight;
        lastPostType = t;
      }
      shouldNewline = true;
    }
    self.clear = function () {
       consoleElement.innerHTML = "";
      shouldNewline = lastPostType = true;
    }
  }

  self.check = function (expr, msg) {
    status = status && expr;
    return expr || self(msg) && false;
  }

  self.status = function () { return status; }

  return self;
})(); // DB


/******************************************************************************
  Base64 encoder and decoder

  USAGE::
    Base64([1,2,3])  Returns a base64 encoded string of the byte (0..255)
                     values in the array.
    Base64("0G83")   Returns a decoded base64 string as an array of bytes
                     values.

    Base64.encode()  Explicit call.
    Base64.decode()  Explicit call.
    Base64.test(ary) Runs an internal test.  Calls DB.check(ary) on the
                     comparision of the output of the encoding then decoding
                     of the passed byte array.
  ALGORITHM NOTES::
    An incomplete octet will be correctly created because
       emptyArray[0]      => undefined
       undefined >> num   => 0
******************************************************************************/
var Base64 = (function () {
  // Private
  var self;
  var base64table = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','-','_'];

  var _encode = function (ary) {
    var ary1 = ary.slice(0); // Copy the array since I shift the elements off.
    var octet=0;     // Which octet to create
    var str = ""; // The encoded string
    while (ary1.length) {
      str +=
        base64table[(0 == octet) ? ary1[0] >> 2 :                              // [000000..]
                    (1 == octet) ? ((ary1.shift() & 3) << 4) + (ary1[0] >> 4) :// [......00][1111....]
                    (2 == octet) ? ((ary1.shift() & 15) << 2) + (ary1[0] >> 6) //           [....1111][22......]
                   /*3 == octet*/: ary1.shift() & 63];                         //                     [..222222]
      octet = ++octet & 3;
    }
    return str;
  }

  var _decode = function (str) {
    var ary=[];
    var i=0, byte;
    while (i < str.length) {
      ary.push((base64table.indexOf(str[i]) << 2) + (base64table.indexOf(byte=str[++i]) >> 4)); // [000000][00....]
      if (++i == str.length) break;
      ary.push(((base64table.indexOf(byte)&15) << 4) + (base64table.indexOf(byte=str[i]) >> 2));//         [..1111][1111..]
      if (++i == str.length) break;
      ary.push(((base64table.indexOf(byte)&3) << 6) + (base64table.indexOf(str[i])));           //                 [....22][222222]
      if (++i == str.length) break;
    }
    return ary;
  }

  var _test1 = function (ary) {
    str = Base64(ary);
    ary2 = Base64(str);
    DB.check((ary.toString() == ary2.toString()), ary + " != " + ary2);
  }

  var _test = function () {
    _test1([]);
    _test1([0]);
    _test1([1]);
    _test1([2]);
    _test1([255]);
    _test1([1,255]);
    _test1([255,1]);
    _test1([255,1]);
    _test1([255,1,255]);
    _test1([255,1,255]);
    _test1([1,255,1]);
    _test1([0,0,0,0,0]);
    _test1([0,0,0,0,255]);
    _test1([255,0,0,0,0]);
    _test1([1,1,1,1,1]);
    _test1([255,255,255,255,255]);
  }

  //// Public
  self = function (o) {
    if (Array.isArray(o)) return _encode(o);
    else if (typeof o == "string") return _decode(o);
    else return false;
  }
  self.encode = _encode;
  self.decode = _decode;
  self.test = _test;

  return self;
})();




/******************************************************************************
  Create a piano keyboard in the DOM.  It emulates a keyboard controlled
  oscillator.

  USAGE::
    var Keyboard = new PianoKeyboard('piano', 37, 0, 1, 130.813);

  CONSTRUCTOR PARAMETERS::
    DOM element id to add the new piano element.
    number of keys
    starting key (0==C, 1==C#, ... 11=B)
    octave
    first specified key's frequency

  METHODS::
    Keyboard.keyElements           All key DOM elements in an array
    Keyboard.keyElement(key)       Get the DOM element representing the white or black key  Indexed between 0 and number of keys-1.
    Keyboard.freq(key)             Frequency of key.
    Keyboard.setStartFrequency(f)  Reset the base frequencies of the keyboard (first note's frequency)
    Keyboard.highlight(key, color);Highlight the key using color.  Overrides its last color, if any.
    Keyboard.unhighlight(key);     Removes last/top highlighted color and reverts to its previous color (if any)

******************************************************************************/
var PianoKeyboard = function (id, keyCount, startKey, startOctave, startFrequency) {

  //// Private

  var _pianoDOM = document.getElementById(id);
  DB.check(_pianoDOM, "ERROR: PianoKeyboard: Element id=" + id + " not found in DOM.");

  var _keysDOM = []; // Keeps track of the DOM elements which represent the white and black keys in order.
  var _frequencies = [];
  var _highlights = []; // Array of stacks.  An empty stack implies no high-light.

  var _createDOM = function () {
    var notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    var sharps = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0]; // Bool table of sharps in an octave, starting at C
    var newKey, keyPair = false; // The piano DOM is composed of divs containing either just a div (white key) or div and p (white and black key)
    startKey += startOctave * 12; // Adjust initial key to account for octave
    for (var k=0; (k < keyCount); ++k) {

      if (sharps[(k + startKey)%12]) {
        // Create the sharp key
        newKey = CreateAppendChild('p', _pianoDOM);
      } else {
        // Create the natural key
        var note   = (k + startKey) % 12;
        var octave = Floor((k + startKey) / 12);
        newKey = CreateAppendChild('div', _pianoDOM)
        // add the note's textual label including the octave number.
        newKey.innerText = notes[note] + (note==0?octave:'');
      }

      _keysDOM.push(newKey); // Keep track of each created key.
      _frequencies.push(startFrequency * Pow(2, k/12.0));
      _highlights.push([]);
    }
  }

  // Construct

  _createDOM();
  DB.check(keyCount == _keysDOM.length, "ERROR: PianoKeyboard: Created incorrect number of keys.");
  DB.check(keyCount == _frequencies.length, "ERROR: PianoKeyboard: Created incorrect number of frequencies.");

  // Public

  this.keyElements = _keysDOM;
  this.keyElement = function (i) { return _keysDOM[i]; }
  this.freq = function (k) { return _frequencies[k] + Rnd(); } // Adding a random [0..1] value to the freq in an attempt to get rid of beating.  Ended up with a phaser effect when equal notes are played instead.
  this.setStartFrequency = function (newStartFrequency) {
    for (var i=0; (i < keyCount); ++i) _frequencies[i] = newStartFrequency * Pow(2, i/12.0);
  }
  this.highlight = function (key, color)  {
    if ((0 <= key) && (key < keyCount)) {
      _highlights[key].push(color);
      _keysDOM[key].style.backgroundColor = color;
    }
  }
  this.unhighlight = function (key, color) {
    var i;
    var stk = _highlights[key];
    if (!stk) return; // If invalid key, retutn
    if (color) { // Remove color from stack (could be anywhere)
      i = stk.indexOf(color);
      if (-1 < i) { stk.splice(i, 1); }
    } else {
      stk.pop(); // If no color passe, pop last color
    }
    // Set the key's color to the top of the stack
    i = stk.length;
    _keysDOM[key].style.backgroundColor = (0 < i) ? stk[i-1] : "";
  }
} // PianoKeyboard 


/******************************************************************************
  Database of Web Audio audio buffers.  It will download and convert raw audio
  files into ready to use AudioBuffers.

  USAGE::
    var noises = new AudioBuffers(filenames)

  METHODS::
    noises.length          Number of files loaded.
    noises.fileName(i)     Get a filename.
    noises.audioBuffer(i)  Get an audio buffer or undefined.
******************************************************************************/
var AudioBuffers = function (filenames) {
  // Private
  var _audioBuffers = [];

  function _Validate () {
    if (!DB.check(filenames && Array.isArray(filenames), "ERROR: AudioBuffersdb: Invalid filenames ary.")) {
      filenames = [];
    }
  }

  function _loadRawAudioFiles () {
    filenames.forEach(function (fn, i) { // forEach passes in each ary element and the index.
      var client = new XMLHttpRequest();
      client.open('GET', fn);
      client.responseType = "arraybuffer";
      client.onreadystatechange = // Callback after remote file has been loaded
        function (e) {
          if (4 != client.readyState) return;
          var statusState = ((200 == client.status) || (0 == client.status) && (null != client.response)); // When loaded locally with --allow-file-access-from-files, status is 0 so must check client.response instead
          DB.check(statusState, "ERROR: AudioBuffers: " + client.status + " '" + (client.responseURL || fn) + "'");
          if (statusState) {
            DB.log("LOADED " + fn);
            var samples = new Int16Array(client.response); // Consider u8 ary as s16 ary.
            // Normalized each s16 sample to f32 between -1 and 1.
            var Noise =  new Float32Array(samples.length);
            for (var j=0; j<samples.length; ++j) {
              Noise[j] = samples[j]/32768;
            }
            // Create and set the audio buffer
            _audioBuffers[i] = ctx.createBuffer(1, samples.length, 44100);
            _audioBuffers[i].getChannelData(0).set(Noise);
          } // if
        } // function()
      client.send();
    }); // forEach function
  } // function

  // Construct

  _Validate();
  _loadRawAudioFiles();

  // Public

  this.length = filenames ? filenames.length : 0;
  this.fileName = function (i) { return filenames[i]; }
  this.audioBuffer = function (i) { return _audioBuffers[i]; }
} // AudioBuffers 


/******************************************************************************
  Create a playable drumkit.  Expects a webaudio context and Audio Buffers DB.

  USAGE::
    var DrumKit = new Drumkit(ctx, color, audioBuffers);

  CONSTRUCTOR PARAMETERS::
    An web audio context and audio buffers object.

  METHODS::
    Drumkit.color                 Color associated with this object
    Drumkit.name(pad)             String describing the pad.  Usually the drum sound.
    DrumKit.play(pad, vol, when)  Plays an audiobuffer sample specified by pad at
                                  volume vol at time when or now if when==0.
******************************************************************************/
var Drumkit = function (ctx, color, audioBuffers) {
  //// Local
  var bassReleaseTime = 0.8; // Release time in seconds for both the filter and gain.
  //// Public
  this.name = function (pad) {
    return (undefined == pad) ? "TR-808" : audioBuffers.fileName(pad);
   }
  this.color = color
  this.play = function (pad, vol, when) {
    var audioBuffer = audioBuffers.audioBuffer(pad);
    if (!audioBuffer) return; // Do nothing if no audio buffer.
    var gain;
    var now = (when || ctx.currentTime); // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
    var source = ctx.createBufferSource();
    source.buffer = audioBuffer;
    source.onended = function() { source.disconnect(); } // When the audio stops, remove it from the graph.
    var gain = ctx.createGain(); // Ramp

    if (pad == 0) { // HACK: need to generalize a sound pipeline
      // Loop the bass noise for one second with a LPF and gain ramp.
      source.playbackRate.setValueAtTime(0.39, now);
      source.playbackRate.linearRampToValueAtTime(0.37, now+bassReleaseTime);
      source.loop = true;
      source.start(when);
      source.stop(now + bassReleaseTime);

      var lp = ctx.createBiquadFilter(); // LPF
      lp.type = "lowpass";
      lp.frequency.value = 120;
      lp.Q.value = 0.5;

      gain.gain.setValueAtTime(vol, now);
      gain.gain.linearRampToValueAtTime(0, now+bassReleaseTime);

      source.connect(lp);
      lp.connect(gain);
    } else {
      gain.gain.value = vol;
      source.connect(gain);
      source.start(when);
    }

    gain.connect(ctx.destination);
  }
} // Drumkit


/******************************************************************************
  Create a playable synthesizer.

  USAGE::
    var Synth = new Synthesizer(ctx, keyboard, color);

  CONSTRUCTOR PARAMETERS::
    A web audio context.
    An instantiated playable object.

  METHODS::
    Synth.color                Color associated with this object
    Synth.name(key)            Name associated with this key.  Default is the synth waveform name, each key.
    Synth.play(key, vol, when) Plays a waveform at a freq determined by the Keyboard object at the
                               specified key, at webaudio context time 'when' or immediately if when==0.
    Synth.waveform()           Get current waveform string.
    Synth.waveformNext()       Select the next waveform.
    Synth.highlight(key)       Highlight the keyboard object's key with my color.
    Synth.unhighlight()        Remove my highlight from the keyboard object.
******************************************************************************/
var Synthesizer = function (ctx, keyboard, color) {
  //// Local
  var _release = 0.5; // Release time in seconds for both the filter and gain.
  var _waveforms = ["sine", "square", "sawtooth", "triangle"];
  var _waveformIdx = 2;

  var _play = function (key, vol, when) {
    var now = when==0 ? ctx.currentTime : when; // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
    var osc = ctx.createOscillator(); // Create and add to table if not already
    osc.frequency.value = keyboard.freq(key); // Ask the keyboard object for the frequency of this key
    osc.type = _waveforms[_waveformIdx];
    osc.start(now);
    osc.stop(now + _release);
    osc.onended = (function(osc){ return function() { osc.disconnect(); }})(osc);

    var gain = ctx.createGain();
    gain.gain.setValueAtTime(vol*0.5, now);
    gain.gain.linearRampToValueAtTime(0, now + _release);

    osc.connect(gain);
    gain.connect(ctx.destination);

  }

  //// Public
  this.color = color
  this.name = function (note) { return this.waveform(); }
  this.play = _play;
  this.waveform = function () { return _waveforms[_waveformIdx]; }
  this.waveformNext = function () {
    if (_waveforms.length == ++_waveformIdx) _waveformIdx=0;
  }
  var lastKey = -1;
  this.highlight = function (key) {
      keyboard.unhighlight(lastKey, color); // Remove last high-light
      keyboard.highlight(key, color); // Set new high-light
      lastKey = key
  };
  this.unhighlight = function () {
    keyboard.unhighlight(lastKey, color); // Remove last high-light
  };
  //this.tick = function (time) { }
} // Synthesizer


/******************************************************************************
  Creates and maintains a sequence of notes to send a playable object over time.

  USAGE::
    var track = new Part(idElement, beatCount, subBeatCount, beatsPerMeasure, playableObject);

  CONSTRUCTOR PARAMETERS::
    idElement         ID string
    beatCount         Number of total beats (measures * beatspermeasure)
    subBeatCount      Number of subbeats per beat
    beatsPerMeasure   Length of measure.  Used to determine beat highlighing in the tracks.
    playableObject    An object that makes sound

  METHODS::
    track.playable          Get the playable object
    track.element           Get the track element
    track.elementBeat(i)    Get the ith beat element
    track.elementTicks      get array of all tick elements.
    track.elementTick(i)    Get the ith tick element
    track.elementName       Get the name element for this track
    track.backgroundBeat(i) Get ith beat's original background.
    track.backgroundColor(i) Get ith tick's original background color.
    track.tickLength        Get number of ticks (notes, keys, whatever) this track contains.
    track.key(i)            Get the key at tick i.
    track.setKey(i, key)    Set the ith tick's key.
    track.setAllKeys        Set the default key or drum index.
    track.cursor()          Get the "cursor" representing one of the tick indices.
    track.setCursor(i)      Set the "cursor" tick index.
    track.vol()             Get volume (default = 0.5).
    track.setVol(v)         Get volume.
    track.play(tick, when)  Play the note at sequence 'tick'
    //track.tick(time)        Sequences all sounds from the web audio's context
                            current time through the specified 'time' parameter.
******************************************************************************/
var Part = function (idElement, beatCount, subBeatCount, beatsPerMeasure, playable) {
  //// Local
  var _beatCounter = 0;
  var _trackElement; // The DOM element
  var _elementBeats = [];
  var _elementTicks = [];
  var _volPad, _elementMenu, _elementName;
  var _notes = []; // Each tick (beatCount * subBeatCount) gets its own key.
  var _beatOriginalBackground = [];
  var _tickOriginalBackground = [];
  var _cursor = -1;
  var _vol = 0.4;

  var _createElements = function () {
    var p;
    _trackElement = document.createElement('div'); // DOM element
    _trackElement.className = "track";
    // Add beat elements to DOM

    if (idElement) { _trackElement.appendChild(idElement); }

    for (var b=0; (b < beatCount); ++b) {
      var beatElement = CreateAppendChild('div', _trackElement); // Beat element added to track element
      beatElement.className = "beat";
      beatElement.style.backgroundColor = (0 == (_beatCounter++ % beatsPerMeasure)) ? "#333" : "#222";
      // Keep track of the beat DOM element and its default background color.
      _elementBeats.push(beatElement);
      _beatOriginalBackground.push(beatElement.style.backgroundColor);
      for (var t=0; (t < subBeatCount); ++t) {
        var tickElement = CreateAppendChild('p', beatElement); // Four tick elements added to each beat element
        tickElement.className = "tick"
        tickElement.innerText = '.';
        // Keep track of the track DOM element and its default background color.
        _elementTicks.push(tickElement);
        _tickOriginalBackground.push(tickElement.style.backgroundColor); // Cache original background color of beat element
        _notes.push(b); // Build up the tick's key values.
      }
    }
    // Add an edit/menu element.
    _elementMenu = CreateAppendChild('p', _trackElement);
    _elementMenu.className = "menu"
    _elementMenu.style.position = "relative"
    _elementMenu.innerText = "[V]"

    _volPad = CreateAppendChild('p', _elementMenu);
    _volPad.style.position = "absolute"
    _volPad.style.top = 0;
    _volPad.style.left = 0;
    _volPad.innerText = " .,.....\n,,......\n........\n........\n........\n........\n.......@\n......@@";
    _volPad.style.display="none";
    _volPad.style.background="#242";
    _volPad.style.zIndex = "1";
    _elementMenu.onmousedown = function () {
      MouseIsDown = true;
      _volPad.style.display="block";
    }
    _volPad.onmousemove = function (event) {
      var mx = (event.clientX - event.target.getBoundingClientRect().left) / 87;
      var my = (event.clientY - event.target.getBoundingClientRect().top) / 183;
      _vol = my * 0.9 + mx * 0.1;
    }
    _volPad.onmouseleave  = function () { _volPad.style.display="none"; }
    _volPad.onmousedown = function () { event.stopPropagation(); }
    _volPad.onmouseup = function () { if (!MouseIsDown) { event.stopPropagation(); _volPad.style.display="none";} }
    
    // Add sound name element to this track DOM element
    _elementName = CreateAppendChild('p', _trackElement);
    _elementName.className = "name"
  }

  var _setAllKeys = function (key) {
    for (var t=0; t<_notes.length; ++t) { _notes[t] = key; }
  }

  // Construct
  _createElements();

  //// Public
  this.playable = playable;
  this.element = _trackElement;
  this.elementBeat = function (i) { return _elementBeats[i]; }
  this.elementTicks = _elementTicks;
  this.elementTick = function (i) { return _elementTicks[i]; }
  this.elementName = _elementName;
  this.backgroundBeat = function (i) { return _beatOriginalBackground[i]; }
  this.backgroundColor = function (i) { return _tickOriginalBackground[i]; }
  this.tickLength = _notes.length;
  this.key = function (k) { return _notes[k]; }
  this.setKey = function (tick, key) { _notes[tick] = key; }
  this.setAllKeys = function (key) { _setAllKeys(key); }
  this.cursor = function () {return _cursor; }
  this.vol = function () {return _vol; }
  this.setVol = function (v) {_vol = v; }
  this.setCursor = function (i) { _cursor = i; }
  this.play = function (tick, when) { playable.play(_notes[tick], _vol, when); }
} // Part


/******************************************************************************

  Implemenation MAIN

******************************************************************************/


DB.check((window.AudioContext || window.webkitAudioContext), "Audio context not found.");
var ctx = new (window.AudioContext || window.webkitAudioContext)();

var Keyboard;
var Tracks = [];
Tracks.beats = 0;
Tracks.ticks = 0;

var currentActiveTrack = false;  // This is the last track acted upon.  Should be initialied at some point.
var setTrackTickKey = false; // HACK: This becomes a function that sets the key of some track.  Move this functionality into the piano keyboard object.

var ToggleButtonState = 1;
var BeatDuration = .25 + .125; // .5 .25 .125 .0625 .03125  Keep timing binary friendly.

// It's nice to keep track of the user's mouse button state.  The window element will always catch this event and handle it.
var MouseIsDown = false;
window.onmouseup = function () { MouseIsDown = false; }

// It's nice to keep track of the user's shift state.
var ShiftIsDown = false;
var ShiftCallback = false; // Called when mouse moves and shift is down
var ShiftCallbackDone  = false;

window.onkeyup = function (event) {
  if (ShiftIsDown && !event.shiftKey) {
    if (ShiftCallbackDone) ShiftCallbackDone(event);
    ShiftIsDown = ShiftCallback = ShiftCallbackDone = false;
    DB(ShiftIsDown);
  }
}

window.onkeydown = function (event) {
  //DB("onkeydown global: " + event.keyCode)
  if (event.keyCode == 191) DB.clear(); // Pressing '/' will clear the DB (debug console) element.
  if (event.keyCode == 80) {
    pause(event); // Pressing '/' will clear the DB (debug console) element.
    event.stopPropagation(); // TODO This doesn't prevent space from scrolling the main window.
  }
}

window.onmousemove = function (event) {
  if (ShiftCallback) ShiftCallback(event);
}

document.body.addEventListener('touchstart', function (event) { if (event.touches.length=='fack') event.preventDefault(); DB(event.touches);}, true);


/******************************************************************************
 Keyboard, Synthesizer, and Tracks
******************************************************************************/

var setupKeyboard = function (keyboard) {
  // Register mouse event handlers for every DOM keyboard element representing a key.
  keyboard.keyElements.map(function (keyElement, key) {
    var KeyPressColor = "#0af"
    var _keyAction = function () {
      keyboard.highlight(key, KeyPressColor); // Set current key hilight
      currentActiveTrack.playable.play(key, currentActiveTrack.vol(), 0);
    }
    keyElement.onmouseover = function() { if (MouseIsDown) { _keyAction(); } };
    keyElement.onmousedown = function() { MouseIsDown=true; _keyAction(); };
    keyElement.onmouseleave = function () {
      keyboard.unhighlight(key, KeyPressColor);
    }
    keyElement.onmouseup = function (event) {
      keyboard.unhighlight(key, KeyPressColor);
      if (setTrackTickKey) setTrackTickKey(key);  // Evaluate the track callback passing the key/note index.  Generally this will be used to set the key/note in the track at its cursor position.
    }
  });//map function
} // setupKeyboard()


/* The synth tracks all share one cursor for the keyboard.  It could be the case that there are multiple keyboards.  This means the keyboard should keep track of which track and tick the cursor is.
*/

var currentMouseOverElement = false; // For some reason, mouseleave can occur after mouseover.  This is used to ignore mouseover should it be on an element the mouse is not on any more.
var currentPianoKey = -1;

function setupSynthTrack (track) {

  track.elementTicks.map(function (tickElement, t) {

    tickElement.onmouseover = function (event) {
      // If mousing over a key but still on another key, remove other key's high-light
      if (currentMouseOverElement) {
        Keyboard.unhighlight(currentPianoKey, "yellow")
      }
      // Set this key's high-light
      currentMouseOverElement = event.target;
      currentPianoKey = track.key(t);
      Keyboard.highlight(currentPianoKey, "yellow")

      if (MouseIsDown) this.innerText = ToggleButtonState == 1 ? "X" : "." // If dragging mouse while down, set note
      if (this.innerText=="X") track.playable.play(currentPianoKey, track.vol(), 0); // Play note if on
    }

    tickElement.onmouseleave = function (event) {
      if (event.target == currentMouseOverElement) { // Leaving a tick that we are still on.
        Keyboard.unhighlight(currentPianoKey, "yellow")
        currentMouseOverElement = false;
        currentPianoKey = -1;
      }
    }

    tickElement.onmousedown = function (event) {
      MouseIsDown = true; // Set global state

      // Unset keyboard key and track cursor (if active)
      if (0 <= currentActiveTrack.cursor()) {
        var c = currentActiveTrack.cursor();
        Keyboard.unhighlight(currentActiveTrack.key(c), "blue"); // Erase keyboard's tick high-light
        currentActiveTrack.elementTick(c).style.backgroundColor = currentActiveTrack.backgroundColor(c); // Erase tick's high-light.
      }

      // At this point, no tick nor keyboard key is high-lighted with the blue

      var sameHighlight = (currentActiveTrack == track) && (track.cursor() == t); // Is the same tick selected?

      // Set keyboard keyand track tick cursor
      Keyboard.highlight(track.key(t), "blue")
      this.style.backgroundColor = "blue";
      track.setCursor(t)

      // Flip a tick's note if it's not selected or already highlighted.  That way an already selected note can be slected and immediately edited in the keybard.
      if (sameHighlight || this.innerText==".") {
        ToggleButtonState = this.innerText == "." ? 1 : 2;
        this.innerText = ToggleButtonState == 1 ? "X" : "."
      }

      // Update Callback for the keyboard to set this current new track's tick's key/note value.
      setTrackTickKey = function (k) {
        Keyboard.unhighlight(track.key(track.cursor()), "blue") // Erase old keyboard active tick key
        track.setKey(t, k);
        Keyboard.highlight(track.key(t), "blue") // Set keyboard key to this active track's tick
      }

      // Play the note
      if (this.innerText=="X") track.playable.play(track.key(t), track.vol(), 0);

      // Update the ticklist element with each note from this track.  Eventually this will be another way to edit/move notes of the active track.
      //var sheetElement = document.getElementById("phraseMain").getElementsByClassName('ticklist')[0];
      //sheetElement.innerText = "";
      //track.elementTicks.map(function (e){ sheetElement.innerText += e.innerText; });

      // Make sure the rest of the world knows about the latest track
      currentActiveTrack = track;
    };

    tickElement.onmouseup = function (event) { }

  }); // map function
}

function setupDrumTrack (track) {
  track.elementTicks.map(function (tickElement, t) {

    tickElement.onmousedown = function (event) {
      MouseIsDown = true;
      ToggleButtonState = this.innerText == "." ? 1 : 2;
      this.innerText = ToggleButtonState == 1 ? "X" : "."
      if (this.innerText=="X") track.playable.play(track.key(t), track.vol(), 0);
    }

    tickElement.onmouseover = function (event) {
      if (MouseIsDown) { this.innerText = (ToggleButtonState == 1 ? "X" : ".") }
      else if (this.innerText == "X") track.playable.play(track.key(t), track.vol(), 0);
    }
  }); // map function
}


/******************************************************************************
  Creates and maintains a set of parts divided into measures of beats of notes.
  A two measure 4/4 would be initilzed with 4,4,4.

  USAGE::
    var phrase = new createPhrase(measures, beatsper, ticksper)

  CONSTRUCTOR PARAMETERS::
    measures  Number of measures
    beatsper  Beats per measure
    ticksper  Notes per beat

  METHODS::
    phrase.addPart(playable)      Appends a part to the phrase and associates it with a playable object which implements .play(note, vol, when).
    phrase.addPartFixed(playable, fixedNote) Appends a part to the phrase and associates it with a playable object that will be called with a fixedNote.

  NOTES::

    Calls:               Sets:
      setupSynthTrack()    window.Tracks
      setupDrumTrac()      window.currentActiveTrack
                           window.restoreTicks (loads ticks from GET string)

******************************************************************************/
var createPhrase = function (measures, beatsper, ticksper) { // , synths, drumKit) {
  //// Local
  var _mainRythmDOM = document.getElementById("phraseMain");
  var _rythmDOM = _mainRythmDOM.getElementsByClassName('rythm')[0]; // Consider the rythm block where the tracks will live.
  var partCount = 0;

  // Add a new part to this phrase object. It requires a playable object
  var _createPart = function (playable, idx) { // idx can be undefined
    // The track toggle button
    var id = document.createElement('b');
    id.className = "trackid";
    id.innerText = partCount;
    id.style.fontWeight = "normal";
    // Create new part/voice object and store it globally (TODO for now)
    var _track = new Part(id, measures*beatsper, ticksper, beatsper, playable);
    Tracks.push(_track);
    _track.elementName.innerText = playable.name(idx);
    _rythmDOM.appendChild(_track.element);
    // Clicking on the track button will toggle the actual track
    var b = CreateAppendChild('b', _mainRythmDOM.getElementsByClassName('partlist')[0]);
    b.innerText =  partCount;
    b.style.fontWeight = "normal";
    b.style.display = "none";
    b.onmousedown = function(e, be){ toggleElementDisplay(e, be);}.bind(null, _track.element, b);
    id.onmousedown = function(e, be){ toggleElementDisplay(e, be);}.bind(null, _track.element, b);
    ++partCount;
    return _track;
  }

  //// Public
  this.addPart = function (playable) {
    var track = _createPart(playable);
    track.elementName.onmousedown = function () {
      track.playable.waveformNext();
      track.elementName.innerText = track.playable.waveform();
    }
    setupSynthTrack(track);
    currentActiveTrack = track; // Make sure the keyboard can make sounds initially.
  } // addPart

  this.addPartFixed = function (drumKit, fixedNote) {
    var track = _createPart(drumKit, fixedNote);
    track.setAllKeys(fixedNote);
    track.elementName.onmousedown = function () {
      track.play(fixedNote, 0);
      track.elementName.style.color = "white";
    }
    track.elementName.onmouseup = function () {
      track.elementName.style.color = "";
    }
    setupDrumTrack(track);
  } // addPartFixed

  Tracks.beats = measures*beatsper; // Make this info available along with the track objects themselves
  Tracks.ticks = ticksper;

} // createPhrase


var saveTicks = function () {
  var pattern=[];
  var synthTracks=[]; 

  // The track ticks
  Tracks.map(function (track) {
    var byte=0;
    if (track.playable instanceof Synthesizer) synthTracks.push(track); // Keep track of synth tracks.
    track.elementTicks.map(function (te, i) {
      byte = (byte >> 1) + ("." == te.innerText ? 0 : 128);
      if (7==i%8) {
        pattern.push(byte);
        byte=0;
      }
    });
  });

  // The synth track notes
  synthTracks.map(function (track) {
    for (var i=0; i<track.tickLength; ++i) {
      pattern.push(track.key(i))
    }
  });

  window.history.replaceState("ohhai", "Digital Audio Workstation", document.location.href.split('?')[0] + '?'  + Base64(pattern));
}


/* Parse GET string
*/
var restoreTicks = function () {
  var ary = Base64(window.location.search.substring(1));
  if (320 != ary.length) {
    if (0 < ary.length) DB("WARNING: restoreTicks: GET string phrase not detected.");
    return;
  }
  DB("Scanning phrase via GET string...");
  var bit = 0;
  var synthTracks=[];

  Tracks.map(function (track) {
    if (track.playable instanceof Synthesizer) synthTracks.push(track); // Keep track of synth tracks.
    track.elementTicks.map(function (te, i) {
      bit = i%8;
      te.innerText = ((ary[0]>>bit) & 1) ? "X" : ".";
      if (7==bit) ary.shift();
    });
  });

  synthTracks.map(function (track) {
    for (var i=0; i<track.tickLength; ++i) {
      track.setKey(i, ary.shift());
    }
  });
}



/******************************************************************************

 Event loops

******************************************************************************/
var Pause = false;
var Beat = 0; // Forever incrementing
var nextBeatTime = 0.00; // This should be initialized a bit beyond whatever ctx.currentTime is to allow for ramp-up of the code.

/* Periodically high-light whatever beat (and all sub-beats) should be playing
   currently.  It uses the web audio context's currentTime as a time reference.
*/
var rendererLoop = (function (_lastBeat, _lastTick) { return function () {
    if (Pause) return;
    var beat = (Floor(Beat - (nextBeatTime - ctx.currentTime) / BeatDuration) + (1000*Tracks.beats)) % Tracks.beats;
    var t, track, note;
    var tick = (Floor((Beat*Tracks.ticks) - (nextBeatTime - ctx.currentTime) / (BeatDuration / Tracks.ticks)) + (1000*Tracks.beats*Tracks.ticks)) % (Tracks.beats * Tracks.ticks);

    // Over all tracks
    for (t=0; (t < Tracks.length); ++t) {
      track = Tracks[t];
      if (_lastBeat != beat) { // Highlight the current active beat
        track.elementBeat(_lastBeat).style.backgroundColor = track.backgroundBeat(_lastBeat);
        track.elementBeat(beat).style.backgroundColor = "green";
      }

      if (_lastTick != tick) {
        // Highlight the track name
        note = track.elementTick(tick).innerText;
        if ('.' != note) {
          track.elementName.style.color = track.playable.color // Update track name's high-light every tick

          if (track.playable instanceof Synthesizer) { // Highlight this track's keyboard with it's synth's color
            track.playable.highlight(track.key(tick));
          }
        } else {
          track.elementName.style.color = "" // Unhighlight track's name every tick
          if (track.playable instanceof Synthesizer) { // Unhighlight this track's keyboard highlight (if any)
            track.playable.unhighlight();
          }
        }
      }
    }

    _lastBeat = beat;
    _lastTick = tick;
};})(0,0);


/* Periodically tell the various tracks to send their audio out to the audio
   context.
*/
var sequencerLoop = function () { // HACK: The sequencer
  if (Pause) return;
  var currentTime = ctx.currentTime;
  var tickDuration = BeatDuration / Tracks.ticks;

  while (nextBeatTime <= (currentTime + 1.0)) { // Try to keep 1 second of audio rendered ahead of the current time.
    if (0 == (Beat % Tracks.beats)) { saveTicks(); } //  On the initial beat, upate the URL's get string.
    // Over all the track in this measure
    for (var t=0; (t < Tracks.length); ++t) {
      for (var s=0; (s < Tracks.ticks); ++s) {
        var note = Tracks[t].elementTick(Tracks.ticks*(Beat%Tracks.beats) + s).innerText;
        if ('.' != note ) {
            Tracks[t].play((Beat%Tracks.beats)*Tracks.ticks + s, // Calculate the track's tick to play
                           nextBeatTime + (s * tickDuration));
        } //if
      } // ticks
    } // tracks
    Beat += 1.0;
    nextBeatTime += BeatDuration;
  } // while
}


var pause = function (event) {
  var highlight = true;
  var id = false; 
  var color = '#f00';
  var e = document.getElementsByClassName('pause')[0];
  if (Pause = !Pause) {
    DB.post('pause', 'suspend');
    e.style.backgroundColor = color;
    id = setInterval(function(){
                       e.style.backgroundColor = (Pause && (highlight =! highlight)) ? color : '';
                       if (!Pause) { clearInterval(id); }
                     },
                     500);
  } else {
    DB.post('pause', 'resume');
    e.style.backgroundColor = '';
    clearInterval(id);
    if (nextBeatTime <= ctx.currentTime) { nextBeatTime = ctx.currentTime + 0.25; }
  }
}

var reset = function (event) {
  if (Pause) {
    Pause = false;
    DB.post('pause', 'resume');
  }
  Beat = 0;
  nextBeatTime = ctx.currentTime + 0.25;
}

var HideState=false;
var hide = function (event, classToHide) {
  if (HideState) {
    event.target.parentElement.getElementsByClassName('rythm')[0].style.display = "";
    HideState = false;
  } else {
    event.target.parentElement.getElementsByClassName('rythm')[0].style.display = "none";
    HideState = true;
  }
}

var toggleElementDisplay = function (e, be) {
  e.style.display = (e.style.display=="none" ? "" : "none");
  be.style.display = (e.style.display == "none" ? "" : "none");
}



var setupControls = function () {
  //document.getElementById('speed').onmouseenter = function (event) { event.target.focus(); }
  //document.getElementById('speed').onmouseleave = function (event) { event.target.blur(); }

  document.getElementById('speed').onkeydown = function (event) {
      //DB("onkeydown speed: " + event.keyCode);
      if (event.keyCode == 38) {
        var newDuration = parseInt(event.target.innerText.replace("\n",""))+1;
        event.target.innerText = newDuration;
        BeatDuration = 60/newDuration;
      } // if
      if (event.keyCode == 40) {
        var newDuration = parseInt(event.target.innerText.replace("\n",""))-1;
        event.target.innerText = newDuration;
        BeatDuration = 60/newDuration;
      } // if
  }

  document.getElementById('speed').onkeypress = function (event) {
    //DB("onkeypress speed: " + event.keyCode);
    setTimeout(function() { // The GUI is slower than this event handler which ends up adding the newline after this code removes it.  So delay this code a bit.
      if (event.keyCode == 13) {
        var newDuration = parseInt(event.target.innerText.replace("\n",""));
        event.target.innerText = newDuration;
        BeatDuration = 60/newDuration;
      } // if
    }); // function
  } // function


  document.getElementById('freq').onmouseenter = function (event) { event.target.focus(); }
  document.getElementById('freq').onmouseleave = function (event) { event.target.blur(); }
  document.getElementById('freq').onkeypress = function (event) {
    setTimeout(function () { // The GUI is slower than this event handler which ends up adding the newline after this code removes it.  So delay this code a bit.
      if (event.keyCode == 13) {
        Keyboard.setStartFrequency(event.target.innerText = parseFloat(event.target.innerText.replace("\n","")));
      } // if
    }); // function
  } // function

  // Let's make a few elements moveable between each other

  /* I Shift has been pressed over a moveable block
       * position:absolute  
       * 
       event.target.parentElement
            .clientX/Y
                       .getBoundingClientRect().left/right
  */
  var ShiftClientX = 0;
  var ShiftClientY = 0;
  var Slots = [];
  var tempElem = false;

  /* As the mouse moves around the element, keep track of its relative location */
  var createMover = function (moverId) {

    document.getElementById(moverId).onmousemove = function (event) {
      if (!ShiftIsDown) {
        event.target.focus();
        // The moveable element's offset from the mouse.
        ShiftClientX = Floor(event.clientX - event.target.getBoundingClientRect().left);
        ShiftClientY = Floor(event.clientY - event.target.getBoundingClientRect().top);
        //DB("event.clientXY " + ShiftClientX + " " + ShiftClientY);
      }
    }

    document.getElementById(moverId).onkeydown = function (event) {
      if (ShiftClientX && !ShiftIsDown && event.shiftKey) {
        var elem = event.target;
        var parent = elem.parentElement;
        ShiftClientX += parent.getBoundingClientRect().left;
        ShiftClientY += parent.getBoundingClientRect().top;
        ShiftIsDown = true;
        //DB(ShiftIsDown);
        event.tabindex=1;
        event.target.style.left = event.offsetLeft + "px"
        event.target.style.top = event.offsetTop + "px"
        event.target.style.position = 'absolute'
        event.target.style.opacity = 0.7
        event.target.style.border = "solid 1px white";

        // Create the slots this element can be moved to.
        for (var i=0; (i < parent.children.length); i++) {
          var child = parent.children[i];
          if (child != elem) Slots.push(child);
        }
        // Create the placeholder
        tempElem = elem.cloneNode(true);
        tempElem.style.position = 'static';

        //event.target.style.border = "solid thin white";
        ShiftCallback = function (event) { // What to do when the mouse moves while shift is held down.
          var shiftX = event.clientX - ShiftClientX;
          var shiftY = event.clientY - ShiftClientY;
          elem.style.left =  shiftX + "px";
          elem.style.top =  shiftY + "px";
          //DB("global:" + event.clientX + " " + event.clientY);
          //Where to insert the place holder
          for (var i=0; (i < Slots.length); ++i) {
            if (20 > Abs(Slots[i].offsetLeft - shiftX)) {
              parent.insertBefore(tempElem, Slots[i]);
            }
          }
        }
        ShiftCallbackDone = function (event) {
          event.target.style.left = "";
          event.target.style.top = "";
          event.target.style.position = "";
          event.target.style.opacity = "";
          event.target.style.border = "";
          ShiftClientX = ShiftClientY = false;
          parent.insertBefore(elem, tempElem);
          parent.removeChild(tempElem);
          elem.outerHTML += " ";
          createMover(moverId);
          Slots = [];
        }
        ShiftCallback(event);
      } // if
    } // function
  } // createMover

  //createMover('freq');
  //createMover('speed');
} // setupControls ()



/******************************************************************************

 Main

 TODO:
  Moveable DOM elmeents 
   shrinkable
   raisable

 CONCEPTS

 Pressing a physical key/pad creates a note message/event.

 Sheet
  Phrase      \
   Measure/Bar \Parts/Voices
    Beat       /
     Tick     /


  Sheet of one phrase.  Phrase of parts broken divided into two measures. Measures/bars of four beats. Beats divided into X number of ticks.
    x, xx x. .. x, x. xx x.       Tick order:  1 3 
    ,, .. x. .. ,, .. .x .x                    |/| 
                                               2 4 
  Official      Me
  ------------- --------
  Part / Voice  track Deprecated
  Quarter note  beat
  Shortest note tick
  

  The only thing the sequencer needs to keep track of are ticks.  Everything
  else is for visual grouping and rendering.

******************************************************************************/
window.onload = function () {
  DB("::onload");

  // Create a phrase with 4 measures, 4 beats per measure, and 4 ticks per beat.
  var phrase = new createPhrase(4, 4, 4);

  // Create a piano in the dom.  61 keys, starting at C in octave 2.
  Keyboard = new PianoKeyboard("piano1", 61, 0, 2, 65.4064);
  setupKeyboard(Keyboard); // Give the piano immediate playing capability

  // Add synth parts to the phrase
  phrase.addPart(new Synthesizer(ctx, Keyboard, "red"));
  phrase.addPart(new Synthesizer(ctx, Keyboard, "green"));
  phrase.addPart(new Synthesizer(ctx, Keyboard, "cyan"));

  // Add drum parts to the phrase
  var filenames = ["808.bass.raw", "808.snare.drum.raw", "808.snare.noise.raw", "808.maracas.raw", "808.cowbell.raw", "808.rim.raw", "808.highhat.closed.raw", "808.claves.raw", "808.clap.raw", "808.highhat.opened.raw", "808.cymbal.raw", "909.thump.raw", "909.snare.noise.raw"];
  var DrumKit = new Drumkit(ctx, "orange", new AudioBuffers(filenames));
  for (var n=0; n<filenames.length; ++n) { phrase.addPartFixed(DrumKit, n) }

  restoreTicks(); // Parse get string

  // Setup menus and moveable buttons.
  setupControls();

  // Begin event loops
  setInterval(rendererLoop, 50);
  setInterval(sequencerLoop, 50);
  //Base64.test();

  nextBeatTime = ctx.currentTime+1.2;

  DB("--onload [" + DB.status() + "]");
}


//]]></script>

</body></html>
