<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
 <title>Digital Audio Workstation</title>
 <link rel="stylesheet" href="index.css" type="text/css" media="screen" title="Shrewm"/ >
</head>
<body>

<h1>Digital Audio Workstation</h1>
<hr/>
<p class="mainNav">
 <a href="http://webaudio.github.io/web-audio-api/">[WebAudio]</a>
 <a href="http://validator.w3.org/check/referer">[XHTML 1.0]</a>
 <a href="http://jigsaw.w3.org/css-validator/check/referer/">[CSS 2.1]</a>
</p>

<div id="piano"></div>
<br/>
<!-- each track gets a bunch of beats -->
<div id="rythm">
</div>
<p style="display:inline-block; background:#080"  onmousedown="pause=!pause; this.style.background=pause?'red':'green'; Beat = Floor(ctx.currentTime / BeatDuration)">pause</p>

<p id="DB"></p>

<script type="text/javascript">//<![CDATA[

/******************************************************************************
  Useful aliases
******************************************************************************/
var Floor = Math.floor;
var Pow   = Math.pow;
var CreateAppendChild = function (name, element) { return element.appendChild(document.createElement(name)); }
var CreateInsertBefore = function (name, element) { return element.insertBefore(document.createElement(name), element.firstChild); }

/******************************************************************************
  Debug message console and error checking
  Usage::
    <p id="DB"></p> -- Create the console element.  If nonexistent, this object will revert to using the browser's console.
    DB("string")    -- Send string to info window.  Behaves like a pre element.
    DB.clear()      -- Clear the window of all text
    DB.check(expr, string) -- If expr is false, send string to console.  status() will return false after an error checked.
    DB.status()     -- False if check ever failed.
******************************************************************************/
var DB = (function () {
  var consoleElement = document.getElementById('DB');
  var self;
  var status = true;

  var setStyles = function (e) {
    e.style.border = "solid thin green";
    e.style.whiteSpace = "pre";
    e.style.overflow = "auto";
    e.style.maxHeight = "20em";
  }

  // Create the instance which is a function.  Also create the clear function.
  if (!consoleElement) {
    self = function (s) { console.log(s);}
    self.clear = function () { }
  } else {
    setStyles(consoleElement);
    self = function (s) {
      consoleElement.innerHTML += "\n" + s;
      consoleElement.scrollTop = consoleElement.scrollHeight;
    }
    self.clear = function () { consoleElement.innerHTML = ""; }
  }

  self.check = function (expr, msg) {
    status = status && expr;
    return expr || self(msg) && false;
  }

  self.status = function () { return status; }

  return self;
})(); // DB


/******************************************************************************
  Database of Web Audio audio buffers.  It will download and convert raw audio
  files into ready to use AudioBuffers.

  USAGE::
    var noises = new AudioBuffersDB(["song1.raw", "song2.raw"]);
    noises.length         Number of files loaded.
    noises.fileName(i)    Get a filename.
    noises.audioBuffer(i) Get an audio buffer or undefined.
******************************************************************************/
var AudioBuffersDB = function (fileNames) {

  // Private

  var _audioBuffers = [];

  function _Validate () {
    if (!DB.check(fileNames && Array.isArray(fileNames), "ERROR: AudioBuffersdb: Invalid fileNames ary.")) {
      fileNames = [];
    }
  }

  function _loadRawAudioFiles () {
    fileNames.forEach(function (fn, i) { // forEach passes in each ary element and the index.
      var client = new XMLHttpRequest();
      client.open('GET', fn);
      client.responseType = "arraybuffer";
      client.onreadystatechange = // Callback after remote file has been loaded
        function () {
          if (4 != client.readyState) return;
          DB.check(200 == client.status, "ERROR: AudioBuffersDB._loadRawAudioFiles:  Problem with file '" + client.responseURL + "'");
          if (200 == client.status) {
            var samples = new Int16Array(client.response); // Consider u8 ary as s16 ary.
            // Normalized each s16 sample to f32 between -1 and 1.
            var Noise =  new Float32Array(samples.length);
            for (var j=0; j<samples.length; ++j) {
              Noise[j] = samples[j]/32768;
            }
            // Create and set the audio buffer
            _audioBuffers[i] = ctx.createBuffer(1, samples.length, 44100);
            _audioBuffers[i].getChannelData(0).set(Noise);
          } // if
        } // function()
      client.send();
    }); // forEach function
  } // function

  // Construct

  _Validate();
  _loadRawAudioFiles();

  // Public

  this.length = fileNames ? fileNames.length : 0;
  this.fileName = function (i) { return fileNames[i]; }
  this.audioBuffer = function (i) { return _audioBuffers[i]; }
  this.setAudioBuffer = function (i, o) { _audioBuffers[i] = o; } // TODO: get rid of this
} // AudioBuffersDB 


/******************************************************************************
  Create a piano keyboard in the DOM.

  USAGE::
    var Keyboard = new PianoKeyboard("piano", 37, 0, 1, 130.813);

  CONSTRUCTOR PARAMETERS::
    DOM element id
    number of keys
    starting key (0==C, 1==C#, ... 11=B)
    octave
    first specified key's frequency

  METHODS::
    Keyboard.keyElements     All key DOM elements in an array
    Keyboard.keyElement      Get the DOM element representing the white or black key
    Keyboard.freq(key)       Frequency of key.  Indexed between 0 and number of keys (36 in this example).
******************************************************************************/
var PianoKeyboard = function (id, keyCount, startKey, startOctave, startFrequency) {

  //// Private

  var _pianoDOM = document.getElementById(id);
  DB.check(_pianoDOM, "ERROR: PianoKeyboard: Element id=" + id + " not found in DOM.");

  var _keysDOM = []; // Keeps track of the DOM elements which represent the white and black keys in order.

  var _createDOM = function () {
    var notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    var sharps = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0]; // Bool table of sharps in an octave, starting at C
    var newKey, keyPair = false; // The piano DOM is composed of divs containing either just a div (white key) or div and p (white and black key)
    startKey += startOctave*12; // Adjust initial key to account for octave
    for (var i=0; (i < keyCount); ++i) {

      if (sharps[(i + startKey)%12]) {
        // Create the sharp key.  If this is the first key, the key pair element needs to also be created.
        keyPair || (keyPair = CreateAppendChild('div', _pianoDOM));
        newKey = CreateAppendChild('p', keyPair);
      } else {
        // Create the natural key.
        keyPair = CreateAppendChild('div', _pianoDOM);
        var note   = (i + startKey) % 12;
        var octave = Floor((i + startKey) / 12);
        newKey = CreateAppendChild('div', keyPair)
        newKey.innerText = notes[note] + (note==0?octave:'');
      }

      _keysDOM.push(newKey); // Keep track of each created key.
    }
  }

  // Construct

  _createDOM();
  DB.check(keyCount == _keysDOM.length, "ERROR: PianoKeyboard: Created incorrect number of keys.");

  // Public

  this.keyElements = _keysDOM;
  this.keyElement = function (i) { return _keysDOM[i]; }
  this.freq = function (k) { return startFrequency * Pow(2, k/12.0);  }
} // PianoKeyboard 


/******************************************************************************
  Create a playable drumkit.  Expects a webaudio context and Audio Buffers DB.

  USAGE::
    var DrumKit = new Drumkit(ctx, audioBufers);

  CONSTRUCTOR PARAMETERS::
    An web audio context and audio buffers object.

  METHODS::
    DrumKit.play(soundIdx, when)  Plays key specified by the Keyboard object at
                                  webaudio context time 'when' or immediately if
                                  when==0.
******************************************************************************/
var Drumkit = function (ctx, audioBuffers) {
  //// Local
  var release = 0.5; // Release time in seconds for both the filter and gain.
  //// Public
  this.play = function (drum, when) {
    var audioBuffer = audioBuffers.audioBuffer(drum);
    if (!audioBuffer) return; // Do nothing if no audio buffer.
    var now = when==0 ? ctx.currentTime : when; // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
    var source = ctx.createBufferSource();
    source.buffer = audioBuffer;
    source.start(when);
    source.onended = function() { source.disconnect(); } // When the audio stops, remove it from the graph.
  
    if (drum == 0) { // HACK: need to generalize a sound pipeline
      // Loop the bass noise for one second with a LPF and gain ramp.
      var release=0.9
      source.playbackRate.setValueAtTime(0.4, now);
      source.playbackRate.linearRampToValueAtTime(0.37, now+release);
      source.loop = true;
      source.stop(now + release);
  
      var lp = ctx.createBiquadFilter(); // LPF
      lp.type = "lowpass";
      lp.frequency.value = 120;
      lp.Q.value = 0.5;
  
      var gain = ctx.createGain(); // Ramp
      gain.gain.setValueAtTime(0.7, now);
      gain.gain.linearRampToValueAtTime(0, now+release);
  
      source.connect(lp);
      lp.connect(gain);
      source = gain;
    }

    source.connect(ctx.destination);
  }
} // Drumkit


/******************************************************************************
  Create a playable synthesizer.  Expects a webaudio context global ctx to be
  defined.

  USAGE::
    var Synth = new Synthesizer(Keyboard);

  CONSTRUCTOR PARAMETERS::
    A web audio context.
    An instantiated playable object.

  METHODS::
    Synth.play(key, when)  Plays key specified by the Keyboard object at
                           webaudio context time 'when' or immediately if
                           when==0.
    Synth.lastKey()        Get last key played
    Synth.waveform()       Get current waveform string.
    Synth.waveformNext()   Select the next waveform.
******************************************************************************/
var Synthesizer = function (ctx, keyboard) {
  //// Local
  var _release = 0.5; // Release time in seconds for both the filter and gain.
  var _waveforms = ["sine", "square", "sawtooth", "triangle"];
  var _waveformIdx = 0;
  var _lastKey = 0;

  var _play = function (key, when) {
    var now = when==0 ? ctx.currentTime : when; // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
    var osc = ctx.createOscillator(); // Create and add to table if not already
    osc.frequency.value = keyboard.freq(key); // Ask the keyboard object for the frequency of this key
    osc.type = _waveforms[_waveformIdx];
    osc.start(now);
    osc.stop(now + _release);
    osc.onended = (function(osc){ return function() { osc.disconnect(); }})(osc);

    var gain = ctx.createGain();
    gain.gain.setValueAtTime(0.4, now);
    gain.gain.linearRampToValueAtTime(0, now + _release);

    osc.connect(gain);
    gain.connect(ctx.destination);

    _lastKey = key;
  }

  //// Public
  this.play = _play;
  this.lastKey = function () { return _lastKey; }
  this.waveform = function () { return _waveforms[_waveformIdx]; }
  this.waveformNext = function () {
    if (_waveforms.length == ++_waveformIdx) _waveformIdx=0;
  }
} // Synthesizer


/******************************************************************************
  Creates a track.  Plays a sequence of sounds.

  USAGE::
    var track = new Track(playableObject, defaultNote);

  CONSTRUCTOR PARAMETERS::

  METHODS::
    track.playable          Get the playable object
    track.element           Get the DOM element
    track.elementBeat(i)    Get the ith beat element
    track.elementTicks      get array of all tick elements.
    track.elementTick(i)    Get the ith tick element
    track.elementName       Get the DOM name element for this track
    track.backgroundBeat(i) Get ith beat's original background.
    track.backgroundTick(i) Get ith tick's original background.
    track.tickLength        Get number of ticks
    track.key(i)            Get the key at tick i.
    track.setKey(i, key)    Set the ith tick's key.
    track.setAllKeys        Set the default key or drum index.
    track.play(tick, when)  Play the note at sequence 'tick'
    track.tick(time)        Sequences all sounds from the web audio's context
                            current time through the specified 'time' parameter.
******************************************************************************/
var Track = function (ctx, beatCount, subBeatCount, playable) {
  //// Local
  var _beatCounter = 0;
  var _element; // The DOM element
  var _elementBeats = [];
  var _elementTicks = [];
  var _elementName;
  var _notes = []; // Each tick (beatCount * subBeatCount) gets its own key.
  var _beatOriginalBackground = [];
  var _tickOriginalBackground = [];

  var _createElements = function () {
    var p;
    _element = document.createElement('div'); // Track element
    _element.className = "track";
    // Add beat elements to DOM
    for (b=0; (b < BeatCount); ++b) {
      var beatElement = CreateAppendChild('div', _element); // Beat element added to track element
      beatElement.className = "beat";
      beatElement.style.backgroundColor = ["#333", "#222", "#222", "#222"][_beatCounter++ % subBeatCount];
      // Keep track of the beat DOM element and its default background color.
      _elementBeats.push(beatElement);
      _beatOriginalBackground.push(beatElement.style.backgroundColor);
      for (t=0; (t < subBeatCount); ++t) {
        var tickElement = CreateAppendChild('p', beatElement); // Four tick elements added to each beat element
        tickElement.className = "tick"
        //var v = parseInt(window.location.search[1+track+(TrackCount+1)*beat], 16) // Consider prexisting beat state
        //tickElement.innerText = (v & 1<<i)? "X" : ".";
        tickElement.innerText = '.';
        // Keep track of the track DOM element and its default background color.
        _elementTicks.push(tickElement);
        _tickOriginalBackground.push(tickElement.style.backgroundColor); // Cache original background color of beat element
        _notes.push(b); // Build up the tick's key values.
        tickElement.onmousedown = function (event) {
          MouseIsDown = true;
          ToggleButtonState = this.innerText == "." ? 1 : 2;
          this.innerText = ToggleButtonState == 1 ? "X" : "."
        }
        tickElement.onmouseover = function (event) {
          if (0 == ToggleButtonState) {
            ToggleButtonState = this.innerText == "." ? 1 : 2;
          }
          if (MouseIsDown) this.innerText = ToggleButtonState == 1 ? "X" : "."
        }
      }
    }
    // Add sound name element to this track DOM element
    _elementName = CreateAppendChild('p', _element);
    _elementName.className = "name"
  }

  var _setAllKeys = function (key) {
    for (var t=0; t<_notes.length; ++t) { _notes[t] = key; }
  }

  // Construct
  _createElements();

  //// Public
  this.playable = playable;
  this.element = _element;
  this.elementBeat = function (i) { return _elementBeats[i]; }
  this.elementTicks = _elementTicks;
  this.elementTick = function (i) { return _elementTicks[i]; }
  this.elementName = _elementName;
  this.backgroundBeat = function (i) { return _beatOriginalBackground[i]; }
  this.backgroundTick = function (i) { return _tickOriginalBackground[i]; }
  this.tickLength = _notes.length;
  this.key = function (k) { return _notes[k]; }
  this.setKey = function (tick, key) { _notes[tick] = key; }
  this.setAllKeys = function (key) { _setAllKeys(key); }
  this.play = function (tick, when) { playable.play(_notes[tick], when); }
  //this.tick = function (time) { }
} // Track


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


DB.check((window.AudioContext || window.webkitAudioContext), "Audio context not found.");
var ctx = new (window.AudioContext || window.webkitAudioContext)();

var Keyboard;
//var PianoSequencerNotes = []; // 64 (4 measures, 4 beats, 4 sub-beats) Sixteenth count array of note indices
var Synth; // The synthesizer object
var Drumkit; // The drumkit object
var Tracks = [];
//var CurrentPianoNote = 0;
var pause=false;

var setTrackTickKey = false; // This becomes a function that sets the key of some track.

var Noises = new AudioBuffersDB( // Object containg AudioBuffers derived from remote files
 ["808.bass.raw",
  "mom.raw",
  "808.snare.noise.raw",
  "808.maracas.raw",
  "808.cowbell.raw",
  "808.rim.raw",
  "808.highhat.closed.raw",
  "808.claves.raw",
  "808.clap.raw",
  "808.highhat.opened.raw",
  "808.cymbal.raw",
  "909.thump.raw",
  "909.snare.noise.raw"]);

var MouseIsDown = false;
var ToggleButtonState = 0;
var TrackCount = Noises.length;
var BeatCount = 16;
var BeatDuration = .125  /* + 0.0625 +  0.03125;*/ // Keep timing binary friendly.

window.onmouseup = function () { MouseIsDown = false; }
window.onkeydown = function () { if (event.keyCode == 191) DB.clear(); }


var beatCounter = 0;
function setupTrack (track) {
  var lastKey=0;
  var currentMouseOverElement = false; // For some reason, mouseleave can occur after mouseover.  This is used to ignore mouseover.

  track.elementTicks.map (function (tickElement, t) {

    tickElement.onmouseover = function (event) {
      currentMouseOverElement = event.srcElement;
      if (0 == ToggleButtonState) {
        ToggleButtonState = this.innerText == "." ? 1 : 2;
      }
      if (MouseIsDown) this.innerText = ToggleButtonState == 1 ? "X" : "."
      Keyboard.keyElement(lastKey).style.backgroundColor="";
      Keyboard.keyElement(track.key(t)).style.backgroundColor="yellow";
      lastKey = track.key(t);
    };

    tickElement.onmouseleave = function (event) {
      //this.style.backgroundColor="";
      //Keyboard.keyElement(PianoSequencerNotes[hoverHilight]).style.backgroundColor="";
      //Keyboard.keyElement(PianoSequencerNotes[CurrentPianoNote]).style.backgroundColor="yellow";
      //TracksBeats[TrackCount-1][Floor(CurrentPianoNote/4)].element.children[CurrentPianoNote%4].style.backgroundColor="yellow";
      if (currentMouseOverElement == event.srcElement) Keyboard.keyElement(lastKey).style.backgroundColor="";
    };

    tickElement.onmousedown = function (event) {
      MouseIsDown = true;
      ToggleButtonState = this.innerText == "." ? 1 : 2;
      this.innerText = ToggleButtonState == 1 ? "X" : "."
      //Keyboard.keyElement(PianoSequencerNotes[CurrentPianoNote]).style.backgroundColor="";
      //CurrentPianoNote = beat*4+i;
      //Keyboard.keyElement(PianoSequencerNotes[CurrentPianoNote]).style.backgroundColor="yellow";
      setTrackTickKey = function (k) { track.setKey(t, k); }
      lastKey = track.key(t);
    };

    //var j = 1+(TrackCount+1)*BeatCount; // Start of the 2 hex character note indices
    //j += 2*(beat*4 + i);
    //PianoSequencerNotes[beat*4 + i] = parseInt(window.location.search.substring(j, j+2), 16)|0;
    //var v = parseInt(window.location.search[1+track+(TrackCount+1)*beat], 16) // Consider prexisting beat state
    //tickElement.innerText = (v & 1<<i)? "X" : ".";
  }); // map function
}


var setupKeyboard = function (keyboard, synth) {
  var lastHitNote = 0;

  // Register mouse event handlers for every DOM keyboard element representing a key.
  keyboard.keyElements.map(function (keyElement, key) {
    var keyboardPress = function () {
      keyboard.keyElement(lastHitNote).style.backgroundColor=""; // Reset current key hilight
      lastHitNote = key;
      keyboard.keyElement(key).style.backgroundColor="#08f"; // Set current key hilight
      synth.play(key, 0);
      if (setTrackTickKey) { setTrackTickKey(key); }
    }
    keyElement.onmousedown = function() { MouseIsDown=true; keyboardPress(); };
    keyElement.onmouseover = function() { if (MouseIsDown) { keyboardPress(); } };
    //keyElement.onmouseout = keyElement.onmouseup = function() { keyboard.keyElement(lastHitNote).style.backgroundColor=""; }
  });//map function

} // setupKeyboard


var createTracks = function (synths, drumKit) {
  var rythmDOM = document.getElementById("rythm"); // Consider the rythm block where the tracks will live.
  var track;

  for (c=0; (c < synths.length); ++c) {
    // Create synth tracks which are kept track of in global 'Tracks'
    Tracks.push(track = new Track(ctx, 16, 4, synths[c]));
    track.elementName.innerText = track.playable.waveform();
    track.elementName.onmousedown = (function (track) { return function () {
      track.playable.waveformNext();
      track.elementName.innerText = track.playable.waveform();
    }})(track);
    rythmDOM.appendChild(track.element);
    setupTrack(track);
  }

  // Create beat tracks which are kept track of in global 'Tracks'
  for (i=0; (i < Noises.length); ++i) {
    Tracks.push(track = new Track(ctx, 16, 4, drumKit));
    track.elementName.innerText = Noises.fileName(i);
    track.setAllKeys(i);
    track.elementName.onmousedown = (function(track, key) { return function () { track.play(key, 0); }})(track, i);
    rythmDOM.appendChild(track.element);
  }
} // createTracks


/* Whenver this is called, it will highlight whatever beat should be playing
   currently.  It uses the web audio context's counter as a reference.
*/
var LastRenderedTick = -1;
var BeatLast = 0; // Quarter beat

var rendererLoop = function () {
    if (pause) return;
    var t;
    var tick = Floor(ctx.currentTime / (BeatDuration/4)) % (BeatCount*4); // Realtime tick (16th beat)
    var beat = Floor(tick/4); // 1/4 beat

    if (LastRenderedTick == tick) return;

    for (t=0; (t < Tracks.length); ++t) {
      // 1/4th beat rendering
      Tracks[t].elementBeat(BeatLast).style.backgroundColor = Tracks[t].backgroundBeat(BeatLast);
      Tracks[t].elementBeat(beat).style.backgroundColor = "green";
    }
    LastRenderedTick = tick;
    BeatLast = beat;
}


var Beat = 0; // Forever incrementing
var pattern="";
var sum = 0;
var sequencerLoop = function () { // HACK: The sequencer
  if (pause) return;
  while ((Beat * BeatDuration) <= (ctx.currentTime + 1.0)) { // Perform up to one second in the future

/*
    if (0 == (Beat % BeatCount)) { //  On the initial beat, upate the URL's get string.
      for (i=0; i<PianoSequencerNotes.length; ++i) // Add the note values for the synth track
         pattern += (PianoSequencerNotes[i]<16?"0":"") + PianoSequencerNotes[i].toString(16);
      window.history.replaceState("ohhai", "Digital Audio Workstation", document.location.href.split('?')[0] + '?'  + pattern);
      pattern="";
    }
*/
    for (var t=0; (t < Tracks.length); ++t) {
      sum = 0;
      for (s=0; s<4; ++s) {
        var note = Tracks[t].elementTick(4*(Beat%BeatCount) + s).innerText;
        if ('.' != note ) {
            Tracks[t].play((Beat%BeatCount)*4 + s, Beat * BeatDuration + (s*BeatDuration)/4);
          sum += 1<<s; // Add the 16th notes giving a value between 0x0 and 0xf (used in the URL's get string);
        } //if
      } // sub beats
      pattern = pattern + sum.toString(16);
    } // beats
    Beat += 1.0;
  } // while
}


/* Main
*/
window.onload = function () {
  DB("::onload");

  Keyboard = new PianoKeyboard("piano", 39, 0, 1, 130.813); // Create a piano in the dom.  SID 4 EVR
  Synth    = new Synthesizer(ctx, Keyboard);
  Synth2   = new Synthesizer(ctx, Keyboard);
  Synth3   = new Synthesizer(ctx, Keyboard);
  DrumKit  = new Drumkit(ctx, Noises);
  setupKeyboard(Keyboard, Synth); // Give the piano immediate playing capability
  createTracks([Synth, Synth2, Synth3], DrumKit);
  setInterval(rendererLoop, 50);
  setInterval(sequencerLoop, 50);

  DB("--onload [" + DB.status() + "]");
}

//]]></script>


</body></html>
