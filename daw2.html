<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html version="-//W3C//DTD XHTML 1.1//EN"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xml:lang="en" lang="en"
      xsi:schemaLocation="http://www.w3.org/1999/xhtml http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd">
<head>
 <title>Liveka7 DAW</title>
 <link rel="stylesheet" href="daw2.css" type="text/css" media="screen" title="Shrewm"/>
</head>
<body>

<p id="xDB" style="width:24em; background:black; z-index:1; border:solid 1px green; white-space:pre; overflow:auto; max-height:10em; position:fixed; right:0; bottom:0"></p>


<div style="float:right">&#x2669; &#x266b; &#x266a; &#x266c; &#x266d; &#x266e; &#x266f;</div>

<h1>Liveka7 Digital Audio Workstation 2<span style="font-family:monospace">&#x03b1;</span></h1>
<hr/>
<div id="headerNav" class="headerNav">
 <a id="info" style="background-color:#22f;width:2em;text-align:left;display:inline-block"></a>
 <a onmousedown="window.location.href=window.location.pathname+''">Clear</a>
 <a onmousedown="popupToggle('pauseicon')">Kitteh</a>
 <a href="https://www.w3.org/TR/webaudio/">WebAudio</a>
</div>

<div class="window">
  <div>SHEET</div>
  <div class="knobs">
    <input type="range" id="volume" class="actor" max="100" value="50" min="0" style="width:6ch" title="VOLUME"/>
    <!--p id="mainVolume">vol</p-->
    <p id="bpm" class="actor" title="BPM" contenteditable="true">60</p>
    <p class="actor reset" title="PLAY" onmousedown="TickerTimer.rewind(this)">|&gt;</p>
    <p id="pause" class="actor pause" title="PAUSE" onmousedown="TickerTimer.pause(this)">||</p>
    <div id="addpart">
      <div style="display:none; border:solid 1px #066; background:#000; white-space:nowrap; position:absolute; z-index:3">
        <div id="createphrase" style="background:#066; text-align:center">Create</div>
        <input id="addmeasures" value="4" type="number"/>Measures<br/>
        <input id="addbeats" value="4" type="number"/>Beats<br/>
        <input id="addticks" value="4" type="number"/>ticks<br/>
      </div>
      <p class="actor" title="NEW PART">+</p>
    </div>
    <!-- p style="font-weight:bold; color:black; background:yellow; border:dashed thick red" class="actor" title="THE DROP (USE SPARINGLY)">&gt!}=-DrOp-={!&lt;</p -->
  </div>
  <div id="sheet" class="sheet"></div>
</div>

<div class="window">
  <div>SYNTHS</div>
  <div class="knobs"> <p id="freq" class="actor" contenteditable="true">27.5</p> <p id="addsynth" class="actor">+</p> </div>
  <div id="synths"></div>
</div>

<div class="window">
  <div>FILTERS</div>
  <div class="knobs">
    <p id="addFilterDelay" class="actor">D</p>
    <p id="addFilterLowpass" class="actor">L</p>
  </div>
  <div id="filters"></div>
</div>

<div class="window">
  <div>KEYBOARD</div>
  <div class="knobs"></div>
  <div>
    <div id="piano1" class="piano"></div>
    <div id="piano2" class="piano"></div>
  </div>
</div>

<p><img id="pauseicon" title="PSYCHEDELIC PAWS" alt="PSYCHEDELIC PAWS" style="display:none; border-radius:50%; clip-path: polygon(35% 0, 100% 55%,35% 100%);" src="catpause.jpg" onclick="ctx.resume()"/></p>


<script type="text/javascript">//<![CDATA[
"use strict"

/******************************************************************************
  Useful aliases and objects
******************************************************************************/
var NBSP = "\u00a0";
var Floor = Math.floor;
var Round = Math.round;
var Ceil  = Math.ceil;
var Pow   = Math.pow;
var Abs   = Math.abs;
var Rnd   = Math.random;
var Max   = Math.max;
var Mod   = function (n,d) { return n - d * Floor(n/d); };
var Trunc2 = function (f) { return f.toFixed(2); }
var ElementById = function(id) { return document.getElementById(id); };

// Generate ary of ints: []  OR  [0..a-1]  OR  [a..b]
// This doesn't work for 0,0 var range=(a,b)=>[...Array(Math.abs((b||0)-(a||0)+!!b-0)).keys()].map(n=>n+a*!!b);
var Range = function (a, b) {
  return (a == undefined) ? [] :
         (b == undefined) ? [...Array(a).keys()] :
         [...Array(b+1-a).keys()].map( n => n+a );
}

var RangeMap = function (rng, f) {
  return (rng instanceof Array ? Range(...rng) : Range(rng)).map(f);
}

var RangeForEach = function (rng, f) {
  return (rng instanceof Array ? Range(...rng) : Range(rng)).forEach(f);
}

var CreateAppendChild = function (name, element, text) {
  var e = element.appendChild(document.createElement(name));
  if (text != undefined) { e.innerText = text; }
  return e;
};

var CreateInsertChild = function (name, element, text) {
  var e = element.insertBefore(document.createElement(name),element.firstChild);
  if (text != undefined) { e.innerText = text; }
  return e;
};

var ToggleElementDisplay = function (e1, e2) {
  let off = e1.style.display == "none"; // 'none' implies not displayed.  '' implies the default CSS value.
  e1.style.display = off ? "" : "none"; // Toggle e1's display state.
  if (e2) { e2.style.display = off ? "none" : ""; } // e2's style is opposite e1.
};


// Reveal instantly an element in the center of the screen if 'show' == true,
// otherwise un-reveal it by slowly reducing opacity over time.
var revealCenter = function (id, show) {
  // Show, reset styles
  let e = ElementById(id);
  let style = e.style;
  style.opacity = style.display = "";
  style.position = "fixed";
  style.top      = (window.innerHeight/2 - e.height/2) + "px";
  style.left     = (window.innerWidth/2 - e.width/2) + "px";
  // Leave on
  if (show) { return; }
  // Slowly vanish
  (e.vanish = (opacity) => {
    if (opacity <= 0.0) {
      // Unshow, reset opacity
      style.display="none";
      style.opacity = ""
    } else {
      style.opacity = opacity;
      setTimeout(e.vanish.bind(null, opacity-0.05), 50);
    }
  })(1.0);
}

/*  Slowly reveal or hide a DOM element.
*/
var popupToggle = function (id) {
  let e = document.getElementById(id);
  let style = e.style;
  let op; // Opacity to start at
  if (style.display == "none") { // If off enable it and ramp opacity from 0 to 1
    style.display = "";
    style.position = "fixed";
    style.top = (window.innerHeight/2 - e.clientHeight/2) + "px"; // Always be centering
    style.left = (window.innerWidth/2 - e.clientWidth/2) + "px";
    op = style.opacity = -1; // Slowly reveal
  } else {
    op = 100; // Slowly disappear
  }
  (e.opacity = (o) =>
    o <= -100
      ? e.style.opacity=""
      : o == 0
        ? (style.opacity="", style.display="none")
        : (style.opacity = Abs(o/100),
           setTimeout( e.opacity.bind(null, o-5), 10))
  )(op);
  e.onmousedown = () => popupToggle(id);
}


// Blink element using color, stop blinking if color false
var blinkify = (e, color) => (
  e.blinker = color
    ? () => (setTimeout( ()=>e.blinker(), 400),
             e.style.backgroundColor = e.style.backgroundColor ? "" : color)
    : () => e.style.backgroundColor = ""
)();


/* A click-toggleable element object

   A DOM element is created and added to parent. When clicked, the appropriate
   handler will be called.  Each callback will receive the event and should
   return a string set to the innerText.  The current state and associated
   element have getters.

   USAGE::
   let a = AppendNewToggleActor(document.body, false, "myclass", ()=>"yes", ()=>"no");
   DB(`State ${a()}  Element ${a.element(}`);
*/
var AppendNewToggleActor = function (parent, state, className, callbackTrue, callbackFalse) {
  let element = CreateAppendChild('p', parent) // New Element
  if (className) { element.className = className; } // Maybe set the class
  // Call appropriate handler and update element's text
  let act = (event) => element.innerText = (state ? callbackTrue : callbackFalse)(event);
  // Event handler: toggle state
  element.onmousedown = (event) => (state = !state, act(event));
  // Call a handler at instantiation so everything is synched
  act();
  // Return state
  let self = () => state;
  // Return DOM element
  self.element = () => element;
  return self;
};


/******************************************************************************
  Debug message console and error checking

  DOM requirements::
    <p id="DB"></p>        -- If nonexistent, the DB object will revert to using the browser's console.

  Usage::
    DB("string")           -- Send string to info window.  Behaves like a pre element.
    DB.log("string")       -- Send string to console.log.
    DB.error("string")     -- Send string to console.log.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.clear()             -- Empty the entire DB element.
    DB.check(expr, string) -- If expr is false, send string to console.  status() will then always return false.
    DB.status()            -- Returns false if check ever failed.
******************************************************************************/
var DB = (function () {
  var consoleElement = document.getElementById('DB');
  var self;
  var status = true;
  var shouldNewline = true; // Want to prepend a newline when the last message was plain text.
  var lastPostType = false, lastPost = false;
  var repeatCount = 0;

  var setStyles = function (e) {
    return;
    e.style.border = "solid 1px green";
    e.style.whiteSpace = "pre";
    e.style.overflow = "auto";
    e.style.maxHeight = "20em";
  }

  // Create the instance which is a function.  Also create the clear function.
  if (!consoleElement) {
    self = function (s) { console.log(s); return s; }
    self.log = self;
    self.error = function (s) { console.error(s);}
    self.post  = function (t, s) { // For the console, only the first post type is displayed.
      console.log("[" + t + "]" + s);
    }
    self.clear = function () { lastPostType = false; }
  } else {
    setStyles(consoleElement);
    self = function (s) {
      if (lastPost == s) {
       ++repeatCount;
        s = repeatCount + s;
      } else {
        repeatCount = 0;
      }
      consoleElement.innerHTML += (shouldNewline ? "" : "\n") + s;
      consoleElement.scrollTop = consoleElement.scrollHeight;
      shouldNewline = lastPostType = false;
    }
    self.log = function (s) { console.log(s); }
    self.error = function (s) { console.error(s); }
    self.post = function (t, s) {
      if (t == lastPostType) {
        if (lastPost == s) { ++repeatCount; }
        consoleElement.lastChild.innerText = (0<repeatCount ? repeatCount : "") + "[" + t + "]" + s;
      } else {
        consoleElement.appendChild(document.createElement('p')).innerText = "[" + t + "]" + s;
        consoleElement.scrollTop = consoleElement.scrollHeight;
        lastPostType = t;
        repeatCount = 0;
      }
      lastPost = s;
      shouldNewline = true;
      return s;
    }
    self.clear = function () {
       consoleElement.innerHTML = "";
      shouldNewline = lastPostType = true;
    }
  }

  self.check = function (expr, msg) {
    status = status && expr;
    return expr || self.error(msg) && false;
  }

  self.status = function () { return status; }

  return self;
})(); // DB



/******************************************************************************
  Useful DAW objects
******************************************************************************/
var ctx = (window.AudioContext && new window.AudioContext()) ||
          (window.webkitAudioContext && new window.webkitAudioContext());
DB.check(ctx, "Missing window.AudioContext.  Use Chrome browser.");


/******************************************************************************
  Hyphen - WebSocket baed Key/Value store

  USAGE::
    hyphen(msg)      Send message to Hyphen
******************************************************************************/
//hyphen.song = function () { return ""; }
var hyphen =
(function () {
   DB ("Connecting to Hyphen!");
   var server = new WebSocket( window.location.protocol=="https:" ? "wss://shroom.dv8.org:7179" : "ws://shroom.dv8.org:7180");
   var song = false;

   // Listener starts off waiting for "HYPHEN" hello message
   server.onmessage = function (e) {
      if (typeof(e.data) == "string") {
         if (e.data != "HYPHEN") {
            DB("hyphen Sent hot bars");
            song = e.data.split("&")[0];;
            window.location.href = window.location.pathname+"?"+song;
         } else {
             DB("hyphen text: " + e.data);
         }
      } else {
         DB("hyphen bin: " + e.data);
      }
   }

   var get = function (songid) {
      if (server.readyState != 1) {
         DB.post("hyphen", "Waiting for connection readyState...");
         setTimeout(get.bind(0, songid), 200);
      } else {
         DB("hyphen sending: get" + songid);
         var ret = server.send("get" + songid);
      }
   }

   var qstr = window.location.search.substring(1).split("&")[0];
   if ( qstr.length < 20) {
      get(qstr);
   }

   var self = get;

   self.server = function () { return server }
   self.song   = function () { return song }

   return self

});


/******************************************************************************
  Base64 encoder and decoder

  USAGE::
    Base64([1,2,3])  Returns a base64 encoded string of the byte (0..255)
                     values in the array.
    Base64("0G83")   Returns a decoded base64 string as an array of bytes
                     values.
    Base64.test(ary) Runs an internal test.  Calls DB.check(ary) on the
                     comparision of the output of the encoding then decoding
                     of the passed byte array.
  ALGORITHM NOTES::
    An incomplete octet will be correctly created because:
    (emptyArray[0] >> num)   =>   (undefined >> num)   =>
******************************************************************************/
var Base64 = (function () {
  //// Private
  var self;
  var base64table = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',
                     'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
                     'W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l',
                     'm','n','o','p','q','r','s','t','u','v','w','x','y','z','-','_'];
  var _encode = function (ary) {
    var ary1 = ary.slice(0); // Copy the array since I shift the elements off.
    var octet=0;     // Which octet to create
    var str = ""; // The encoded string
    while (ary1.length) {
      str +=
        base64table[(0 == octet) ? ary1[0] >> 2 :                              // [000000..]
                    (1 == octet) ? ((ary1.shift() & 3) << 4) + (ary1[0] >> 4) :// [......00][1111....]
                    (2 == octet) ? ((ary1.shift() & 15) << 2) + (ary1[0] >> 6) //           [....1111][22......]
                   /*3 == octet*/: ary1.shift() & 63];                         //                     [..222222]
      octet = ++octet & 3;
    }
    return str;
  }

  var _decode = function (str) {
    var ary=[];
    var i=0, byte, stet0, stet1;
    while (i < str.length) {
      stet0 = base64table.indexOf(str[i]);
      if (!DB.check(0 <= stet0, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      stet1 = base64table.indexOf(byte=str[++i]);
      if (!DB.check(0 <= stet1, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      ary.push((stet0 << 2) + (stet1 >> 4)); // [000000][00....]
      if (++i == str.length) break;


      stet0 = base64table.indexOf(byte);
      if (!DB.check(0 <= stet0, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      stet1 = base64table.indexOf(byte=str[i]);
      if (!DB.check(0 <= stet1, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      ary.push(((stet0&15) << 4) + (stet1 >> 2));//         [..1111][1111..]
      if (++i == str.length) break;


      stet0 = base64table.indexOf(byte);
      if (!DB.check(0 <= stet0, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      stet1 = base64table.indexOf(str[i]);
      if (!DB.check(0 <= stet1, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      ary.push(((stet0&3) << 6) + (stet1));           //                 [....22][222222]
      if (++i == str.length) break;
    }
    return ary;
  }

  var _test1 = function (ary) {
    var str = Base64(ary);
    var ary2 = Base64(str);
    DB.check((ary.toString() == ary2.toString()), ary + " != " + ary2);
  }

  var _test = function () {
    _test1([]);
    _test1([0]);
    _test1([1]);
    _test1([2]);
    _test1([255]);
    _test1([1,255]);
    _test1([255,1]);
    _test1([255,1]);
    _test1([255,1,255]);
    _test1([255,1,255]);
    _test1([1,255,1]);
    _test1([0,0,0,0,0]);
    _test1([0,0,0,0,255]);
    _test1([255,0,0,0,0]);
    _test1([1,1,1,1,1]);
    _test1([255,255,255,255,255]);
  }

  //// Public
  self = function (o) {
    if (Array.isArray(o)) return _encode(o);
    else if (typeof o == "string") return _decode(o);
    else return false;
  }

  self.test = _test;

  return self;
})();

Base64.test();


/******************************************************************************
  GET string wrapper providing a stream object.

  USAGE::
    var gs = new GetStringBase64();

  METHODS::
    .reset           Reset the stream.
    .assertString(s) Match and consume the next bytes as characters to string s.
    .assertBytes(a)  Match and consume the next bytes as bytes to byte array a.
    .nextString(l)   Return next bytes as string of length l.
    .nextBools(c)    Consume and return next c bits as array of bytes.  Unused bits ignored.
    .nextByte()      Consume and return next byte as byte.
    .peekByte()      Return next byte as byte.
    .examine()       Return current internal unBased64 getstring.
    .length()        Return current length of decoded GET string.
******************************************************************************/
var GetStringBase64 = function (get) {
  //// PRIvate
  var self = this;
  var _gsb64 =
    get ||
    (window.location.search.substring(1).length < 20 // Using query as song filename as well
    ? ""
    : window.location.search.substring(1));
  var _gs = [];

  //// PUBLIC
  this.reset = function () {
    _gs = Base64(_gsb64);
  }

  this.assertString = function (str) {
    for (var i=0; i<str.length; ++i) {
      var a = _gs.shift();
      var b = str.charCodeAt(i);
      if (a != b) return false;
    }
    return true;
  }

  this.assertBytes = function (ba) {
    for (var i=0; i<ba.length; ++i) {
      var a = _gs.shift();
      var b = ba[i]
      if (a != b) return false;
    }
    return true;
  }

  this.nextString = function (len) {
    var ret = _gs.splice(0,len);
    return String.fromCharCode.apply(null, ret);
  }

  this.nextBools = function (len) {
    var i=0, b, m, bs=[];
    while (i<len) {
      m = i++%8;
      if (0 == m) {
        if (_gs.length < 1) { return bs; }
        b = _gs.shift();
      }
      bs.push(!!(b >> m&1));
    }
    return bs;
  }

  this.nextByte = function () {
   return (0 < _gs.length) ? _gs.splice(0,1)[0] : null;
  }

  this.peekByte = function () {
   return (0 < _gs.length) ? _gs[0] : null;
  }

  this.examine = function () { return _gs; }
  this.length  = function () { return _gs.length; }

  var _testAssert = function (a, b) { DB.check(a==b, a + " != " + b); }
  var _test = function () {
    var __gsb64 = _gsb64; // Save internal state
    var __gs = _gs;

    _gsb64 = "C34oCm";
    self.reset();
    _testAssert(self.nextByte(), 48);
    _testAssert(self.nextByte(), 49);
    _testAssert(self.nextByte(), 50);
    _testAssert(self.nextByte(), 51);
    _testAssert(self.nextByte(), null);

    _gsb64 = __gsb64; // Restore internal state
    _gs = __gs;
  }

  _test();
  this.reset();
}


/******************************************************************************
  Inter-Broadcast Communication message hyper-loop system.

  USAGE:: var Icb = new IBC();

  METHODS::
    default(m)       Send m to all listeners
    .broadcast(m)    Send m to all listeners
    .listeners()     Get current set of listeners
    .addListener(f)  Add a listener callback which receives m.  Returns an id.
    .delListener(id) Remove aforementioned listener.
    .debug()         Toggle debug

******************************************************************************/
var IBC = function () {
  // Private
  var self;
  var _debug = false;
  var _id = 0;
  var _listeners = []; // Array of [id, callback]
  var _dequeue = [];
  var _sendToAll = function (m) {
    // Are any listeners queued for deletion?
    while (_dequeue.length) {
      var id = _dequeue.pop();
      var i = _listeners.findIndex(function(e){ return id == e[0]; });
      if (0 <= i) { _listeners.splice(i, 1); }
    }
    if (_debug) { DB(_listeners.length + "<-" + JSON.stringify(m)); }
    _listeners.map(function(f){ f[1](m); });
  }
  // Public
  var self = function (m) {
    _sendToAll(m);
  }

  self.broadcast = _sendToAll;
  self.listeners = function () { return _listeners; }
  self.addListener = function (f) { _listeners.push([++_id, f]);  return _id; }
  self.delListener = function (id) {
    _dequeue.push(id);
  }
  self.debug = function () { _debug = !_debug; };
  // Test
  (function(){
    var l1, l2, a=0, b=0;
    DB.check(self.listeners().length==0, "ERROR:  There should be 0 listeners"); // Verify no listerns

    l1 = self.addListener(function (m) { a=m; }); // Register a listener
    self.broadcast(69);                      // Broadcast to listener 1
    DB.check(self.listeners().length==1, "ERROR:  There should be 1 listener, instead " + self.listeners().length);
    DB.check(a==69 && b==0, "ERROR:  Expect 69 and 0 after broadcast: " + a + " " + b);

    l2 = self.addListener(function (m) { b=m; });
    self.broadcast(42);                      // Broadcast to listener 1 and 2
    DB.check(self.listeners().length, 2);
    DB.check(a==42 && b==42, "ERROR:  Expect 42 and 42 after broadcast: " + a + " " + b);

    self.delListener(l1); // Remove listener 1
    self.broadcast(55);                      // Broadcast to listener 2
    DB.check(self.listeners().length==1, "ERROR:  There should be 1 listener"); // Verify no listerns
    DB.check(self.listeners().length, 2);
    DB.check(a==42 && b==55, "ERROR:  Expect 42 and 55 after broadcast: " + a + " " + b);

    self.delListener(l2);
    self.broadcast();
    DB.check(self.listeners().length==0, "ERROR:  There should be 0 listeners"); // Verify no listerns
  })();
  return self;
}();


/******************************************************************************
  Create a slider object in the DOM.

  There will be one slider object that when activated will adjust wherever the
  mouse moves over it be set to the passed in value.  A call back will be
  provided that will be set to the final value.

  USAGE::
    var slider = new DOMSlider();

  CONSTRUCTOR PARAMETERS::
    na             N/A

  METHODS::
    default(e, i, c)  Activate slider in the DOM at the mouse position
                      using event e, initial value i, and setter
                      callback c.
******************************************************************************/
var Slider = function () {
  var callback;
  var mouseMoved = false,  mouseUp = false;
  var e = CreateAppendChild('p', document.body);
  e.style.position = "absolute"
  e.className = "knobs"
  e.style.width="13ch";
  e.style.border="solid 1px #066";
  e.innerHTML = "<p>|-----|-----|\n|-----|-----|</p><div>0</div>";
  e.style.display="none";
  e.style.background="black";
  e.style.zIndex=2;
  e.children[0].onmousemove = function (event) {
    mouseMoved = true;
    var box = event.target.getBoundingClientRect();
    var val = 1.0-((event.clientX - box.left) / box.width + .005)
    if (val < 0.0) val = 0.0;
    if (1.0 < val) val = 1.0;
    event.target.parentElement.children[1].innerText = val.toFixed(2);
    callback(val);
  }
  e.children[0].onmouseleave = function () {
    if (mouseMoved) { e.style.display = "none"; }
  }
  e.onmousedown = function (event) { event.stopPropagation(); }
  e.onmouseup = function (event) { // Handle clicking, releasing, then moving
    if (mouseMoved || mouseUp) { e.style.display="none"; }
    event.stopPropagation();
    mouseUp = true
  }
  return function(event, val, cb) {
    callback = cb;
    e.children[1].innerText = val.toFixed(2);
    mouseMoved = false;
    mouseUp = false;
    e.style.display="block";
    e.style.top = Floor(event.pageY - e.clientHeight/3.0) +"px" ;
    e.style.left = Floor(event.pageX - e.clientWidth*(0.995-val)) +"px" ;
  }
}() // DOMSlider


/******************************************************************************
  Skeuomorphic piano keyboard.  Implements the DOM element as well as the
  audio synthesis.

  USAGE::
    var kb = new PianoKeyboard(id, startKey, keyCount, startOctave);

  CONSTRUCTOR PARAMETERS::
    id             DOM element id to add the new piano element.
    startKey       Initial key using MIDI note values 0..127 == C-1..G9
    keyCount       Number of keys

  METHODS::
DEPREATED    .freq(key)             Frequency of key.
    .highlight(key, color) Highlight the key using color.  Overrides its last
                           color, if any, by pushing new color on a stack.
    .unhighlight(key)      Removes last/top highlighted color and reverts to
                           its previous color (if any)
    .midi(event)           MIDI message to interpret and perform

  GLOBALS::
    IBC: Keyboard will broadcast the physical press.  Listener will act on the
         message and set tick notes, high-light things, send audio to the DAC,
         etc.  Performance is a concern.  Audio stream related messages should
         avoid the IBC and manage private callback lists.
******************************************************************************/
var PianoKeyboard = function (id, keyStart, keyCount) {
  //// Private
  var self = this;
  var element = document.getElementById(id);
  DB.check(element, "ERROR: PianoKeyboard: Element id=" + id + " not found in DOM.");
  var _keysDOM = []; // Keeps track of the DOM elements which represent the white and black keys in order.
  var _highlights = []; // Array of stacks.  An empty stack implies no high-light.
  var _highlightColor = "#f8f"
  var notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

  // Helpers to set/unset key highlight

  var keyPress = function(key) {
    self.highlight(key, _highlightColor); // Set current key high-light
    IBC(["keyboard1", key, true]); // Notify listeners a key was pressed  ["piano1", 12, startPlaying]
  }

  var keyRelease = function(key) {
    self.unhighlight(key, _highlightColor);
    IBC(["keyboard1", key, false]); // Notify listeners a key was released  ["piano1", 12, stopPlaying]
  }

  RangeForEach(keyCount, (i) => {
    let key = keyStart + i;
    let newKey;
    // Sharp or natural key.
    if (2 == notes[key % 12].length) {
      newKey = CreateAppendChild('p', element);
    } else {
      newKey = CreateAppendChild('div', element)
      // Natural key gets a note/octave label
      var octave = Floor((key-12) / 12);
      let note = key % 12;
      newKey.innerText = notes[note] + (note==0?octave:'');
    }

    // Register mouse event handlers for every keyboard DOM element representing a key.
    newKey.onmouseover  = function () { if (MouseIsDown) { keyPress(key); } };
    newKey.onmousedown  = function () { MouseIsDown=true; keyPress(key); };
    newKey.onmouseleave = function () { if (MouseIsDown) { keyRelease(key); } };
    newKey.onmouseup    = function () { keyRelease(key); }

    _keysDOM.push(newKey); // Keep track of each created key.
    _highlights.push([]);
  });

  DB.check(keyCount == _keysDOM.length, "ERROR: PianoKeyboard: Created incorrect number of keys.");

  self.highlight = function (key, color)  {
    //DB.post("PianoKeyboard", ["highlight", key, color])
    let i = key - keyStart;
    if ((0 <= i) && (i < keyCount)) {
      _highlights[i].push(color);
      _keysDOM[i].style.backgroundColor = color;
    }
  }

  self.unhighlight = function (key, color) {
    //DB.post("PianoKeyboard", ["unhighlight", key, color])
    let i = key - keyStart;
    let stk = _highlights[i];
    if (!stk) return; // Invalid key keys are ignored.
    if (color) { // Remove color from stack (could be anywhere)
      let s = stk.indexOf(color);
      if (-1 < s) { stk.splice(s, 1); }
    } else {
      stk.pop(); // If no color passed, pop last color
    }
    // Set the key's color to the top of the stack
    let l = stk.length;
    _keysDOM[i].style.backgroundColor = (0 < l) ? stk[l-1] : "";
  }

  /*
    Voice Message        octet 1         octet 2          octet 3
    -------------     ----------- ----------------- -----------------
    Note off                8x    Key number        Note off velocity
    Note on                 9x    Key number        Note on velocity (0 implies note off)
    Polyphonic Key Pressure Ax    Key number        Amount of pressure
    Control Change          Bx    Controller number Controller value
    Program Change          Cx    Program number    None
    Channel Pressure        Dx    Pressure value    None
    Pitch Bend              Ex    MSB               LSB
    The MIDI controller I use sends "note on" with 0 velocity as a "note off"
  */
  self.midi = function (msg) { // TODO This should not be here
    //DB.post("PianoKeyboard", msg.data);
    var d = msg.data;
    var cmd = d[0];
    var key = d[1];
    if ((0x90 + 0 <= cmd) && (cmd <= 0x90+15) // channel 0..15
        && (keyStart <= key) && (key < keyStart + keyCount)) {
      if (d[2] == 0) {
        keyRelease(key);
      } else {
        keyPress(key);
      }
    }
  }
} // PianoKeyboard


/******************************************************************************
  Database of Web Audio audio buffers.  It will download and convert raw audio
  files into ready to use AudioBuffers.

  USAGE::
    var noises = new AudioBuffers(filenames)

  METHODS::
    noises.length          Number of files specified.
    noises.fileName(i)     Get a filename.
    noises.audioBuffer(i)  Get an audio buffer or undefined.
******************************************************************************/
var AudioBuffers = function (ctx, filenames) {
  //// Private
  var _audioBuffers = [];

  function _Validate () {
    if (!DB.check(filenames && Array.isArray(filenames), "ERROR: AudioBuffersdb: Invalid filenames ary.")) {
      filenames = [];
    }
  }

  function _loadRawAudioFiles () {
    let count=0;
    filenames.forEach(function (fn, i) { // forEach passes in each ary element and the index.
      var client = new XMLHttpRequest();
      client.open('GET', fn);
      client.responseType = "arraybuffer";
      client.onreadystatechange = // Callback after remote file has been loaded
        function (e) {
          if (4 != client.readyState) { return; }
          var statusState = ((200 == client.status) || (0 == client.status) && (null != client.response)); // When loaded locally with --allow-file-access-from-files, status is 0 so must check client.response instead
          DB.check(statusState, "ERROR: AudioBuffers: " + client.status + " '" + (client.responseURL || fn) + "'");
          if (statusState) {
            //DB.post("AudioBuffers", `${i}/${filenames.length} ${fn}`);
            if (++count == filenames.length) {
              DB.post("AudioBuffers", `${count} files acquired`);
            }
            //DB.log("LOADED " + fn);
            var samples = new Int16Array(client.response); // Consider u8 ary as s16 ary.
            // Normalized each s16 sample to f32 between -1 and 1.
            var Noise =  new Float32Array(samples.length);
            for (var j=0; j<samples.length; ++j) {
              Noise[j] = samples[j]/32768;
            }
            // Create and set the audio buffer
            _audioBuffers[i] = ctx.createBuffer(1, samples.length, 44100);
            _audioBuffers[i].getChannelData(0).set(Noise);
          } // if
        } // function()
      client.send();
    }); // forEach function
  } // function

  //// Construct

  _Validate();
  _loadRawAudioFiles();

  //// Public

  this.length = filenames ? filenames.length : 0;
  this.fileName = function (i) { return filenames[i]; }
  this.fileNameCompact = function (i) {
    let fn = filenames[i].slice(0, -4); // Strip trailing ".raw"
    let firstDot = fn.indexOf(".");
    return (0 <= firstDot) ? fn.slice(firstDot+1) : fn;
  }
  this.audioBuffer = function (i) { return _audioBuffers[i]; }
} // AudioBuffers


/******************************************************************************
  Create a playable drumkit.  Expects a webaudio context and list of assets to
  acquire and cache into an AudioBuffer collection.

  USAGE::
    var dk = new Drumkit(ctx, color, keyStart, audioBuffers);

  CONSTRUCTOR PARAMETERS::
    ctx           An web audio context and audio buffers object.
    color         Highlight color
    keyStart      The first MIDI key/note the drumkit is mapped to
    audioBuffers  Playable sound samples

  METHODS::
    .length                    Number of reserved buffers
    .name(pad)                 String describing the pad.  Usually the drum sound.
    .color                     Color associated with this object
    .play(pad, vol, when)      Plays an audiobuffer sample specified by pad at
                               volume vol at time when or now if when==0.
    .connect(destination, idx) Set destination to destination
    .connected(idx)            Get destination to destination
******************************************************************************/
var Drumkit = function (ctx, color, keyStart, filenames) {
  //// Local
  var audioBuffers = new AudioBuffers(ctx, filenames)
  var bassReleaseTime = 0.8; // Release time in seconds for both the filter and gain.
  var destinations = Array(audioBuffers.length).fill(0); // Default destination of each sound to default
  //// Public
  this.length = audioBuffers.length;
  this.name = function (key) {
    return (undefined == key) ? "TR-808" : audioBuffers.fileNameCompact(key-keyStart);
   }
  this.color = color
  this.play = function (pad, vol, when) {
    let key = pad - keyStart;
    var audioBuffer = audioBuffers.audioBuffer(key);
    if (!audioBuffer) {
      DB.error(`Drumkit.play offset ${pad} expect ${keyStart}..${keyStart+this.length-1}`);
      return; // Do nothing if no audio buffer.
    }
    var now = (when || ctx.currentTime); // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
    var source = ctx.createBufferSource();
    source.buffer = audioBuffer;
    source.onended = function() { source.disconnect(); } // When the audio stops, remove it from the graph.
    var gain = ctx.createGain(); // Ramp

    if (key == 0) { // HACK: need to generalize a sound pipeline
      // Loop the bass noise for one second with a LPF and gain ramp.
      source.playbackRate.setValueAtTime(0.39, now);
      source.playbackRate.linearRampToValueAtTime(0.37, now+bassReleaseTime);
      source.loop = true;
      source.start(when);
      source.stop(now + bassReleaseTime);

      var lp = ctx.createBiquadFilter(); // LPF
      lp.type = "lowpass";
      lp.frequency.value = 120;
      lp.Q.value = 0.5;

      gain.gain.setValueAtTime(vol*Volume, now);
      gain.gain.linearRampToValueAtTime(0, now+bassReleaseTime);

      source.connect(lp);
      lp.connect(gain);
    } else {
      gain.gain.value = vol*Volume;
      source.connect(gain);
      source.start(when);
    }

    gain.connect(Destinations.input(destinations[key]));
  }
  this.connect = function (dest, idx) { destinations[idx] = dest; }
  this.connected = function (idx) { return destinations[idx]; }
} // Drumkit


/* MIDI key and frequency manager

   Key 21 (A-natural sub-contra-octave) is set to the base frequency

  Key Note Freq      Key Note Freq
    0 C-1  8.1758       69 A4   440/Middle A
    9 A-1 13.75         81 A5   880
   21 A0  27.5 88Piano  93 A6  1760
   33 A1  55           105 A7  3520
   45 A2 110           108 C8  4186.0090 88Piano
   57 A3 220           117 A8  7040
   60 C4 261.6256/MidC 127 G9 12543.8540
*/
var KeyFreq = function (freqa0) {
  // Generate able of base frequency multipliers
  let keymult = RangeMap(128, (k) => Pow(2, (k-21)/12.0));
  let self = (k) => keymult[k] * freqa0;// + Rnd()*0.5 - 0.25;
  self.setFreqA0 = (f) => freqa0=f;
  self.freq = () => freqa0;
  return self;
}(27.5);

DB.check( KeyFreq(21)==27.5, "KeyFreq frequency mismatch key 21 != 27.5Hz");
DB.check( KeyFreq(69)==440, "KeyFreq frequency mismatch key 69 != 440Hz");
DB.check( KeyFreq(105)==3520, "KeyFreq frequency mismatch key 105 != 3520Hz");
DB.check( KeyFreq(117)==7040, "KeyFreq frequency mismatch key 117 != 7040Hz");


/******************************************************************************
  Create a playable synthesizer.

  USAGE::
    var Synth = new Synthesizer(ctx, keyboard, color);

  CONSTRUCTOR PARAMETERS::
    ctx      A web audio context.
    keyboard An instantiated keyboard object
    color    DOM color

  METHODS::
    .element              This object's element
    .color                Color associated with this object
    .name(key)            Name associated with this key.  Default is the synth waveform name, each key.
    .adsr()               Get ADSR values in array
    .attSet(att)          Set new attack value 0.0-1.0.
    .susSet(sus)          Set new sustain value 0.0-1.0.
    .relSet(rel)          Set new release value 0.0-1.0.
    .play(key, vol, when) Plays a waveform at a freq determined by the Keyboard object at the
                          specified key, at webaudio context time 'when' or immediately if when==0.
    .wave()               Get current waveform index..
    .waveform()           Get current waveform string.
    .highlight(key)       Highlight the keyboard object's key with my color.  Used when playing a note.  TODO:  Is this smrt?
    .unhighlight()        Remove my highlight from the keyboard object.
    .connect(d)           Sets output destination
    .destination()        Return output destination

  EVENTS::
    The name element will toggle receiving MIDI messages via IBC
******************************************************************************/
var SynthGlobalCounter = 0;
var Synthesizers = [];
var Synthesizer = function (ctx, label, type, keyboard, color) {
  //// Local
  var self = this;
  var _ibcId = false;
  var _name = label || ("Synth" + ++SynthGlobalCounter);
  var _att = 0.01; // Attack tiem in seconds.
  var _sus = 0.01;
  var _rel = 0.50; // Release time in seconds for both the filter and gain.
  var _waveforms = ["sine", "square", "sawtooth", "triangle"];
  var _waveformIdx = type;
  var _filterIdx = 0;
  //var _destination = Destinations.input(_filterIdx); // This is dynamic now due to the CTX fuse.
  var _mouseMoved;

  var _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";
  //_element.style.width = "13ch";

  var _nameDOM = CreateAppendChild('div', _element); // [ Synth1 ]
  _nameDOM.style.background="";
  _nameDOM.innerText = _name;

  var _buttons = CreateAppendChild('div', _element); // [ Synth1 [ ] ]

  var _delSynth = CreateAppendChild('p', _buttons);  // [ Synth1 [-] ]
  _delSynth.className="actor mustshift";
  _delSynth.innerText = "-";

  // Remove synth only if not not used in any of the synth parts in any of the phrses and not one of the original 4 synths.
  /*
  _delSynth.onmousedown = function () {
    // Never remove the first four synths as they are used when creating a new phrase. TODO: remove this dependency
    var count=0;
    var synthIndex = Synthesizers.indexOf(self);
    if (synthIndex < 4) { return; }
    // Count synth usage in all parts of all phrases.
    Sheet0.phrases.map(function(ph){ ph.parts.map(function(pt){ if (self == pt.playable) ++count; }); });
    if (0 < count) { return; }
    Synthesizers.splice(synthIndex, 1);
    document.getElementById('synths').removeChild(_element); // Remove myself from DOM
  }
  */

  var _body = CreateAppendChild('div', _element);//  [ Synth1 [-] ]
  _body.className = "knobs";                     //  [            ]

  // Waveform button
  // [ [Synth1] [-] ]
  // [ [sine]       ]
  var _waveformDOM = CreateAppendChild('p', _body)
  _waveformDOM.className = "actor";
  _waveformDOM.innerText = _waveforms[_waveformIdx];
  _waveformDOM.onmousedown = function () {
    if (_waveforms.length == ++_waveformIdx) _waveformIdx=0;
    _waveformDOM.innerText = _waveforms[_waveformIdx];
  }

  CreateAppendChild('br', _body);

  // Attack button
  // [ [Synth1] [-] ]
  // [ [sine]       ]
  // [ [A]          ]
  var _attack = CreateAppendChild('p', _body);
  _attack.style.position = "relative"
  _attack.className = "volume"
  _attack.innerText = "[A]"
  var _attackVal = CreateAppendChild('p', _attack);
  _attack.onmousedown = function(event){ Slider(event, _att, function(v){ _att=v; _attackVal.innerText = v; }); }

  _attackVal.style.position = "absolute";
  _attackVal.innerText = "100";
  _attackVal.style.right = "-1em";
  _attackVal.style.top = "-1em";
  _attackVal.style.backgroundColor = "blue"

  // Sustain button
  // [ [Synth1] [-] ]
  // [ [sine]       ]
  // [ [A][S]       ]
  var _sustain = CreateAppendChild('p', _body);
  _sustain.style.position = "relative"
  _sustain.className = "volume"
  _sustain.innerText = "[S]"
  _sustain.onmousedown = function(event){ Slider(event, _sus, function(v){ _sus=v; }); }

  // Release button
  // [ [Synth1] [-] ]
  // [ [sine]       ]
  // [ [A][S][R]    ]
  var _release = CreateAppendChild('p', _body);
  _release.style.position = "relative"
  _release.className = "volume"
  _release.innerText = "[R]"
  _release.onmousedown = function(event){ Slider(event, _rel, function(v){ _rel=v; }); }

  CreateAppendChild('br', _body);

  // Output block
  // [ [Synth1] [-] ]
  // [ [sine]       ]
  // [ [A][S][R]    ]
  // [ [main]       ]
  var _output = CreateAppendChild('p', _body);
  _output.style.position = "relative"
  _output.className = "volume"
  _output.innerText = "[main]"
  _output.onmousedown = function (event) {
    if (++_filterIdx == Destinations.length) { _filterIdx = 0; }
    _output.innerText = Destinations.name(_filterIdx); // ["main", "delay","lowpass"][_filterIdx];
  }

  var _play = function (key, vol, when, sustain) {
    // Depending on how this is called (when is either 0 or a real time in the
    // future) now will be the current time or when
    var sus = _sus + (sustain ? sustain*TickerTimer.jiffy() : 0);
    var hold = when==0;
    var at = hold ? ctx.currentTime : when;
    var osc = ctx.createOscillator(); // Create and add to table if not already
    // Adding a random [0..1] value to the freq in an attempt to get rid of beating.
    // Ended up with a phaser effect when equal notes are played instead.
    osc.frequency.value = KeyFreq(key);
    osc.type = _waveforms[_waveformIdx];
    osc.onended = function(osc){ osc.disconnect(); }.bind(null, osc);
    osc.start(at);
    osc.stop(at + _att + sus + _rel);

    //DB.post("ASR", [_att, sus, _rel]);
    var gain = ctx.createGain();
    gain.gain.setValueAtTime(0, at);
    gain.gain.linearRampToValueAtTime(vol*0.5*Volume, at + _att);
    gain.gain.setValueAtTime         (vol*0.5*Volume, at + _att + sus);
    gain.gain.linearRampToValueAtTime(0,              at + _att + sus + _rel);

    osc.connect(gain);
    gain.connect(Destinations.input(_filterIdx));
  }

  var playing = [];
  var _playStart = function (key, vol) {
    var at = ctx.currentTime; // Start now
    var osc = ctx.createOscillator();
    osc.frequency.value = KeyFreq(key);
    osc.type = _waveforms[_waveformIdx];
    osc.start(at);
    osc.onended = function(osc){ osc.disconnect(); }.bind(null, osc);

    //DB.post("ASR", [_att, _sus, _rel]);
    var gain = ctx.createGain();
    gain.gain.setValueAtTime(0, at);
    gain.gain.linearRampToValueAtTime(vol*0.5*Volume, at + _att);

    osc.connect(gain);
    gain.connect(Destinations.input(_filterIdx));

    playing[key] = [osc, gain, at+_att]; // Keep track of this oscillator and envelope
  }

  var _playStop = function (key, vol) {
    if (playing[key] == undefined) { return; }

    var osc = playing[key][0]; // Recover osc and gain
    var gain = playing[key][1];
    var at = Max(playing[key][2], ctx.currentTime);
    playing[key] = undefined;

    gain.gain.setValueAtTime(vol*0.5*Volume, at);
    gain.gain.linearRampToValueAtTime(0, at + _rel);
    osc.stop(at + _rel);
  }

  var listenerIBC = function (m) {
    //DB.post("Synthesizer.listenerIBC",  m);
    if (m[0] != "keyboard1") { return; }
    if (m[2] == undefined) {
      _play(m[1], 0.5, 0);
    } if (m[2]) {
      _playStart(m[1], 0.5);
    } else {
      _playStop(m[1], 0.5);
    }
  }

  _nameDOM.onmousedown = function () {
    if (_nameDOM.style.background == "") {
      _nameDOM.style.background="#880";
      _ibcId = IBC.addListener(listenerIBC);
    } else {
      _nameDOM.style.background="";
      _ibcId = IBC.delListener(_ibcId);
    }
    IBC(["tickclick", 0, 0]); // This tells any active part to stop listening to keyboard events.
  }

  Synthesizers.push(this);

  //// Public
  this.element = _element;
  this.color = color
  this.name = function () { return _name; }
  this.adsr = function () { return [parseInt(_att*255), 0, parseInt(_sus*255), parseInt(_rel*255)]; }
  this.attSet = function (att) { _att = att/255.0; }
  this.susSet = function (sus) { _sus = sus/255.0; }
  this.relSet = function (rel) { _rel = rel/255.0; }
  this.play = _play;
  this.wave = function () { return _waveformIdx; }
  this.waveform = function () { return _waveforms[_waveformIdx]; }
  var _lastKey = -1;
  this.highlight = function (key) {
    keyboard.unhighlight(_lastKey, color); // Remove last high-light
    keyboard.highlight(key, color); // Set new high-light
    _lastKey = key
  };
  this.unhighlight = function () {
    keyboard.unhighlight(_lastKey, color); // Remove last high-light
  };
  /*
  this.connect = function(d) {
    //_destination = d;
    _filterIdx = Destinations.index(d);
    _output.innerText = Destinations.name(_filterIdx);
  };
  */
  this.destination = function () { return _filterIdx; };
} // Synthesizer



/******************************************************************************
  Create a single channel delay filter

  USAGE::
    var delay = new Delay(ctx);

  CONSTRUCTOR PARAMETERS::
    ctx      A web audio context.

  METHODS::
    .element    This object's element
    .name(key)  This filter's name
    .input()    Get the input port
    .export()   Return byte aray representing this instance.
******************************************************************************/
var Delay = function (ctx) {
  //// Local
  var self = this;
  var _name = "delay";
  var _del = 0.40; // Attack tiem in seconds.
  var _gai = 0.50; // Release time in seconds for both the filter and gain.

  var _destId = 0;
  var _destination;
  var _delay, _gain;

  var make = function () {
    _gain  = ctx.createGain();
    _delay = ctx.createDelay(1);
    _delay.connect(_gain);
    _delay.delayTime.value = _del;
    _gain.gain.value = _gai;
    _gain.connect(_delay);
    _destination = Destinations.input(_destId); // Initial destination is global destination
    _gain.connect(_destination);
  };

  make();

  var _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";
  //_element.style.width = "13ch";

  var _nameDOM = CreateAppendChild('div', _element); // [ Delay1 ]
  _nameDOM.style.background="";
  _nameDOM.innerText = _name;

  var _buttons = CreateAppendChild('div', _element); // [ Delay1 [ ] ]

  var _delSynth = CreateAppendChild('p', _buttons);  // [ Delay1 [-] ]
  _delSynth.className="actor mustshift";
  _delSynth.innerText = "-";

  var _body = CreateAppendChild('div', _element);//  [ Delay1 [-] ]
  _body.className = "knobs";                     //  [            ]

  // Waveform button
  // [ [Delay1] [-] ]
  // [ [delay]       ]
  var _waveformDOM = CreateAppendChild('p', _body)
  _waveformDOM.className = "actor";
  _waveformDOM.innerText = "delay"
  _waveformDOM.onmousedown = function () { }

  CreateAppendChild('br', _body);

  // Attack button
  // [ [Delay1] [-] ]
  // [ [sine]       ]
  // [ [A]          ]
  var _attack = CreateAppendChild('p', _body);
  _attack.style.position = "relative"
  _attack.className = "volume"
  _attack.innerText = "[D]"
  _attack.onmousedown = function(event){ Slider(event, _del, function(v){
    _del=v;
    _delay.delayTime.value = _del;
   });}


  // Release button
  // [ [Delay1] [-] ]
  // [ [sine]       ]
  // [ [A][F]       ]
  var _release = CreateAppendChild('p', _body);
  _release.style.position = "relative"
  _release.className = "volume"
  _release.innerText = "[G]"
  _release.onmousedown = function(event){ Slider(event, _gai, function(v){
    _gai=v;
    _gain.gain.value = _gai;
  }); }

  CreateAppendChild('br', _body);

  // Output block
  // [ [Delay1] [-] ]
  // [ [sine]       ]
  // [ [A][F]       ]
  // [ [main]       ]
  var _output = CreateAppendChild('p', _body);
  _output.style.position = "relative"
  _output.className = "volume"
  _output.innerText = "[main]"

  _output.onmousedown = function (event) {
    self.connect(Destinations.nextId(_destId));
  }

  //// Public
  this.element = _element;
  this.name = function () { return _name; }
  this.input = function () { return _gain; }
  this.getParams = function () { return [_del, _gai]; }
  this.setParams = function (ps) {
    _delay.delayTime.value = _del = ps[0];
    _gain.gain.value = _gai = ps[1];
  }
  // NEW
  this.dest = function () { return _destId; }
  // Update destination to passed in filter index otherwise update destination
  // if it changed in the filter stack.  Return true if a change occurred.
  this.connect = function (d) {
    if (d == null) {
      if (_destination != Destinations.input(_destId)) {
        make();
        return true;
      }
    } else {
      _gain.disconnect(_destination); // Is this needed?
      _destId = d;
      _destination = Destinations.input(_destId);
      _gain.connect(_destination);
      _output.innerText = Destinations.name(_destId);
    }
    return false;
  }
  this.export = function () {
    var bytes = [0]; // TYPE
    bytes.push(_name.length); // NAME LEN
    //DB("LK3 Filter " + d.name());
    _name.split('').map(b=>bytes.push(b.charCodeAt(0))); // NAME
    bytes.push(0); // Fake filter type.  for now the static delay and lowpass filters
    //DB("Params to write:" + ps);
    bytes.push(2);
    bytes.push(parseInt(_del*255.0));
    bytes.push(parseInt(_gai*255.0));
    return bytes;
  }
} // Delay


/******************************************************************************
  Create a single channel lowpass filter

  USAGE::
    var delay = new Lowpass(ctx);

  CONSTRUCTOR PARAMETERS::
    ctx      A web audio context.

  METHODS::
    .element    This object's element
    .name()     This filter's name
    .input()    Get the input port
******************************************************************************/
var Lowpass = function (ctx) {
  //// Local
  var self = this;
  var _name = "lowpass";
  var _f = .9; // Attack tiem in seconds.
  var _q = 0.0; // Release time in seconds for both the filter and gain.
  var _destId = 0;
  var _destination;
  var _lowpass;

  var make = function () {
    _lowpass = ctx.createBiquadFilter();
    _lowpass.frequency.value = 10000.0*(1.0-_f);
    _lowpass.Q.value = _q * 100.0;
    _destination = Destinations.input(_destId);
    _lowpass.connect(_destination); // New
  }
  make();

  var _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";
  //_element.style.width = "13ch";

  var _nameDOM = CreateAppendChild('div', _element); // [ lowpass ]
  _nameDOM.style.background="";
  _nameDOM.innerText = _name;

  var _buttons = CreateAppendChild('div', _element); // [ lowpass [ ] ]

  var _delSynth = CreateAppendChild('p', _buttons);  // [ lowpass [-] ]
  _delSynth.className="actor mustshift";
  _delSynth.innerText = "-";

  var _body = CreateAppendChild('div', _element);//  [ lowpass [-] ]
  _body.className = "knobs";                     //  [            ]

  // Waveform button
  // [ [lowpass] [-] ]
  // [ [lp]       ]
  var _waveformDOM = CreateAppendChild('p', _body)
  _waveformDOM.className = "actor";
  _waveformDOM.innerText = "lp"
  _waveformDOM.onmousedown = function () { }

  CreateAppendChild('br', _body);

  // Attack button
  // [ [lowpass] [-] ]
  // [ [lp]       ]
  // [ [F]          ]
  var _attack = CreateAppendChild('p', _body);
  _attack.style.position = "relative"
  _attack.className = "volume"
  _attack.innerText = "[F]"
  _attack.onmousedown = function(event){ Slider(event, _f, function(v){
    // The filter needs to be doing something when the parameters are updated otherwise the changes don't take effect.  I wonder if this is a bug in the audio engine's scheduler?
    var osc = ctx.createOscillator();
    osc.frequency.value = 0;
    osc.start(0);
    osc.stop(ctx.currentTime+.05);  // 1/20th of a sec should be long enough
    osc.onended = ()=>osc.disconnect();
    osc.connect(_lowpass);

    _f=v;
    _lowpass.frequency.value = 10000.0*(1.0-_f);
   });}

  // Release button
  // [ [lowpass] [-] ]
  // [ [lp]         ]
  // [ [F][Q]       ]
  var _release = CreateAppendChild('p', _body);
  _release.style.position = "relative"
  _release.className = "volume"
  _release.innerText = "[Q]"
  _release.onmousedown = function(event){ Slider(event, _q, function(v){
    _q=v;
    _lowpass.Q.value = _q * 100.0;
  }); }

  //// Public
  this.element = _element;
  this.name = function () { return _name; }
  this.input = function () { return _lowpass; }
  this.getParams = function () { return [_f, _q]; }
  this.setParams = function (ps) {
    _f = ps[0];
    _lowpass.frequency.value = 10000.0*(1.0-_f);
    _q = ps[1];
    _lowpass.Q.value = _q * 100.0;
  }
  // NEW
  this.dest = function () { return _destId; }
  // Update destination if it changed in the filter stack.  Return true if a change occurred.
  this.connect = function () {
    if (_destination != Destinations.input(_destId)) {
      _lowpass.disconnect(_destination); // Is this needed?
      make();
      return true;
    }
    return false;
  }
  this.export = function () {
    var bytes = [0]; // TYPE
    bytes.push(_name.length); // NAME LEN
    //DB("LK3 Filter " + d.name());
    _name.split('').map(b=>bytes.push(b.charCodeAt(0))); // NAME
    bytes.push(1); // Fake filter type.  for now the static delay and lowpass filters
    //DB("Params to write:" + ps);
    bytes.push(2);
    bytes.push(parseInt(_f*255.0));
    bytes.push(parseInt(_q*255.0));
    return bytes;
  }
} // Lowpass



// Keeps track of all possible sound destinations. The main context destination
// is always and more including delay and lowpass filters.
var Destinations = (function (ctx) {
  var self = [];

  var fuse = ctx.createGain();
  fuse.name = function () { return "mainFuse"; };
  fuse.input = function () { return fuse; };
  fuse.connect(ctx.destination);
  self.push(fuse);

  self.name = function (i) { return self[i].name(); }
  self.input = function (i) { return self[i].input(); }
  self.nextId = function (id) {
    let ret = (id+1) % self.length;
    DB(`nextId ${id} -> ${ret}  ${self.length}`);
    return ret;
  }
  self.next = function (d) { // Return destination after d in array.
    var i = 1 + self.findIndex( function (v,i) { return d== v.input(); } )
    return self[i % self.length];
  }
  self.index = function (d) { // Return index of the destination object
    var i = self.findIndex( function (v,i) { return d==v || d==v.input(); } )
    return (0 <= i) ? i : 0;
  }
  self.cut = function () {
    let oldFuse = fuse;
    // Silence current gainf use
    fuse.gain.setValueAtTime(0, ctx.currentTime);
    fuse.disconnect(ctx.destination);

    // Create new fuse gain and connect to CTX
    fuse = self[0] = ctx.createGain();
    fuse.name = function () { return "mainFuseNew"; };
    fuse.input = function () { return fuse; };
    fuse.connect(ctx.destination);

    // Sweep through for any filters that are connected to a filter
    // that doesn't match the filter in this array.  Update them.  Repeat.
    // For a filter like delay which can continue to produce samples, a new
    // one needs to be created and the exisintg one replaced.  This algorithm
    // will run again and update any filters depending on it until all filters point
    // to a filter in this array.

    // get reconnected to new fuse;
    var updateCount = 0;
    while (updateCount < self.length) { // Sanity check: Don't expect to update more filters than exists
      var updated = false;
      self.slice(1).forEach( (filter, i) => {
        if (filter.connect()) {
          //DB(`Reconnected ${i} ${filter.name()} to ${filter.dest()}`);
          ++updateCount;
          updated = true;
        }
      });
      if (!updated) { break; }
    }
    DB.check(updateCount < self.length, "Updated more filters than exists");

  }

  return self;
})(ctx);


/******************************************************************************

 Song serialization

******************************************************************************/
/*
 Encode song objects into Base-64 encoding of the following:

  -HEADER-
  "LK"      project
  03        version
  00        main volume
  00 00     beat duration

  -FILTERS...-
  00                Type = Filter
   06"filter"        label
   00                Filter type 00=delay 01=lowpass
   02                parameter count
    00...             parameters

  -SYNTH...-
  01                Type = Synthesizer
   09"synthname"     label
   00                Waveform [square sawtooth triangle sine]
   00                Volume
   00 00 00          Attack sustain release
   00                output destination/filter

  -PHRASE...-
  02                Type = Phrase
   0a"phrasename"    label
   04 04 04          measures, beatspermeasure, ticksperbeat
   10                part count
    -PART...-
    08"partname" 00   label
    00                volume
    00                destinatin/filter
    00...             4*4*4 bits representing on/off tick
    -NOTE OR NOTES-
      80              If 8th bit set then this&7f is the note to use for each tick.
      00...           Otherwise {number of ticks} bytes represent the notes for each tick.

  -PHRASE REFERENCE-
  03                Type PhraseReference
   0a"phrasename"    Label referring to actual phrase
*/
var saveSongLK3 = function () {

  var writtenPhrases = []; // Keep track of written phrases
  var bytes = [76,75,3]; // "LK" 03  LiveKa7 DAW Version 3 Header

  bytes.push(parseInt(Volume*255.0));
  // BMP saved as fixed point to two decimal places in little endian.  So convert the duration in seconds to microseconds then split.
  bytes.push(parseInt((6000/BeatDuration) & 255));
  bytes.push(parseInt((6000/BeatDuration) >> 8));

  Destinations.map(function(d,i) {
    if (0 < i) {
      d.export().map(b=>bytes.push(b));
    }
  });

  Synthesizers.map(function(s) {
    bytes.push(1); // TYPE
    // LENGTH "SYNTH LABEL"
    bytes.push(s.name().length);
    s.name().split('').map(function(b){bytes.push(b.charCodeAt(0))});
    bytes.push(s.wave()); // Waveform index
    bytes.push(255); // Volume not used for now
    var adsr = s.adsr();
    bytes.push(adsr[0]); // Attack
    bytes.push(adsr[2]); // Sustain
    bytes.push(adsr[3]); // Release
    bytes.push(s.destination());
  });

  for (var i=0; i<Sheet0.length(); ++i) {

    var ref = Sheet0.index(i);
    var phrase = ref.phrase;

    if (0 <= writtenPhrases.indexOf(phrase)) { // Write phrase if first reference to it
      // TYPE LENGTH "REFERENCED PHRASE LABEL"
      bytes.push(3);
      bytes.push(phrase.id.length);
      phrase.id.split('').map(function(b){bytes.push(b.charCodeAt(0))});
    } else {
      writtenPhrases.push(phrase); // Keep track of phrases written
      // TYPE LENGTH "PHRASE LABEL"
      bytes.push(2);
      bytes.push(phrase.id.length);
      phrase.id.split('').map(function(b){bytes.push(b.charCodeAt(0))});
      // MEASURES BEATS TICKS PARTCOUNT
      bytes.push(phrase.measureCount);
      bytes.push(phrase.beatCount/phrase.measureCount);
      bytes.push(phrase.tickCount/phrase.beatCount);
      bytes.push(phrase.partCount());

      phrase.parts.map(function(part, i){
        // LENGTH "PART LABEL" VOLUME
        bytes.push(part.elementName.innerText.length);
        part.elementName.innerText.split('').map(function(b){bytes.push(b.charCodeAt(0))});
        bytes.push(Floor(255.0*part.vol()));
        bytes.push(Destinations.index(DrumKit0.connected(part.key(0)))); // DESTINATION/FILTER

        // TICK BITS
        var bit = 1
        var byte=0;
        part.elementTicks.map(function (te, i) {
          if ("." != te.innerText) byte = byte | bit;
          if (128 == bit) {
            bytes.push(byte);
            bit = 1;
            byte = 0;
          } else {
            bit = bit<<1
          }
        });
        if (bit != 1) { bytes.push(byte); }

        // SINGLE BYTE (drumkit) or MULTIPLE NOTE BYTES
        if (part.playable instanceof Synthesizer) {
          for (var i=0; i<part.tickLength; ++i) {
            if (part.elementTick(i).innerText != ".") { bytes.push(part.key(i)); } // Only emit notes for on ticks.
          }
        } else {
          bytes.push(128 + part.key(0));
        }

      });
    }
  }
  mybytes = bytes;
  //console.log(bytes);
  window.history.replaceState("ohhai", "The LiveKa7 DAW", document.location.href.split('?')[0] + '?'  + Base64(bytes));
} // saveSongLK3
var mybytes;

var restoreSongLK3 = function (keyboard, drumKit, encodedSong) {
  var gs = new GetStringBase64(encodedSong);
  var next, b, label, d;
  if (!gs.assertString("LK") || !gs.assertBytes([3])) {
    DB("Not LK3")
    return false;
  }

  DB("Decoding LK3...")

  b = gs.nextByte();
  Volume = b / 255.0;

  b = gs.nextByte() + (gs.nextByte()<<8);
  BeatDuration = 6000.0/b;
  document.getElementById('speed').innerText = (60/BeatDuration).toFixed(0);

  while (null != (next = gs.nextByte()))
  if (0 == next) { // FILTER / DESTINATION
    label = gs.nextString(gs.nextByte()); // NAME LENGTH, NAME
    var t = gs.nextByte(); // TYPE
    b = gs.nextByte(); // PARAM COUNT
    //DB("params count = " + b);
    var ps=[]
    for (var i=0; i<b; ++i) { // PARAMS
      ps.push(gs.nextByte() / 255.0);
    }
    //DB("params = " + ps);
    if (t==0) {
      d = new Delay(ctx);
      //DB("LK3 delay create");
    } else if (t==1) {
      //DB("LK3 lowpass create");
      d = new Lowpass(ctx);
    } else { t==-1; }

    if (-1 != t) {
      Destinations.push(d);
      document.getElementById('filters').appendChild(d.element);
      d.setParams(ps);
    }
  } else if (1 == next) { // Synthesizer
    DB("LK3 Synth...");
    label = gs.nextString(gs.nextByte());
    var synth = new Synthesizer(ctx, label, gs.nextByte(), keyboard, "#84f");
    if (!Synthesizer0) Synthesizer0 = synth;
    else if (!Synthesizer1) Synthesizer1 = synth;
    else if (!Synthesizer2) Synthesizer2 = synth;
    else if (!Synthesizer3) Synthesizer3 = synth;
    document.getElementById('synths').appendChild(synth.element);
    gs.nextByte(); // Ignore volume for now
    synth.attSet(gs.nextByte());
    synth.susSet(gs.nextByte());
    synth.relSet(gs.nextByte());
    var i = gs.nextByte();
    synth.connect(Destinations[i].input());
  } else if (2 == next) { // Phrase
    label = gs.nextString(gs.nextByte());
    var measures = gs.nextByte();
    var beatsper = gs.nextByte();
    var ticksper = gs.nextByte();
    var partCount = gs.nextByte();
    var phrase = new Phrase(label, measures, beatsper, ticksper, keyboard);
    Sheet0.add(new PhraseReference(phrase));
    for (var i=0; i<partCount; ++i) {
      var part;
      label = gs.nextString(gs.nextByte());
      var vol = gs.nextByte();
      var dst = gs.nextByte(); // Destination (set below if drumkit track)

      var bools = gs.nextBools(phrase.tickCount);
      if (gs.peekByte() & 128) {
        var fixedNote = gs.nextByte() & 127;
        part = phrase.createPartFixed(drumKit, fixedNote)
        drumKit.connect(Destinations.input(dst), fixedNote); // DESTINATION/FILTER
        part.elementFilter.innerText = Destinations.name(dst);
      } else {
        Synthesizers.map(function(s) { // Lookup synth
          if (s.name() == label) {
            part = phrase.createPart(s);
          }
        });
        bools.map(function(n,i){if (n) { part.setKey(i, gs.nextByte());}});
      }
      part.setVol(vol/255.0); // Volume
      bools.map(function(n,i){part.elementTick(i).innerText = n?"X":".";});
    }
  } else if (3 == next) { // Phrase reference
    label = gs.nextString(gs.nextByte()); // Look-up existing phrase id and create a new ref using it.
    for (var i=0; i<Sheet0.length(); ++i) {
      var phrase = Sheet0.phrase(i)
      if (phrase.id == label) { // Found it
        var refPhrase = new PhraseReference(phrase);
        Sheet0.add(refPhrase);
        DB(label + " reference");
        break;
      }
    }
  }

  return true;
} // restoreSongLK3


/*
 Encode song objects into Base-64 encoding of the following:

  -HEADER-
  "LK" 02  version
  00        main volume
  00 00     beat duration

  -SYNTH...-
  00                Type Synthesizer
  0a"synthname"     label
  00                Waveform [square sawtooth triangle sine]
  00                Volume
  00 00             Attack release

  -PHRASE...-
  01                Type Phrase
  0a"phrasename"    label
  04 04 04          measures, beatspermeasure, ticksperbeat
  10                partcount
  -PART...-
  08"partname" 00   label, part volume
  00...             4*4*4 bits representing on/off tick
  -NOTE OR NOTES-
    80              If 8th bit set then this&7f is the note to use for each tick.
    00...           Otherwise {number of ticks} bytes represent the notes for each tick.

  -PHRASE REFERENCE-
  02                Type PhraseReference
  0a"phrasename"    Label referring to actual phrase
*/
var saveSongLK2 = function () {

  var writtenPhrases = []; // Keep track of written phrases
  var bytes = [76,75,2]; // "LK" 02  LiveKa7 DAW Version 2 Header

  bytes.push((Volume*255.0).toFixed(0));
  // BMP saved as fixed point to two decimal places in little endian.  So convert the duration in seconds to microseconds then split.
  bytes.push(parseInt((6000/BeatDuration) & 255));
  bytes.push(parseInt((6000/BeatDuration) >> 8));

  Synthesizers.map(function(s) {
   // TYPE LENGTH "SYNTH LABEL"
    bytes.push(0);
    bytes.push(s.name().length);
    s.name().split('').map(function(b){bytes.push(b.charCodeAt(0))});
    bytes.push(s.wave()); // Waveform index
    bytes.push(255); // Volume
    var adsr = s.adsr();
    bytes.push(adsr[0]); // Attack
    bytes.push(adsr[3]); // Release
  });

  for (var i=0; i<Sheet0.length(); ++i) {

    var ref = Sheet0.index(i);
    var phrase = ref.phrase;

    if (0 <= writtenPhrases.indexOf(phrase)) { // Write phrase if first reference to it
      // TYPE LENGTH "REFERENCED PHRASE LABEL"
      bytes.push(2);
      bytes.push(phrase.id.length);
      phrase.id.split('').map(function(b){bytes.push(b.charCodeAt(0))});
    } else {
      writtenPhrases.push(phrase); // Keep track of phrases written
      // TYPE LENGTH "PHRASE LABEL"
      bytes.push(1);
      bytes.push(phrase.id.length);
      phrase.id.split('').map(function(b){bytes.push(b.charCodeAt(0))});
      // MEASURES BEATS TICKS PARTCOUNT
      bytes.push(phrase.measureCount);
      bytes.push(phrase.beatCount/phrase.measureCount);
      bytes.push(phrase.tickCount/phrase.beatCount);
      bytes.push(phrase.partCount());

      phrase.parts.map(function(part, i){
        // LENGTH "PART LABEL" VOLUME
        bytes.push(part.elementName.innerText.length);
        part.elementName.innerText.split('').map(function(b){bytes.push(b.charCodeAt(0))});
        bytes.push(Floor(255.0*part.vol()));

        // TICK BITS
        var bit = 1
        var byte=0;
        part.elementTicks.map(function (te, i) {
          if ("." != te.innerText) byte = byte | bit;
          if (128 == bit) {
            bytes.push(byte);
            bit = 1;
            byte = 0;
          } else {
            bit = bit<<1
          }
        });
        if (bit != 1) { bytes.push(byte); }

        // SINGLE BYTE (drumkit) or MULTIPLE NOTE BYTES
        if (part.playable instanceof Synthesizer) {
          for (var i=0; i<part.tickLength; ++i) {
            if (part.elementTick(i).innerText != ".") { bytes.push(part.key(i)); } // Only emit notes for on ticks.
          }
        } else {
          bytes.push(128 + part.key(0));
        }

      });
    }
  }

  window.history.replaceState("ohhai", "The LiveKa7 DAW", document.location.href.split('?')[0] + '?'  + Base64(bytes));
}

var restoreSongLK2 = function (keyboard, drumKit, encodedSong) {
  var gs = new GetStringBase64(encodedSong);
  var next, b, label;
  var waveforms = ["sine", "square", "sawtooth", "triangle"];
  var color = ["#f00", "#0f0", "#00f"];
  if (!gs.assertString("LK") || !gs.assertBytes([2])) {
    DB("Not LK2")
    return false;
  }

  DB("Decoding LK2...")

  b = gs.nextByte();
  Volume = b / 255.0;

  b = gs.nextByte() + (gs.nextByte()<<8);
  BeatDuration = 6000.0/b;
  document.getElementById('speed').innerText = (60/BeatDuration).toFixed(0);

  while (null != (next = gs.nextByte()))
  if (0 == next) { // Synthesizer
    label = gs.nextString(gs.nextByte());
    var synth = new Synthesizer(ctx, label, gs.nextByte(), keyboard, "#84f");
    if (!Synthesizer0) Synthesizer0 = synth;
    else if (!Synthesizer1) Synthesizer1 = synth;
    else if (!Synthesizer2) Synthesizer2 = synth;
    else if (!Synthesizer3) Synthesizer3 = synth;
    document.getElementById('synths').appendChild(synth.element);
    gs.nextByte(); // Ignore volume for now
    synth.attSet(gs.nextByte());
    synth.relSet(gs.nextByte());
  } else if (1 == next) { // Phrase
    label = gs.nextString(gs.nextByte());
    var measures = gs.nextByte();
    var beatsper = gs.nextByte();
    var ticksper = gs.nextByte();
    var partCount = gs.nextByte();
    var phrase = new Phrase(label, measures, beatsper, ticksper, keyboard);
    Sheet0.add(new PhraseReference(phrase));
    for (var i=0; i<partCount; ++i) {
      var part;
      label = gs.nextString(gs.nextByte());
      var vol = gs.nextByte();
      var bools = gs.nextBools(phrase.tickCount);
      if (gs.peekByte() & 128) {
        part = phrase.createPartFixed(drumKit, gs.nextByte()&127);
      } else {
        Synthesizers.map(function(s) { // Lookup synth
          if (s.name() == label) {
            part = phrase.createPart(s);
          }
        });
        bools.map(function(n,i){if (n) { part.setKey(i, gs.nextByte());}});
      }
      part.setVol(vol/255.0); // Volume
      bools.map(function(n,i){part.elementTick(i).innerText = n?"X":".";});
    }
  } else if (2 == next) { // Phrase reference
    label = gs.nextString(gs.nextByte()); // Look-up existing phrase id and create a new ref using it.
    for (var i=0; i<Sheet0.length(); ++i) {
      var phrase = Sheet0.phrase(i)
      if (phrase.id == label) { // Found it
        var refPhrase = new PhraseReference(phrase);
        Sheet0.add(refPhrase);
        DB(label + " reference");
        break;
      }
    }
  }

  return true;
}

/*
 Encode song objects into Base-64 encoding of the following:

  -HEADER-
  "LK" 01  version
  00        main volume
  00 00     beat duration

  -PHRASE OR PHRASE_REFERENCE...-
    -PHRASE-
    00                Type Phrase
    0a"phrasename"    label
    04 04 04 10       measures, beatspermeasure, ticksperbeat, partcount
    -PART...-
    08"partname" 00   label, part volume
    00...             4*4*4 bits representing on/off tick
    -NOTE OR NOTES-
      80              If 8th bit set then this&7f is the note to use for each tick.
      00...           Otherwise {number of ticks} bytes represent the notes for each tick.

    -PHRASE REFERENCE-
    01                Type PhraseReference
    0a"phrasename"    Label referring to actual phrase

*/
var saveSongLK1 = function () {

  var writtenPhrases = []; // Keep track of written phrases
  var bytes = [76,75,1]; // "LK" 01  LiveKa7 DAW Version 1 Header

  bytes.push((Volume*255.0).toFixed(0));
  // BMP saved as fixed point to two decimal places in little endian.  So convert the duration in seconds to microseconds then split.
  bytes.push(parseInt((6000/BeatDuration) & 255));
  bytes.push(parseInt((6000/BeatDuration) >> 8));

  for (var i=0; i<Sheet0.length(); ++i) {

    var ref = Sheet0.index(i);
    var phrase = ref.phrase;

    if (0 <= writtenPhrases.indexOf(phrase)) { // Write phrase if first reference to it
      // TYPE LENGTH "REFERENCED PHRASE LABEL"
      bytes.push(1);
      bytes.push(phrase.id.length);
      phrase.id.split('').map(function(b){bytes.push(b.charCodeAt(0))});
    } else {
      writtenPhrases.push(phrase); // Keep track of phrases written
      // TYPE LENGTH "PHRASE LABEL"
      bytes.push(0);
      bytes.push(phrase.id.length);
      phrase.id.split('').map(function(b){bytes.push(b.charCodeAt(0))});
      // MEASURES BEATS TICKS PARTCOUNT
      bytes.push(phrase.measureCount);
      bytes.push(phrase.beatCount/phrase.measureCount);
      bytes.push(phrase.tickCount/phrase.beatCount);
      bytes.push(phrase.partCount());

      phrase.parts.map(function(part, i){
        // LENGTH "PART LABEL" VOLUME
        bytes.push(part.elementName.innerText.length);
        part.elementName.innerText.split('').map(function(b){bytes.push(b.charCodeAt(0))});
        bytes.push(Floor(255.0*part.vol()));

        // TICK BITS
        var bit = 1
        var byte=0;
        part.elementTicks.map(function (te, i) {
          if ("." != te.innerText) byte = byte | bit;
          if (128 == bit) {
            bytes.push(byte);
            bit = 1;
            byte = 0;
          } else {
            bit = bit<<1
          }
        });
        if (bit != 1) { bytes.push(byte); }

        // SINGLE BYTE (drumkit) or MULTIPLE NOTE BYTES
        if (part.playable instanceof Synthesizer) {
          for (var i=0; i<part.tickLength; ++i) {
            if (part.elementTick(i).innerText != ".") { bytes.push(part.key(i)); } // Only emit notes for on ticks.
          }
        } else {
          bytes.push(128 + part.key(0));
        }

      });
    }
  }

  window.history.replaceState("ohhai", "The LiveKa7 DAW", document.location.href.split('?')[0] + '?'  + Base64(bytes));
}

var restoreSongLK1 = function (keyboard, drumKit, encodedSong) {
  var gs = new GetStringBase64(encodedSong);
  var b, label;
  var waveforms = ["sine", "square", "sawtooth", "triangle"];
  //var color = ["#f00", "#0f0", "#00f"];
  if (!gs.assertString("LK") || !gs.assertBytes([1])) {
    DB("Not LK1")
    return false;
  }

  b = gs.nextByte();
  DB("LK1 volume " + b);
  Volume = b / 255.0;

  b = gs.nextByte() + (gs.nextByte()<<8);
  DB("LK1 beatduration " + b);
  BeatDuration = 6000.0/b;
  document.getElementById('speed').innerText = (60/BeatDuration).toFixed(0);

  while (null != gs.peekByte()) if (0 == gs.nextByte()) { // Phrase
    label = gs.nextString(gs.nextByte());
    var measures = gs.nextByte();
    var beatsper = gs.nextByte();
    var ticksper = gs.nextByte();
    var partCount = gs.nextByte();
    var phrase = new Phrase(label, measures, beatsper, ticksper, keyboard);
    Sheet0.add(new PhraseReference(phrase));
    for (var i=0; i<partCount; ++i) {
      var part;
      label = gs.nextString(gs.nextByte());
DB(label);
      var vol = gs.nextByte();
      var bools = gs.nextBools(phrase.tickCount);
      if (gs.peekByte() & 128) {
        part = phrase.createPartFixed(drumKit, gs.nextByte()&127);
      } else {
        //if (0 == i) {
        //  part = phrase.createPart(Synthesizer0);
        //} else {
        //  part = phrase.createPart(new Synthesizer(ctx, false, waveforms.indexOf(label), keyboard, color[i%3]));
        //}
        if (waveforms.indexOf(label) == -1)
          part = phrase.createPart(Synthesizer1);
        else
          part = phrase.createPart([Synthesizer0, Synthesizer1, Synthesizer2, Synthesizer3][waveforms.indexOf(label)]);
        bools.map(function(n,i){if (n) { part.setKey(i, gs.nextByte());}});
      }
      part.setVol(vol/255.0); // Volume
      bools.map(function(n,i){part.elementTick(i).innerText = n?"X":".";});
    }
  } else { // Phrase reference
    label = gs.nextString(gs.nextByte()); // Look-up existing phrase id and create a new ref using it.
    for (var i=0; i<Sheet0.length(); ++i) {
      var phrase = Sheet0.phrase(i)
      if (phrase.id == label) { // Found it
        var refPhrase = new PhraseReference(phrase);
        Sheet0.add(refPhrase);
        DB(label + " reference");
        break;
      }
    }
  }

  return true;
}


/* Old encoding:
-- 427 character base-64 encoding
0G410K44GGGH4H4H4H4H4KLHH1H5H5HP00000000000000000000000000000000CpCpCpCpCpC000000000000000000000pCpCpCpCpCp1KL0KGH34LG000000000000000000000100400G014H4H4H4H4H4H00000000000400002m4B0GG2408E0mC310G411852mK41X064mS71m8820W92H892WeE2WmB2mi030mC3GqG3GuE30uF3myF700001S10G4S0W827WC30ny410GN1GK57mO61YC71mSX20W85ma92I4A2WeZ2miB7mmC31SD3GqV3WuE7WyF3pG0Bm0h0IW18m8U0Xm35mCX12O41GKe1IC69WOX1mS79WWX22e9A0aZ2YyAAWig2oeCA0mq3JSDEmusDZSsDWy
-- Of 320 bytes
010101014104410411111111111111114551441445445459000000000000000000000000000000000000000000000000333333333333333300000000000000000000000000000000ccccccccccccccccc15150144110c45500000000000000000000000000000000010001000100011111111111111111110000000000000000040000000b010b01040210020e0303030404040412050b05040610061307070702080808090912090a0a0e0a0c0b0b0b000c0c0c0d0d100d0e0e0c0e0f0f0f0f1c000000170101011c0202021e0303031f040404170505051f060606230707072108080817090909210a0a0a230b0b0b1f0c0c0c170d0d0d1f0e0e0e1e0f0f0f34002f002b01280123021e021c03170321042604050528052306260621070707260821082a092809230a2f0a2a0b2a0b2a0c280c340d370d3b0e36363736360f
-- 16 parts of 64 binary ticks --
0101010141044104 1111111111111111 4551441445445459 0000000000000000
0000000000000000 0000000000000000 3333333333333333 0000000000000000
0000000000000000 cccccccccccccccc c15150144110c455 0000000000000000
0000000000000000 0100010001000111 1111111111111111 0000000000000000
-- First three parts are synths which require a note for every tick encoded as bytes ----
040000000b010b01040210020e0303030404040412050b05040610061307070702080808090912090a0a0e0a0c0b0b0b000c0c0c0d0d100d0e0e0c0e0f0f0f0f
1c000000170101011c0202021e0303031f040404170505051f060606230707072108080817090909210a0a0a230b0b0b1f0c0c0c170d0d0d1f0e0e0e1e0f0f0f
34002f002b01280123021e021c03170321042604050528052306260621070707260821082a092809230a2f0a2a0b2a0b2a0c280c340d370d3b0e36363736360f

Base64('base64digits...').forEach(function(x){s+=("0"+x.toString(16)).slice(-2);}) // Append decoded hex digits to s

*/

/* Only saves a single phrase with three synth tracks and 13 beat tracks.
*/
var saveSongLK0 = function () {
  var pattern=[];
  var synthParts=[];

  // Over each part...
  Sheet0.phrase(0).parts.map(function (part) {
    var byte=0;
    if (part.playable instanceof Synthesizer) synthParts.push(part); // Keep track of synth parts.
    part.elementTicks.map(function (te, i) {
      byte = (byte >> 1) + ("." == te.innerText ? 0 : 128);
      if (7==i%8) {
        pattern.push(byte);
        byte=0;
      }
    });
  });

  // The synth part's tick keys
  synthParts.map(function (part) {
    for (var i=0; i<part.tickLength; ++i) {
      pattern.push(part.key(i))
    }
  });

  window.history.replaceState("ohhai", "Digital Audio Workstation", document.location.href.split('?')[0] + '?'  + Base64(pattern));
}

/* Only restores a single phrase with three synth tracks and 13 beat tracks.
*/
var restoreSongLK0 = function (keyboard, drumKit) {
  var gs = new GetStringBase64();

  if (320 != gs.length()) {
    DB("Not LK0");
    return false;
  }

  DB("LK0 Creating default phrase...");

  // Create a phrase with 4 measures, 4 beats per measure, and 4 ticks per beat.
  var phrase = new Phrase("Phrase", 4, 4, 4, keyboard);
  var phraseRef = new PhraseReference(phrase);
  Sheet0.add(phraseRef);

  // Add synth parts to the phrase
  phrase.createPart(Synthesizer1);
  phrase.createPart(Synthesizer2);
  phrase.createPart(Synthesizer3);

  for (var n=0; n<drumKit.length; ++n) { phrase.createPartFixed(drumKit, n) }

  DB("Scanning phrase via GET string...");

  var synthParts=[];
  var bits = gs.nextBools(1024);

  phrase.parts.map(function (part) {
    if (part.playable instanceof Synthesizer) synthParts.push(part); // Keep part of synth parts.
    part.elementTicks.map(function (te, i) {
      te.innerText = bits.shift() ? "X" : "."; // Bits encoded big endian.
    });
  });

  synthParts.map(function (part) {
    for (var i=0; i<part.tickLength; ++i) {
      part.setKey(i, gs.nextByte());
    }
  });
}




/******************************************************************************
  TickerTimer - Manage ticks and time

  The default behavior is to return [tick, time] representing the
  current tick to process and at what future time.

  Ticks represent periodic time units that need to be sequentially
  considered when creating and emitting audio on time.  This will
  make sure enough ticks have been processed so that there is at most
  1 second of audio processed.

  Start rendering just a bit after currentTime?  No, doesn't seem to be
  a problem and a delay before starting is annoying anyways.

     ...---------------------------...
           ^  ^=========^=========^======== <samples written
 currentTime  tick0time tick1time lastTime
              ^render0

  tickCued   =  0;  -1     -1     -1    -1      -1
  let tick   = -1;  0      1      2      3      3
  let time   = -1;  100.25 100.50 100.75 101.00 101.00   (time+jiffy) - CurrentTime should be a second

  renderedCued = 0
  tickRender = -1;  -1     -1     -1     -1     0

          calls                     ctx.currentTime
  tickNext() => [0, 100.25]             100.00
  tickNext() => [1, 100.50]             100.10
  tickNext() => [2, 100.75]             100.15
  tickNext() => [3, 101.00]             100.19
  tickNext() => false                   100.20  when currentTime is over
  tickRender() => 0                     100.21
  tickRender() => false                 100.30
  tickRender() => 1                     100.32
  tickNext() => [4, 101.25]             100.35

  Idea:  base tick on CurrentTime - Time of last "first" tick.  The math will be just a sub and div

******************************************************************************/
var TickerTimer = (function (ctx) {
  // Settings
  let bpm   = 60;
  let jiffy = .25; // Tick length in seconds (speed of music)
  let lead  = 1.0; // Audio pre-buffer length in seconds
  let length = 8; // Total number of ticks
  let start  = 0; // Start tick
  let end    = length-1; // End tick
  // Dynamic state
  let paused = true;
  let tickCue = 0;
  let tick    = -1;
  let time    = -1;
  let renderCue = 0;
  let render    = -1;
  var now = -1;

  /* Last emitted time +jiffy - CurrentTime / jiffy -> number of ticks back from tick the real time tick count is */
  var _pause = function (e) {
    if (paused = !paused) { // Did we switch into pause mode?
      tickCue = renderCue = self.currentTick(); // Force next tick and render to current realtime.
      Destinations.cut();
    }
    blinkify(e, paused&&"#f00");
    //DB.post('TickerTimer._pause', paused);
  }


  // Debugging message
  let self = function (f, r) {
    //DB.post("next Tick", `${paused} ${tickCue} ${tick} ${time}   ${now}   ${renderCue} ${render} => ${r} ${f?"RRRRRRR":"ttt"} `);
    return r;
  };

  // Request the next tick and time to render it.  False implies not ready.
  self.nextTick = function () {
    now = ctx.currentTime; // Debugging: update early for more debugging info
    if (paused) { // Paused: Skip rendering
      return false;
    } else if (tickCue != -1) { // Un-paused:  Send this cued tick and set time to now
      tick = tickCue;
      tickCue = -1;
      time = now;
    } else if (now + lead <= time) { // Buffer full, skip rendering
      return false;
    } else { // Normal running, next tick and inc time
      ++tick;
      if (end < tick) { tick = start; } // Keep tick within selected tick range
      time += jiffy;
      if (time < now) { time = now; } // Reset time if we fell behind now
    }
    // Return processing details/instructions: "Generate sound at 'time' from notes at 'tick'"
    ElementById("info").innerText = Trunc2(time-now);
    return [tick, time];
  };

  // Request the next rendering tick.  False implies tick hasn't moved.
  self.nextRender = function () {
    now = ctx.currentTime; // Debugging: update 'now' for extra info
    let ret = false;  // Default return value
    if (renderCue != -1) { // Cued (running or paused)...
      if (renderCue != render) { // Update with cue.
        render = renderCue;
        ret = render;
      } // Skip, already on cue.
      renderCue = -1;
    } else if (!paused) { // Normal running...
      let currentTick = self.currentTick();
      if (currentTick != render) { // Update with new tick.
        ret = render = currentTick;
      } // Skip, on same tick
    } // Paused,..always skip.
    return ret;
  }

  self.tick = self;
  self.pause     = function (e)  { _pause(e); }
  self.setBpm    = function (b) { bpm=b; jiffy = 15/bpm; };
  self.setStart  = function (i) { if (i<=end) { start = i; length=end-start+1; if (paused) { tickCue = renderCue = start; } } return self; };
  self.setEnd    = function (i) { if (start<=i) { end = i; length=end-start+1; } return self; };
  self.rewind = function (e, newTick) { // Reset state so next tick is 0 and next time will be nowish.
    if (paused) { _pause(e); }
    // Rewind to specified tick or the usual start tick
    tickCue = renderCue = (newTick == undefined) ? start : newTick;
    return self;
  };
  self.now = () => ctx.currentTime;
  // Derive the actual current tick (which will most likely have already been processed)
  // When deriving the live beat for DOM highlighting, must do so within the current active beat range
  // So the distance between (BeatTime - currentTime) / beatDuration is how beats to subtract from Beat
  // to get the live beat.  But if this is less than BeatInitial, mod the BeatRange to compensate..
  self.currentTick = function (adj) {
    now = ctx.currentTime + (adj||0);
    //               |4.00 now4.12 2|4.25    3|4.5    4|4.75  5|5.00=TIME 6|
    //   time - now  = .88 % .25 = 3.52 ceil=4  tick- = 2
    //                           tick- = 2.48
    let ticksAhead = Floor(tick - (time - now) / jiffy);
    return Mod(ticksAhead-start, length)+start;
  }
  self.isPaused = function () { return paused; }
  self.lastTime = function () { return time + jiffy; }
  self.jiffy = function () { return jiffy; }
  self.bpm = function () { return bpm; }
  self.getRange = function () { return [start, end]; }
  return self;
})(ctx); // TickerTimer


/******************************************************************************
  Sheet - Manage parts on a dynamic phrase/sheet.

******************************************************************************/
var Sheet = function (id, tickCount, tickertimer) {
  var element = ElementById(id);
  var knobs = element.previousElementSibling;
  let ticks = []; // The row of ticks [ [header [parts]] ... ]
  let parts = []; // List of all Part objects created.  Their elements will be scattered about the tick.
  let tickLastRender = 0;
  let markedTick = null;

  var self = function () { };
  self.element = function () { return element; }
  self.tick = function (i) { return ticks[i]; }
  self.partAdd = function (p) { parts.push(p); return self; }

  // Get list of Parts that lay on this tick.
  self.partsOnTick = function (tick) {
    return parts.filter( p => p.isOnTick(tick) );
  }
  self.partsResetZ = function () {
    parts.forEach( p => p.element().style.zIndex="" );
  }
  self.refreshHeader = function () {
    // Reset Phrase tick header highlights.
    let [start, end] = tickertimer.getRange();
    for (var i=0; i < tickCount; i++) {
      ticks[i].firstChild.style.backgroundColor = (i<start || end<i) ? "#444" : "";
    }
  }
  self.getRange = function () { return tickertimer.getRange(); }
  self.setStart = function (i) { tickertimer.setStart(i); self.refreshHeader(); return self; }
  self.setEnd = function (i) { tickertimer.setEnd(i); self.refreshHeader(); return self; }
  self.play = function (tick, time) {
    self.partsOnTick(tick).forEach( (part) => {
      part.play(tick, time);
    });
  }
  self.tickerTimer = () => tickertimer;
  self.pause = function (e) {
    tickertimer.pause(e);
  }

  self.rewind = function (e) { tickertimer.rewind(e); }
  self.jump   = function (e) { tickertimer.rewind(e, markedTick); }

  self.isPaused = ()=>tickertimer.isPaused();

  let lastVisible = 0; // DEBUGGING mark the rightmost visible tick header in the scrollable viewing phrase element

  self.render = function (tick) {

    let children = element.children;

    // Scroll the grid so current tick is visible

    // Zooming in Chrome alters these so they must be dynamically queried
    var tickWidth = children[0].getBoundingClientRect().width;
    var phraseWidth = element.getBoundingClientRect().width;

    // Adding the phrase window's scroll amount to the phrase window's width
    // gives the location of the last visible tick, dividing by tickWidth
    // for the tick index.
    var visibleTick = Round((phraseWidth + element.scrollLeft) / tickWidth)-2;

    if (visibleTick < children.length) { // DEBUGGING see comment above
      children[lastVisible].firstChild.style.textDecoration="";
      children[visibleTick].firstChild.style.textDecoration="underline";
      lastVisible = visibleTick;
    }

    var pos = Floor(phraseWidth / tickWidth / 2);

    // If the current active phrase range is in the viewport, don't scroll it.
    if (visibleTick < self.getRange()[1]) {
      element.scrollLeft =
        children[tick].offsetLeft
        - (pos-1) * tickWidth;
    }

    // Highlight the full vertical tick

    children[tickLastRender].className="";
    children[tick].className="phrasehighlight";

    tickLastRender = tick;
  }

  // Create the tick columns and the top row tick marks. Part div's will be inserted/removed later.
  // [ [[0]] [[1]] ... ]
  for (var row=0; row < tickCount; row++) {
    let tick = CreateAppendChild('div', element); // Create the tick column
    ticks.push(tick); // Keep track of the tick columns
    let header = CreateAppendChild('p', tick, (Floor(row/8) % 10)); // Add the tick header

    // Hovering will play all ticks in each part.
    header.onmouseover = function (tick) {
      if (brushToPlay()) { self.play(tick, 0); }
    }.bind(null, row);

    header.onmousedown = function (idx, e) { // Handle updating sheet's start/end playback ticks and repeat marker
      if (e.button==2) { self.setEnd(idx); }
      else if (e.button==1 || (e.button==0 && e.metaKey)) {
        // Handle marked tick in phrase sheet's header
        if (markedTick != null) { ticks[markedTick].firstChild.style.color = ""; }
        if (markedTick == idx) {
          markedTick = null;
        } else {
          ticks[markedTick=idx].firstChild.style.color = "black";
        }
      } else {
        self.setStart(idx);
      }
    }.bind(null, row);
  }

  // Add a brushToPlay toggle button
  let brushToPlay = AppendNewToggleActor(knobs, false, "actor",
    ()=>(ticks.forEach(t=>t.firstChild.style.color=null), ")("),
    ()=>(ticks.forEach(t=>t.firstChild.style.color="inherit"), "()"));
  brushToPlay.element().title="BRUSH PLAY";

  // Reset the TickerTimer state object
  tickertimer
    .setStart(0)
    .setEnd(tickCount-1)

  // Create new parts when this button is activated
  var _addphrase = document.getElementById('addpart');
  _addphrase.children[1].onmouseup = function () { _addphrase.children[0].style.display=""; }
  _addphrase.children[0].onmouseleave = function () { _addphrase.children[0].style.display="none"; }
  document.getElementById('createphrase').onmousedown = function () {
    var measures = document.getElementById('addmeasures').value;
    var beats    = document.getElementById('addbeats').value;
    var ticks    = document.getElementById('addticks').value;
    Part(self, 2, 2*20, 0, 60, measures*beats*ticks, Synthesizers[0]);
    _addphrase.children[0].style.display="none";
  };

  return self;
}; // Sheet


/******************************************************************************
  RefPart - References a Part.  Behaves the same as a part to a sheet.
******************************************************************************/
var RefPart = function (partObj, tickIdx, height) {
  let sheet = partObj.sheet();
  let sheetElement = sheet.element();
  let timer = sheet.tickerTimer();

  // Creat part window
  let ref = CreateAppendChild('div', sheetElement.children[tickIdx]);
  ref.className = "window";
  ref.style.top = Max(height, sheetElement.firstChild.firstChild.scrollHeight)+"px";

  // Header - left most cells of row
  let title = CreateAppendChild('div', ref, `*${partObj.titleName()}`);
  title.className = "actor";
  title.title = "MOVE,MINIMIZE";
  title.contentEditable = true;

  let knobs = CreateAppendChild('div', ref);
  knobs.className = "knobs";

  let body = CreateAppendChild('div', ref);
  body.className = "part";

  // Grid tick header
  let headerTicks = CreateAppendChild('div', body);

  for (let t=0; t<partObj.tickCount(); t++) {
    let header =
      0 == t%8 ? CreateAppendChild('p', headerTicks, "@") :
      0 == t%4 ? CreateAppendChild('p', headerTicks, "+") :
      0 == t%2 ? CreateAppendChild('p', headerTicks, "-") :
                 CreateAppendChild('p', headerTicks, "-");
    header.onmouseover = function (tick) {
      if (brushToPlay()) { self.playTick(tick, 0); }
    }.bind(null, t);
  }

  // Behavior

  // brushToPlay knob
  let brushToPlay = AppendNewToggleActor(knobs, false, "actor",
    () => (headerTicks.style.color=null, ")("),
    () => (headerTicks.style.color="inherit", "()"));
  brushToPlay.element().title="BRUSH PLAY";

  title.onmousedown = function (e) {
    if (e.button != 0) { return; }
    MouseIsDown = true; // Set global state

    self.focus();

    // Drag/Move part within sheet

    let tickHeight = sheetElement.firstChild.firstChild.scrollHeight+1;
    let tickWidth  = sheetElement.lastChild.offsetLeft / (sheetElement.childElementCount-1); // Tick width take average width of all ticks
    let leftMargin = sheetElement.offsetLeft-sheetElement.scrollLeft; // Account for element's margin and scrolled offset
    sheetElement.onmousemove = function (offset, e) {
       if (!MouseIsDown) { sheetElement.onmousemove = null; return; } // Maybe stop handling this event
       // Adjust ref's vertical position
       ref.style.top = Max(offset + e.y, tickHeight) + "px";
       // Adjust ref's horizontal position (Phrase's tick)
       let newTick = Floor((e.x-leftMargin+1) / tickWidth);
       if (newTick != tickIdx) {
         sheetElement.children[newTick].appendChild(ref);
         tickIdx = newTick;
       }
    }.bind(null, ref.offsetTop-e.y);
  };

  // Title editing.
  title.onkeydown = function (v) {
    event.stopPropagation(); // Don't bubble the event elsewhere (global controls),
    if (v.code == "Enter") {
      v.preventDefault(); // Prevent form element from adding a newline
    }
  }

  let self = ()=>{};

  self.element = () => ref;
  self.isOnTick = function (t) {
    return tickIdx <= t && t < tickIdx + partObj.tickCount();
  }
  self.play = (gtick, time) => {
    self.playTick(gtick - tickIdx, time);
  }
  self.playTick = (tick, time) => {
    //DB.post("RefPart", [tick, time]);
    partObj.playTick(tick, time);
  }
  self.focus = () => { // Raise/focus this element in sheet and reset others
    sheet.partsResetZ();
    ref.style.zIndex = 1;
  }

  sheet.partAdd(self);
  self.focus();

  return self;
}; // RefPart


/******************************************************************************
  Part - Model a part which for now is a drawable synth/piano or drumkit grid.
******************************************************************************/
var Part = function (sheetObj, tickIdx, height, keyBeg, keyCount, TickCount, playable) {
  // Consider parent
  let sheet = sheetObj.element(); // Parent object's element
  let timer = sheetObj.tickerTimer();

  // Creat part window
  let part = CreateAppendChild('div', sheet.children[tickIdx]); // The Part element
  part.className = "window";
  part.style.top = Max(height, sheet.firstChild.firstChild.scrollHeight)+"px";

  // Header - left most cells of row
  let title = CreateAppendChild('div', part, "Part");
  title.className = "actor";
  title.title="MOVE,MINIMIZE";
  title.contentEditable = true;

  let knobs = CreateAppendChild('div', part);
  knobs.className = "knobs";

  let body = CreateAppendChild('div', part);
  body.className = "part";

  // Grid tick header
  let headerTicks = CreateAppendChild('div', body);

  for (let t=0; t<TickCount; t++) {
    let header =
      0 == t%8 ? CreateAppendChild('p', headerTicks, "@") :
      0 == t%4 ? CreateAppendChild('p', headerTicks, "+") :
      0 == t%2 ? CreateAppendChild('p', headerTicks, "-") :
                 CreateAppendChild('p', headerTicks, "-");
    header.onmouseover = function (tick) {
      if (brushToPlay()) { self.playTick(tick, 0); }
    }.bind(null, t);
  }

  // Container of rows of label and ticks
  let grid = CreateAppendChild('div', body);
  //grid.className="grid";

  RangeForEach(keyCount, (ii) => {
    let key = keyBeg + ii;
    if (playable instanceof Synthesizer) {

      let note = key%12;
      let octave = Floor((key-12)/12); // MIDI octaves start at C-1 up to G9
      let noteLabel = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'][note];
      let nat = 1 == noteLabel.length; // Natural notes are 1 char long
      let label = nat ? noteLabel + (0==note?octave:"") : NBSP;

      let row = CreateInsertChild("div", grid); // A row: Container of label and ticks
      row.className = noteLabel.charAt(0) + (nat ? " nat" : " shp");
      row.title = `${Trunc2(KeyFreq(key))}Hz  ${key}  ${noteLabel}${octave}`;

      let header = CreateAppendChild("p", row, label); // White keys show note

      header.onmousedown = function () {
        // Record a note if a key label is pressed.
        if (!sheetObj.isPaused() && listenerID ) {
          let tick = timer.currentTick()-tickIdx;
          row.children[1].children[tick].innerText = "*";
        }
        // Play the key's sound if recording or live audio is enabled
        if (brushToPlay() || listenerID) {
          MouseIsDown = true;
          IBC(["keyboard1", key, true]); // Notify listeners a key was pressed  ["piano1", 12, startPlaying]
        }
      };

      header.onmouseover = function () { if (MouseIsDown) { IBC(["keyboard1", key, true]); } };
      header.onmouseup = function () {
        if (brushToPlay() || listenerID) {
          IBC(["keyboard1", key, false]); // Notify listeners a key was released  ["piano1", 12, startPlaying]
        }
      };
      header.onmouseleave = function () { if (MouseIsDown) {IBC(["keyboard1", key, false]); } }

      let notes = CreateAppendChild("div", row); // Row of ticks

      for (let x=0; x<TickCount; x++) {
        let tick = CreateAppendChild('p', notes, NBSP); // A tick
        // Action Clicking
        tick.onmousedown = function (e) {
          let txt = e.target.innerText;
          DragOverTickState = txt == NBSP ? 1 : 2;
          MouseIsDown = true; // Set global state
          e.target.innerText = txt == NBSP ? "*" : NBSP;
        }
        // Action Hovering/dragging
        tick.onmouseover = function (e) {
          if (MouseIsDown) {
            e.target.innerText = (DragOverTickState == 1 ? "-" : NBSP) // Continue painting
          } else if (e.target.innerText == "*") {
            playable.play(key, .5, 0); // Play it
          }
        };
      }

    } else {
      let row = CreateInsertChild("div", grid); // A row: Container of label and ticks
      row.className = "drumkit";
      let header = CreateAppendChild("p", row, playable.name(key));

      header.onmousedown = function () {
        if (!sheetObj.isPaused(event) && listenerID ) {
          let tick = timer.currentTick()-tickIdx;
          row.children[1].children[tick].innerText = "*";
        }
        // Play the sound if recording or live audio is enabled
        if (brushToPlay() || listenerID) { playable.play(key, 1, 0, 0); }

      };

      let notes = CreateAppendChild("div", row);
      for (let x=0; x<TickCount; x++) {
        let tick = CreateAppendChild('p', notes, NBSP);
        // Action Clicking
        tick.onmousedown = function (e) {
          let txt = e.target.innerText;
          DragOverTickState = txt == NBSP ? 1 : 2;
          MouseIsDown = true; // Set global state
          e.target.innerText = txt == NBSP ? "*" : NBSP;
        }
        // Action Hovering/dragging
        tick.onmouseover = function (e) {
          if (MouseIsDown) {
            e.target.innerText = (DragOverTickState == 1 ? "*" : NBSP); // Continue painting
          } else if (e.target.innerText != NBSP && brushToPlay()) {
            playable.play(key, .5, 0); // Play it
          }
        };
      }
    }
  });

  let newRef = CreateAppendChild('p', knobs, "*");
  newRef.className = "actor";
  newRef.title = "NEW REF";
  newRef.onmousedown = () => RefPart(self, tickIdx, height+2*21);

  // Toggle brushToPlay knob
  let brushToPlay = AppendNewToggleActor(knobs, false, "actor",
    () => (headerTicks.style.color=null, ")("),
    () => (headerTicks.style.color="inherit", "()"));
  brushToPlay.element().title="BRUSH PLAY";


  // Clear all ticks knobs
  let clearKnob = CreateAppendChild('p', knobs, "X");
  clearKnob.className = "actor mustshift";
  clearKnob.title = "DELETE NOTES";
  clearKnob.onmousedown = function (e) {
    if (!e.shiftKey) { return; }
    RangeForEach(keyCount, (y) => {
      RangeForEach(TickCount, (x) => {
        grid.children[y].children[1].children[x].innerText=NBSP;
      })
    })
  }

  // Toggle Recording
  let listenerID = null;
  let recordKnob = CreateAppendChild('p', knobs, "#");
  recordKnob.className = "actor";
  recordKnob.title = "RECORD";
  let listenerIBC = function (m) {
    if (sheetObj.isPaused() || m[0] != "keyboard1") { return; }
    let tick = timer.currentTick( timer.jiffy()/2 )-tickIdx; // Adjust by half a jiffy so performing can be near the beat/tick instead of on or after it as is done by the tick highlighting renderer.
    if (m[2]) {
      if (m[1] < keyBeg || keyBeg+keyCount <= m[1]) { return; }
      // Rows are in reverse order, also compensate for the first supported MIDI note
      let row = keyCount - (m[1] - keyBeg) - 1;
      grid.children[row].children[1].children[tick].innerText = "*";
      playable.play(m[1], .5, 0, 0);
    }
  }

  recordKnob.onmousedown = function () {
    if (recordKnob.style.background == "") {
      recordKnob.style.background="#800";
      listenerID = IBC.addListener(listenerIBC);
    } else {
      recordKnob.style.background = "";
      IBC.delListener(listenerID);
      listenerID = null;
    }
    IBC(["tickclick", 0, 0]); // This tells any active part to stop listening to keyboard events.
  }


  // Clicking title will raise it.  Dragging title will move it around the sheet

  title.onmousedown = function (e) {
    // Right click on title toggle minimization but right button + meta bring up browser menu
    if (e.button == 2 && !e.metaKey) {
      ToggleElementDisplay(grid);
      event.stopPropagation(); // Keep event from elements
      return;
    }
    if (e.button != 0) { return; }
    MouseIsDown = true; // Set global state

    self.focus();

    // Drag/Move part within sheet

    let tickHeight = sheet.firstChild.firstChild.scrollHeight+1;
    let tickWidth  = sheet.lastChild.offsetLeft / (sheet.childElementCount-1); // Tick width take average width of all ticks
    let leftMargin = sheet.offsetLeft-sheet.scrollLeft; // Account for element's margin and scrolled offset
    sheet.onmousemove = function (offset, e) {
       if (!MouseIsDown) { sheet.onmousemove = null; return; } // Maybe stop handling this event
       // Adjust part's vertical position
       part.style.top = Max(offset + e.y, tickHeight) + "px";
       // Adjust part's horizontal position (Phrase's tick)
       let newTick = Floor((e.x-leftMargin+1) / tickWidth);
       if (newTick != tickIdx) {
         sheet.children[newTick].appendChild(part);
         tickIdx = newTick;
       }
    }.bind(null, part.offsetTop-e.y);
  };

  // Title editing.
  title.onkeydown = function (v) {
    event.stopPropagation(); // Don't bubble the event elsewhere (global controls),
    if (v.code == "Enter") {
      v.preventDefault(); // Prevent form element from adding a newline
    }
  }

  let self = function () { };
  self.element = () => part;
  self.titleName = () => title.innerText;
  self.tickCount = () => TickCount;
  self.sheet = () => sheetObj;
  self.startTick = function () { return tickIdx; }

  self.isOnTick = function (t) {
    return tickIdx <= t && t < tickIdx + TickCount;
  }

  self.play = function (gtick, time) {
    self.playTick(gtick - tickIdx, time);
  }

  let ticks = function (y) { return grid.children[y].children[1]; };

  self.playTick = function (tick, time) {
    if (tick < 0 || TickCount <= tick) {
      DB.error(`tick ${tick} out of range ${tickIdx}..${tickIdx+TickCount-1}`);
      return;
    }
    //DB.post("Part", [tick, time]);
    RangeForEach(keyCount, (i) => {
      let row = ticks(i).children;
      let note = row[tick];
      if (note.innerText == "*") {
        let sustain = 0;
        let next = tick + 1;
        while (next < TickCount
               && row[next].innerText == "-") {
          ++sustain;
          ++next;
        }
        playable.play(keyBeg + keyCount-i-1, .5, time, sustain);
      }
    });
  }

  self.focus = () => { // Raise/focus this element in sheet and reset others
    sheetObj.partsResetZ();
    part.style.zIndex = 1;
  }
  sheetObj.partAdd(self);

  return self;
} // Part



/******************************************************************************
 Run Time
******************************************************************************/

var setupControls = function (keyboard, sheet) {

  document.getElementById('volume').oninput = function (e) {
    Destinations.input(0).gain.value = e.srcElement.value / 100.0;
  }

  // tODO Rethink mousehover == editable focus.  Fails when text box is empty and width very thin.
  //document.getElementById('bpm').onmouseenter = function (event) { event.target.focus(); }
  //document.getElementById('bpm').onmouseleave = function (event) { event.target.blur(); }
  document.getElementById('bpm').onkeydown = function (event) {
    var newBpm;
    if (event.code == "ArrowUp") {
      newBpm = parseInt(event.target.innerText)+1;
    } else if (event.code == "ArrowDown") {
      newBpm = parseInt(event.target.innerText)-1;
    } else if (event.code == "Enter") {
      newBpm = parseInt(event.target.innerText);
      event.preventDefault(); // Prevent element's text receiving a newline
    } else {
      event.stopPropagation(); // Stop global hot keys from receiving event
      return;
    }
    if (isNaN(newBpm) || newBpm < 1 || 666 < newBpm){
      event.target.innerText = TickerTimer.bpm();
    } else {
      event.target.innerText = newBpm;
      TickerTimer.setBpm(newBpm);
    }
  }

  // TODO generalize input boxes
  // Hitting enter will evaluate the box contents the pass to the callback
  document.getElementById('freq').onkeydown = function (v) {
    if (v.code == "Enter") {
      let freq = parseFloat(v.target.innerText) || KeyFreq.freq();
      KeyFreq.setFreqA0(v.target.innerText = freq);
      v.preventDefault(); // Prevent form element from adding a newline
    }
    v.stopPropagation();
  }

  window.onmouseup = function () { MouseIsDown = false; }

  // Global hot keys
  window.onkeydown = function (v) {
    if (v.code == "Slash") DB.clear(); // Pressing '/' will clear the DB (debug console) element.
    //DB.post("window.onkeydown", v.code);

    let pauseElement = ElementById('pause');
    if (v.code == "KeyP") { sheet.pause(pauseElement); }
    else if (v.code == "KeyR") { sheet.rewind(pauseElement); } // Rewind the playback.
    else if (v.code == "Space") { // Pause or jump to mark
      sheet.isPaused()
        ? sheet.jump(pauseElement)
        : sheet.pause(pauseElement);
      v.preventDefault(); // Prevent space from scrolling browser window
    }
  }

  // Browser menu activated only with meta key.  The mouse event capture will
  // be stopped early if meta+mouse3 and the contextmenu bubble will only
  // bubble out if meta is active.
  window.addEventListener(
    "mousedown",
    (v) => v.metaKey && v.button==2 && v.stopPropagation(),
    true);
  window.oncontextmenu = (v) => v.metaKey || v.preventDefault();

  // Prevent tablets and phones from scrolling and resizing?
  document.body.addEventListener(
    'touchstart',
    function (event) {
      if (event.touches.length=='fack') {
        event.preventDefault();
      }
      DB(event.touches);
    },
    true);

}; //setupControls


var renderHandlerLoop = function (phraseObj) {
  var tick = TickerTimer.nextRender();
  if (tick !== false ) {
    //DB.post("render Handler", `${tick}`);
    phraseObj.render(tick);
    setTimeout(renderHandlerLoop.bind(null, phraseObj), 1000*TickerTimer.jiffy());
  } else {
    setTimeout(renderHandlerLoop.bind(null, phraseObj), 100);
  }
}

var processHandlerLoop = function (phraseObj) {
  let ticktime = TickerTimer.nextTick(); // returns [tick to process, time audio is written/buffered]
  if (ticktime !== false) {
    //DB.post("process Handler", `${ticktime}`);
    phraseObj.play.apply(null, ticktime);
  }
  setTimeout(processHandlerLoop.bind(null, phraseObj), TickerTimer.jiffy());
}



/******************************************************************************

 MAIN

 CONCEPTS Musical Definitions

 Pressing a physical key/pad creates a MIDI message/event.

 Sheet      >Arrangement of phrases
  Phrase    >Contains multiple parts
   Part     >A voice (could be a drum sound or entire piano)
    Measure  >Logical division of parts
     Beat    >Physical division of Parts
      Tick   >Physical division of Beats which contain notes to play

  Official      Me
  ------------- --------
  Measure/Bar
  Part/Voice
  Quarter note  Beat
  Shortest note Tick

******************************************************************************/
var Sheet0;
var Keyboard0;
var DrumKit0;
var Synthesizer0;
var Synthesizer1;
var Synthesizer2;
var Synthesizer3;
var DragOverTickState = 1;
var Volume = 0.5; // A global value shared by all output gain logic
var MouseIsDown = false; // It's nice to keep track of global mouse button state.  The window element will always catch this event and handle it.
var midi = null;

function Start () {
  DB.post("Start", DB.status());

  DB.post("Start", "Buttons");
  document.getElementById('addsynth').onmousedown = function () {
    var s = new Synthesizer(ctx, false, 1, Keyboard0, "#84f");
    document.getElementById('synths').appendChild(s.element);
  }

  document.getElementById('addFilterDelay').onmousedown = function () {
    var d = new Delay(ctx);
    Destinations.push(d);
    document.getElementById('filters').appendChild(d.element);
  }

  document.getElementById('addFilterLowpass').onmousedown = function () {
    var filt = new Lowpass(ctx);
    Destinations.push(filt);
    document.getElementById('filters').appendChild(filt.element);
  }

  // Create a piano object and DOM element.  88 keys, starting at 21/A0.
  DB.post("Start", "Keyboard");
  Keyboard0 = new PianoKeyboard("piano1", 21, 88);
  //var keyboard2 = new PianoKeyboard("piano2",  88, 9, 0, 27.5); // 88-key piano: A0 A# B C1 C# D ...

  // MIDI fun
  DB.post("Start", "MIDI");
  function onMIDISuccess( m ) { // TODO Keyboard0 should not be receiving MIDI commands.
    m.inputs.forEach( e => {e.onmidimessage=function(e){Keyboard0.midi(e);};} );
  }

  function onMIDIFailure(msg) { DB.error("MIDI "+msg ); }

  if (navigator.requestMIDIAccess) {
    navigator
      .requestMIDIAccess({"sysex":true, "software":true})
      .then(onMIDISuccess, onMIDIFailure);
  }

  let sheet = Sheet("sheet", 128, TickerTimer);

  DB.post("Start", "More Buttons");
  setupControls(Keyboard0, sheet); // Setup menus and moveable buttons.

  DB.post("Start", "Noises");

  // Load the audio asynchronously and create the default drumkit.
  DrumKit0 = new Drumkit(ctx, "orange", 24, ["808.bass.raw", "808.snare.drum.raw", "808.snare.noise.raw", "808.maracas.raw", "808.cowbell.raw", "808.rim.raw", "808.highhat.closed.raw", "808.claves.raw", "808.clap.raw", "808.highhat.opened.raw", "808.cymbal.raw", "909.thump.raw", "909.snare.noise.raw", "tsss.raw", "boots.raw", "cats.raw"]);

  // LiveKa7 v3
  //restoreSongLK3(Keyboard0, DrumKit0); //, hyphen.song());

  // LiveKa7 v2
  //restoreSongLK2(Keyboard0, DrumKit0);

  // LiveKa7 v1
  if (!Synthesizer0) {
    Synthesizer0 = new Synthesizer(ctx, false, 2, Keyboard0, "#84f");
    document.getElementById('synths').appendChild(Synthesizer0.element);
  }


  if (!Synthesizer1) {
    Synthesizer1 = new Synthesizer(ctx, false, 1, Keyboard0, "#4f4");
    document.getElementById('synths').appendChild(Synthesizer1.element);
  }

  if (!Synthesizer2) {
    Synthesizer2 = new Synthesizer(ctx, false, 2, Keyboard0, "#44f");
    document.getElementById('synths').appendChild(Synthesizer2.element);
  }

  if (!Synthesizer3) {
    Synthesizer3 = new Synthesizer(ctx, false, 3, Keyboard0, "#84f");
    document.getElementById('synths').appendChild(Synthesizer3.element);
  }

  //restoreSongLK1(Keyboard0, DrumKit0);

  // LiveKa7 v0
  //restoreSongLK0(Keyboard0, DrumKit0); // Parse get string

  // Effects
  if (!Destinations[1]) {
    var e = new Delay(ctx);
    Destinations.push(e);
    document.getElementById('filters').appendChild(e.element);
  }

  if (!Destinations[2]) {
    var e = new Lowpass(ctx);
    Destinations.push(e);
    document.getElementById('filters').appendChild(e.element);
  }

  DB.post("Start", "Sequences");
  Part(sheet, 8, 1*21, 24, 16, 32, DrumKit0 );
  Part(sheet, 8,16*21, 21, 88, 32, Synthesizer1 ); // startTick, verticalPos, keyCount <=61, tickCount
  //Part(sheet, 5, 1*20, 13, 8, Synthesizer1 ); // startTick, verticalPos, keyCount <=61, tickCount

  sheet.setStart(8).setEnd(8+32-1);

  DB.post("Start", "Handlers");
  renderHandlerLoop(sheet);
  processHandlerLoop(sheet);

} // Main


// Await for user gesture then restart WebAudio
window.onload = function Main () {
 if (ctx.state == "suspended") {
   revealCenter("pauseicon", true)
   ctx.resume()
   setTimeout(Main, 200);
 } else {
   DB.post("Main", "Starting AudioContext!");
   revealCenter("pauseicon", false)
   setTimeout( ()=>ElementById("pauseicon").style.clipPath="", 1100);
   Start();
 }
};


//IBC.debug();

//]]></script></body></html><!--
* Synth listener that crashes (key out of bounds) denies
  other synths from receiving.
* Moving part to another tick broken when moved beyond the
  last phrase grid column.
* BPMs don't seem to do much beyond 150.  Need to optimize output process pipeline.
------------------------------------------------------------------------------/
