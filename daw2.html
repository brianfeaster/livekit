<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html version="-//W3C//DTD XHTML 1.1//EN"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xml:lang="en" lang="en"
      xsi:schemaLocation="http://www.w3.org/1999/xhtml http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd">
<head>
 <title>Liveka7 DAW</title>
 <link rel="stylesheet" href="daw2.css" type="text/css" media="screen" title="Shrewm"/>
</head>
<body>

<p id="xDB" style="width:24em; background:black; z-index:1; border:solid 1px green; white-space:pre; overflow:auto; max-height:10em; position:fixed; right:0; bottom:0"></p>


<div style="float:right">&#x2669; &#x266b; &#x266a; &#x266c; &#x266d; &#x266e; &#x266f;</div>

<h1>Liveka7 Digital Audio Workstation 2<span style="font-family:monospace">&#x03b1;</span></h1>
<hr/>
<div id="headerNav" class="headerNav">
 <!--a id="info" style="background-color:#22f;width:10em;text-align:left;display:inline-block">info</a-->
 <a onmousedown="window.location.href=window.location.pathname+''">Clear</a>
 <a onmousedown="popupToggle('pauseicon')">Kitteh</a>
 <a onmousedown="popupToggle('djRefact0r')">DjRefact0r</a>
 <a href="https://www.w3.org/TR/webaudio/">WebAudio</a>
</div>

<div class="window">
  <div>SHEET</div>
  <div class="knobs">
    <!--input id="volume" type="range" max="100" value="50" min="0" style="width:6ch" title="VOLUME"/-->
    <p id="mainVolume" title="MAIN VOLUME">VOL</p>
    <p id="bpm" title="BEATS PER MINUTE">&nbsp;BPM&nbsp;</p>
    <p class="actor reset" title="PLAY" onmousedown="TickerTimer.rewind(this)">|&gt;</p>
    <p id="pause" class="actor pause" title="PAUSE" onmousedown="TickerTimer.pause(this)">||</p>
    <div id="addpartdrum" class="addpart">
      <div style="display:none; border:solid 1px #066; background:#000; white-space:nowrap; position:absolute; z-index:3">
        <div id="createphrasedrum" style="background:#066; text-align:center">Create</div>
        <input id="addmeasures" value="4" type="number"/>Measures<br/>
        <input id="addbeats" value="4" type="number"/>Beats<br/>
        <input id="addticks" value="4" type="number"/>ticks<br/>
      </div>
      <p class="actor" title="NEW DRUM PART">+</p>
    </div>
    <div id="addpartsynth" class="addpart">
      <div style="display:none; border:solid 1px #066; background:#000; white-space:nowrap; position:absolute; z-index:3">
        <div id="createphrase" style="background:#066; text-align:center">Create</div>
        <input id="addmeasures" value="4" type="number"/>Measures<br/>
        <input id="addbeats" value="4" type="number"/>Beats<br/>
        <input id="addticks" value="4" type="number"/>ticks<br/>
      </div>
      <p class="actor" title="NEW SYNTH PART">+</p>
    </div>
    <!--p style="border-radius:40%; font-weight:bold; color:black; background:yellow; border:dashed thick red" class="actor" title="THE DROP (USE SPARINGLY)">&gt!}=-<b style="background-color:red"> DrOp </b>-={!&lt;</p-->
    <div id="zoom" style="display:inline-block">
      <p class="actor" title="UNZOOM<">|</p>
      <p class="actor" title="ZOOM<">|-</p>
    </div>
  </div>
  <div id="sheet" class="sheet"></div>
</div>

<div class="window" style="float:left;margin:1pc;">
  <div>DRUMS</div>
  <div class="knobs"><p id="adddrum" class="actor">+</p></div>
  <div id="drums"></div>
</div>

<div class="window">
  <div>SYNTHS</div>
  <div class="knobs"><p id="addsynth" class="actor">+</p></div>
  <div id="synths"></div>
</div>

<div class="window">
  <div>FILTERS</div>
  <div class="knobs">
    <p id="addFilterDelay" class="actor">D</p>
    <p id="addFilterLowpass" class="actor">L</p>
  </div>
  <div id="filters"></div>
</div>

<div class="window">
  <div>KEYBOARD</div>
  <div class="knobs"></div>
  <div style="max-width:calc(100vw - 2ch); overflow:scroll">
    <div id="piano1" class="piano"></div>
  </div>
</div>

<p><img id="pauseicon" title="PSYCHEDELIC PAWS" alt="PSYCHEDELIC PAWS" style="display:none; border-radius:50%; clip-path: polygon(35% 0, 100% 55%,35% 100%);" src="catpause.jpg" onclick="ctx.resume()"/></p>
<p><img id="djRefact0r" title="DJ REFACT0R" alt="DJ REFACT0R" style="display:none; z-index:2; width:100%" src="djRefact0r.jpg" onclick="ctx.resume()"/></p>


<script type="text/javascript">//<![CDATA[
"use strict"

/******************************************************************************
  Debug message console and error checking

  DOM requirements::
    <p id="DB"></p>        -- If nonexistent, the DB object will revert to using the browser's console.

  Usage::
    DB("string")           -- Send string to info window.  Behaves like a pre element.
    DB.log("string")       -- Send string to console.log.
    DB.error("string")     -- Send string to console.log.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.clear()             -- Empty the entire DB element.
    DB.check(expr, string) -- If expr is false, send string to console.  status() will then always return false.
    DB.status()            -- Returns false if check ever failed.
******************************************************************************/
var DB = (function () {
  var consoleElement = document.getElementById('DB');
  var self;
  var status = true;
  var shouldNewline = true; // Want to prepend a newline when the last message was plain text.
  var lastPostType = false, lastPost = false;
  var repeatCount = 1;

  var setStyles = function (e) {
    return;
    e.style.border = "solid 1px green";
    e.style.whiteSpace = "pre";
    e.style.overflow = "auto";
    e.style.maxHeight = "20em";
  }

  // Create the instance which is a function.  Also create the clear function.
  if (!consoleElement) {
    self = function (s) { console.log(s); return s; }
    self.log = self;
    self.error = function (s) { console.error(s);}
    self.post  = function (t, s) { // For the console, only the first post type is displayed.
      console.log("[" + t + "]" + s);
      return s;
    }
    self.clear = function () { lastPostType = false; }
  } else {
    setStyles(consoleElement);
    self = function (s) {
      if (lastPost == s) {
       ++repeatCount;
        s = repeatCount + s;
      } else {
        repeatCount = 1;
      }
      consoleElement.innerHTML += (shouldNewline ? "" : "\n") + s;
      consoleElement.scrollTop = consoleElement.scrollHeight;
      shouldNewline = lastPostType = false;
    }
    self.log = function (s) { console.log(s); }
    self.error = function (s) { console.error(s); }
    self.post = function (t, s) {
      if (t == lastPostType) {
        if (lastPost == s) { ++repeatCount; }
        consoleElement.lastChild.innerText = (1<repeatCount ? repeatCount : "") + "[" + t + "]" + s;
      } else {
        consoleElement.appendChild(document.createElement('p')).innerText = "[" + t + "]" + s;
        consoleElement.scrollTop = consoleElement.scrollHeight;
        lastPostType = t;
        repeatCount = 1;
      }
      lastPost = s;
      shouldNewline = true;
      return s;
    }
    self.clear = function () {
       consoleElement.innerHTML = "";
      shouldNewline = lastPostType = true;
    }
  }

  self.check = function (expr, msg) {
    status = status && expr;
    return expr || self.error(msg) && false;
  }

  self.status = function () { return status; }

  return self;
})(); // DB


/******************************************************************************
  Useful objects
******************************************************************************/
var ctx = (window.AudioContext && new window.AudioContext()) ||
          (window.webkitAudioContext && new window.webkitAudioContext());
DB.check(ctx, "Missing window.AudioContext.  Use another browser.");
var $ = (s)=>document.querySelector(s);
var $$ = (s)=>[...document.querySelectorAll(s)];

/******************************************************************************
  Useful aliases and funtions
******************************************************************************/
var NBSP = "\u00a0";
var Floor = Math.floor;
var Round = Math.round;
var Ceil  = Math.ceil;
var Pow   = Math.pow;
var Abs   = Math.abs;
var Rnd   = Math.random;
var Max   = Math.max;
var Min   = Math.min;
var Mod   = function (n,d) { return n - d * Floor(n/d); };
var Trunc1 = function (f) { return f.toFixed(1); }
var Trunc2 = function (f) { return f.toFixed(2); }
var ElementById = function(id) { return document.getElementById(id); };
var $ = (s)=>document.querySelector(s);
var $$ = (s)=>[...document.querySelectorAll(s)];

// Simple Array compare
HTMLElement.prototype.setClassAndTitle = function (className, title) {
  this.className = className;
  this.title = title;
  return this;
}

Array.prototype.cmp = function (that, len) {
  if ( (len=this.length) == that.length) {
    while (0<=--len && this[len] === that[len]);
  }
  return -1==len;
}

// Gen ary of ints: []  [0..--a]  [a..b]
var Range = (a, b) =>
  (f => Array.from(Array(f?b-a+1:a||0).keys(),f))
  (null==b ? b : n=>n+a);


var RangeMap = function (range, f) {
  return (range instanceof Array ? Range(...range) : Range(range)).map(f);
}

var RangeFilter = function (range, f) {
  return (range instanceof Array ? Range(...range) : Range(range)).filter(f);
}

var RangeForEach = function (range, f) {
  return (range instanceof Array ? Range(...range) : Range(range)).forEach(f);
}

var CreateAppendChild = function (tag, parent, text) {
  var e = parent.appendChild(document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

var CreateAfterSibling = function (tag, sibling, text) {
  var e = sibling.insertAdjacentElement('afterend', document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

var CreateInsertChild = function (tag, parent, text) {
  var e = parent.insertBefore(document.createElement(tag), parent.firstChild);
  if (text != undefined) { e.innerText = text; }
  return e;
};

var ToggleElementDisplay = function (e1, e2) {
  let off = e1.style.display == "none"; // 'none' implies not displayed.  '' implies the default CSS value.
  e1.style.display = off ? "" : "none"; // Toggle e1's display state.
  if (e2) { e2.style.display = off ? "none" : ""; } // e2's style is opposite e1.
};


// Reveal instantly an element in the center of the screen if 'show' == true,
// otherwise un-reveal it by slowly reducing opacity over time.
var revealCenter = function (id, show) {
  // Show, reset styles
  let e = ElementById(id);
  let style = e.style;
  style.opacity = style.display = "";
  style.position = "fixed";
  style.top      = (window.innerHeight/2 - e.height/2) + "px";
  style.left     = (window.innerWidth/2 - e.width/2) + "px";
  // Leave on
  if (show) { return; }
  // Slowly vanish
  (e.vanish = (opacity) => {
    if (opacity <= 0.0) {
      // Unshow, reset opacity
      style.display="none";
      style.opacity = ""
    } else {
      style.opacity = opacity;
      setTimeout(e.vanish.bind(null, opacity-0.05), 50);
    }
  })(1.0);
}


/*  Slowly reveal or hide a DOM element.
*/
var popupToggle = function (id) {
  let e = document.getElementById(id);
  let style = e.style;
  let op; // Opacity to start at
  if (style.display == "none") { // If off enable it and ramp opacity from 0 to 1
    style.display = "";
    style.position = "fixed";
    style.top = (window.innerHeight/2 - e.clientHeight/2) + "px"; // Always be centering
    style.left = (window.innerWidth/2 - e.clientWidth/2) + "px";
    op = style.opacity = -1; // Slowly reveal
  } else {
    op = 100; // Slowly disappear
  }
  (e.opacity = (o) =>
    o <= -100
      ? e.style.opacity=""
      : o == 0
        ? (style.opacity="", style.display="none")
        : (style.opacity = Abs(o/100),
           setTimeout( e.opacity.bind(null, o-5), 10))
  )(op);
  e.onmousedown = () => popupToggle(id);
}


// Blink element using color, stop blinking if color false
var blinkify = (e, color) => (
  e.blinker = color
    ? () => (setTimeout( ()=>e.blinker(), 400),
             e.style.backgroundColor = e.style.backgroundColor ? "" : color)
    : () => e.style.backgroundColor = ""
)();


/* A click-toggleable element object

   A DOM element is created and added to parent. When clicked, the appropriate
   handler will be called.  Each callback will receive the event and should
   return a string set to the innerText.  The current state and associated
   element have getters.

   USAGE::
   let a = AppendNewToggleActor(document.body, false, "myclass", ()=>"yes", ()=>"no");
   DB(`State ${a()}  Element ${a.element(}`);
*/
var AppendNewToggleActor = function (parent, state, className, callbackTrue, callbackFalse) {
  let element = CreateAppendChild('p', parent) // New Element
  if (className) { element.className = className; } // Maybe set the class
  // Call appropriate handler and update element's text
  let act = (event) => element.innerText = (state ? callbackTrue : callbackFalse)(event);
  // Event handler: toggle state
  element.onmousedown = (event) => (state = !state, act(event));
  // Call a handler at instantiation so everything is synched
  act();
  // Return state
  let self = () => state;
  // Return DOM element
  self.element = () => element;
  return self;
};


/******************************************************************************
  Create a slider object in the DOM.

  There will be one slider object that when activated will adjust wherever the
  mouse moves over it be set to the passed in value.  A call back will be
  provided that will be set to the final value.

  USAGE::
    var slider = new DOMSlider();

  CONSTRUCTOR PARAMETERS::
    na             N/A

  METHODS::
    default(e, i, c)  Activate slider in the DOM at the mouse position
                      using event e, initial value i, and setter
                      callback c.
******************************************************************************/
var Slider = function () {
  var callback;
  var mouseMoved = false,  mouseUp = false;
  var e = CreateAppendChild('p', document.body);
  e.style.position = "absolute"
  e.className = "knobs"
  e.style.width="13ch";
  e.style.border="solid 1px #066";
  e.innerHTML = "<p>|-----|-----|\n|-----|-----|</p><div>0</div>";
  e.style.display="none";
  e.style.background="black";
  e.style.zIndex=2;
  e.children[0].onmousemove = function (event) {
    mouseMoved = true;
    var box = event.target.getBoundingClientRect();
    var val = 1.0-((event.clientX - box.left) / box.width + .005)
    if (val < 0.0) val = 0.0;
    if (1.0 < val) val = 1.0;
    event.target.parentElement.children[1].innerText = val.toFixed(2);
    callback(val);
  }
  e.children[0].onmouseleave = function () {
    if (mouseMoved) { e.style.display = "none"; }
  }
  e.onmousedown = function (event) { event.stopPropagation(); }
  e.onmouseup = function (event) { // Handle clicking, releasing, then moving
    if (mouseMoved || mouseUp) { e.style.display="none"; }
    event.stopPropagation();
    mouseUp = true
  }
  return function(event, val, cb) {
    callback = cb;
    e.children[1].innerText = val.toFixed(2);
    mouseMoved = false;
    mouseUp = false;
    e.style.display="block";
    e.style.top = Floor(event.pageY - e.clientHeight/3.0) +"px" ;
    e.style.left = Floor(event.pageX - e.clientWidth*(0.995-val)) +"px" ;
  }
}() // DOMSlider


/******************************************************************************
  Knobify - Give an element a "knob" behavior

  A knob reveal its value by hovering, the mouse wheel adjusts while the
  callback receives the new value, clicking reveals drop down of optional
  presets.

  USAGE::
    <p id="myknob">volume</p>
    Knobify("myknob", (v)=>(vol=v,Round(v)), 10, 0, 100, [100,75,50,25,0])

    element  - Element (or element's id) to knobify.
    callback - Function that receives updated values and returns value
               to display (handles rounding, truncating)
    val      - Initial value (default max)
    fac      - Internal minimum decimal update offset.
    min      - min adjustable value (default 0)
    max      - max adjustable value (default 100)
******************************************************************************/
var Knobify = function (element, callback, val, fac, min, max, presets) {
  element = element instanceof Element ? element : ElementById(element);
  element.className += " actor"; // Make sure actor style

  let value = val===undefined ? max :val;
  let valueSet = (val)=>value=val;
  fac = fac===undefined ? 0.1 :fac;
  min = min===undefined ? 0   : min;
  max = max===undefined ? 100 : max;

  // Move all children into a new child parent.
  let label = element.innerHTML || "KNOB";
  element.innerHTML = "";
  let header = CreateAppendChild('p', element);
  header.innerHTML=label;
  header.contentEditable = true;

  let epresets = undefined;
  if (presets) {
    epresets = CreateAppendChild('div', element);
    epresets.className = "knobspresets";
    epresets.style.display="none";

    element.onmousedown = ()=>epresets.style.display="";

    presets.forEach( (val)=>{
      let e = CreateAppendChild('p', epresets, val);
      e.onmousedown = ()=>header.innerText=callback(valueSet(val));
    });
  }

  header.onmouseover = () => { // Mousing over reveals value
    header.focus();
    header.style.minWidth = element.clientWidth + "px";
    header.innerText = callback(value);
  };

  element.onmouseleave = ()=>{
    if (epresets) { epresets.style.display="none"; }
    header.blur();
    header.innerHTML=label; // Revert to label
  }

  element.onwheel = (e) => { // Scrolling mouse adjusts value
    let v = value - e.deltaY * fac;
    if (v < min) { v=min; } else if (max < v) { v=max; }
    if (v != value) { header.innerText= callback(valueSet(v)); }
    e.preventDefault(); // So scrolling doesn't affect the browser
  };

  header.onkeydown = function (event) {
    let val;
    if (event.code == "ArrowUp") {
      val = value + 1;
    } else if (event.code == "ArrowDown") {
      val = value - 1;
    } else if (event.code == "Enter") {
      val = parseFloat(event.target.innerText);
      if (isNaN(val)) { val = value; }
    } else {
      event.stopPropagation(); // Stop any other key from propagating
      return;
    }
    if (val < min) { val=min; } else if (max < val) { val=max; }
    header.innerText = callback(valueSet(val));
    event.preventDefault(); // Prevent element's text receiving a newline
  };

  callback(value); // Make sure callback is synchronized
  return element;
}; // Knobify



/******************************************************************************
  Hyphen - WebSocket based Key/Value store

  USAGE::
    hyphen(msg)      Send message to Hyphen
******************************************************************************/
//hyphen.song = function () { return ""; }
var hyphen = function () {
   DB ("Connecting to Hyphen!");
   var server = new WebSocket( window.location.protocol=="https:" ? "wss://shroom.dv8.org:7179" : "ws://shroom.dv8.org:7180");
   var song = false;

   // Listener starts off waiting for "HYPHEN" hello message
   server.onmessage = function (e) {
      if (typeof(e.data) == "string") {
         if (e.data != "HYPHEN") {
            DB("hyphen Sent hot bars");
            song = e.data.split("&")[0];;
            window.location.href = window.location.pathname+"?"+song;
         } else {
             DB("hyphen text: " + e.data);
         }
      } else {
         DB("hyphen bin: " + e.data);
      }
   }

   var get = function (songid) {
      if (server.readyState != 1) {
         DB.post("hyphen", "Waiting for connection readyState...");
         setTimeout(get.bind(0, songid), 200);
      } else {
         DB("hyphen sending: get" + songid);
         var ret = server.send("get" + songid);
      }
   }

   var qstr = window.location.search.substring(1).split("&")[0];
   if ( qstr.length < 20) {
      get(qstr);
   }

   var self = get;

   self.server = function () { return server }
   self.song   = function () { return song }

   return self

};


/******************************************************************************
  Base64 encoder and decoder

  USAGE::
    Base64([1,2,3])  Returns a base64 encoded string of the byte (0..255)
                     values in the array.
    Base64("0G83")   Returns a decoded base64 string as an array of bytes
                     values.
    Base64.test(ary) Runs an internal test.  Calls DB.check(ary) on the
                     comparision of the output of the encoding then decoding
                     of the passed byte array.
  ALGORITHM NOTES::
    An incomplete octet will be correctly created because:
    (emptyArray[0] >> num)   =>   (undefined >> num)   =>
******************************************************************************/
var Base64 = (function () {
  //// Private
  var self;
  var base64table = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',
                     'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
                     'W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l',
                     'm','n','o','p','q','r','s','t','u','v','w','x','y','z','-','_'];
  var _encode = function (ary) {
    var ary1 = ary.slice(0); // Copy the array since I shift the elements off.
    var octet=0;     // Which octet to create
    var str = ""; // The encoded string
    while (ary1.length) {
      str +=
        base64table[(0 == octet) ? ary1[0] >> 2 :                              // [000000..]
                    (1 == octet) ? ((ary1.shift() & 3) << 4) + (ary1[0] >> 4) :// [......00][1111....]
                    (2 == octet) ? ((ary1.shift() & 15) << 2) + (ary1[0] >> 6) //           [....1111][22......]
                   /*3 == octet*/: ary1.shift() & 63];                         //                     [..222222]
      octet = ++octet & 3;
    }
    return str;
  }

  var _decode = function (str) {
    var ary=[];
    var i=0, byte, stet0, stet1;
    while (i < str.length) {
      stet0 = base64table.indexOf(str[i]);
      if (!DB.check(0 <= stet0, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      stet1 = base64table.indexOf(byte=str[++i]);
      if (!DB.check(0 <= stet1, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      ary.push((stet0 << 2) + (stet1 >> 4)); // [000000][00....]
      if (++i == str.length) break;


      stet0 = base64table.indexOf(byte);
      if (!DB.check(0 <= stet0, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      stet1 = base64table.indexOf(byte=str[i]);
      if (!DB.check(0 <= stet1, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      ary.push(((stet0&15) << 4) + (stet1 >> 2));//         [..1111][1111..]
      if (++i == str.length) break;


      stet0 = base64table.indexOf(byte);
      if (!DB.check(0 <= stet0, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      stet1 = base64table.indexOf(str[i]);
      if (!DB.check(0 <= stet1, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      ary.push(((stet0&3) << 6) + (stet1));           //                 [....22][222222]
      if (++i == str.length) break;
    }
    return ary;
  }

  var _test1 = function (ary) {
    var str = Base64(ary);
    var ary2 = Base64(str);
    DB.check((ary.toString() == ary2.toString()), ary + " != " + ary2);
  }

  var _test = function () {
    _test1([]);
    _test1([0]);
    _test1([1]);
    _test1([2]);
    _test1([255]);
    _test1([1,255]);
    _test1([255,1]);
    _test1([255,1]);
    _test1([255,1,255]);
    _test1([255,1,255]);
    _test1([1,255,1]);
    _test1([0,0,0,0,0]);
    _test1([0,0,0,0,255]);
    _test1([255,0,0,0,0]);
    _test1([1,1,1,1,1]);
    _test1([255,255,255,255,255]);
  }

  //// Public
  self = function (o) {
    if (Array.isArray(o)) return _encode(o);
    else if (typeof o == "string") return _decode(o);
    else return false;
  }

  self.test = _test;

  return self;
})();

Base64.test();


/******************************************************************************
  GET string wrapper providing a stream object.

  USAGE::
    var gs = new GetStringBase64();

  METHODS::
    .reset           Reset the stream.
    .assertString(s) Match and consume the next bytes as characters to string s.
    .assertBytes(a)  Match and consume the next bytes as bytes to byte array a.
    .nextString(l)   Return next bytes as string of length l.
    .nextBools(c)    Consume and return next c bits as array of bytes.  Unused bits ignored.
    .nextByte()      Consume and return next byte as byte.
    .peekByte()      Return next byte as byte.
    .examine()       Return current internal unBased64 getstring.
    .length()        Return current length of decoded GET string.
******************************************************************************/
var GetStringBase64 = function (get) {
  //// PRIvate
  var self = this;
  var _gsb64 =
    get ||
    (window.location.search.substring(1).length < 20 // Using query as song filename as well
    ? ""
    : window.location.search.substring(1));
  var _gs = [];

  //// PUBLIC
  this.reset = function () {
    _gs = Base64(_gsb64);
  }

  this.assertString = function (str) {
    for (var i=0; i<str.length; ++i) {
      var a = _gs.shift();
      var b = str.charCodeAt(i);
      if (a != b) return false;
    }
    return true;
  }

  this.assertBytes = function (ba) {
    for (var i=0; i<ba.length; ++i) {
      var a = _gs.shift();
      var b = ba[i]
      if (a != b) return false;
    }
    return true;
  }

  this.nextString = function (len) {
    var ret = _gs.splice(0,len);
    return String.fromCharCode.apply(null, ret);
  }

  this.nextBools = function (len) {
    var i=0, b, m, bs=[];
    while (i<len) {
      m = i++%8;
      if (0 == m) {
        if (_gs.length < 1) { return bs; }
        b = _gs.shift();
      }
      bs.push(!!(b >> m&1));
    }
    return bs;
  }

  this.nextByte = function () {
   return (0 < _gs.length) ? _gs.splice(0,1)[0] : null;
  }

  this.peekByte = function () {
   return (0 < _gs.length) ? _gs[0] : null;
  }

  this.examine = function () { return _gs; }
  this.length  = function () { return _gs.length; }

  var _testAssert = function (a, b) { DB.check(a==b, a + " != " + b); }
  var _test = function () {
    var __gsb64 = _gsb64; // Save internal state
    var __gs = _gs;

    _gsb64 = "C34oCm";
    self.reset();
    _testAssert(self.nextByte(), 48);
    _testAssert(self.nextByte(), 49);
    _testAssert(self.nextByte(), 50);
    _testAssert(self.nextByte(), 51);
    _testAssert(self.nextByte(), null);

    _gsb64 = __gsb64; // Restore internal state
    _gs = __gs;
  }

  _test();
  this.reset();
}


/******************************************************************************
  Inter-Broadcast Communication message hyper-loop system.

  USAGE::

  METHODS::
    (m)
    .broadcast(m)    Send m to all listeners
    .listeners()     Get current set of listeners
    .addListener(f)  Add a listener callback which receives m.  Returns an id.
    .delListener(id) Remove aforementioned listener.
    .debug()         Toggle debug

******************************************************************************/
var IBC = function () {
  // Private
  let _debug = false;
  let _id = 0;
  let _listeners = []; // Array of [id, callback, messaged?]

  // Public

  self = function (m) { self.broadcast(m); }

  // Send m to all the listeners
  self.broadcast = function (m) {
    let ls = _listeners.filter( (l)=>!l[2] ); // Listeners we haven't messaged yet

    // Debug dump the message and the handler ID's who'll get it
    if (_debug) { DB( ` ${ls.reduce( ((r,l) => r+=" "+l[0]), JSON.stringify(m)+" ->")}`); }

    ls.forEach((f)=>{
      f[2] = true; // Set handler messaged bool to prevent message cycles
      f[1](m);
      f[2] = false;
    });
  }

  self.listeners = function () { return _listeners; }
  self.addListener = function (f) { _listeners.push([++_id, f]);  return _id; }
  self.delListener = function (id) {
    let idx = _listeners.findIndex( (e)=>e[0]==id );
    if (0 <= idx) { _listeners.splice(idx, 1); }
  }
  self.debug = function () { _debug = !_debug; };
  // Test
  (function(){
    let l1, l2, a=0, b=0;
    DB.check(self.listeners().length==0, "ERROR:  There should be 0 listeners"); // Verify no listerns

    l1 = self.addListener(function (m) { a=m; }); // Register a listener
    self.broadcast(69);                      // Broadcast to listener 1
    DB.check(self.listeners().length==1, "ERROR:  There should be 1 listener, instead " + self.listeners().length);
    DB.check(a==69 && b==0, "ERROR:  Expect 69 and 0 after broadcast: " + a + " " + b);

    l2 = self.addListener(function (m) { b=m; });
    self.broadcast(42);                      // Broadcast to listener 1 and 2
    DB.check(self.listeners().length, 2);
    DB.check(a==42 && b==42, "ERROR:  Expect 42 and 42 after broadcast: " + a + " " + b);

    self.delListener(l1); // Remove listener 1
    self.broadcast(55);                      // Broadcast to listener 2
    DB.check(self.listeners().length==1, "ERROR:  There should be 1 listener"); // Verify no listerns
    DB.check(self.listeners().length, 2);
    DB.check(a==42 && b==55, "ERROR:  Expect 42 and 55 after broadcast: " + a + " " + b);

    self.delListener(l2);
    self.broadcast();
    DB.check(self.listeners().length==0, "ERROR:  There should be 0 listeners"); // Verify no listerns
  })();
  return self;
}(); // IBC


/******************************************************************************
  Skeuomorphic piano keyboard.  Implements the DOM element as well as the
  audio synthesis.

  USAGE::
    var kb = new PianoKeyboard(id, startKey, keyCount, startOctave);

  CONSTRUCTOR PARAMETERS::
    id             DOM element id to add the new piano element.
    startKey       Initial key using MIDI note values 0..127 == C-1..G9
    keyCount       Number of keys

  METHODS::
DEPREATED    .freq(key)             Frequency of key.
    .highlight(key, color) Highlight the key using color.  Overrides its last
                           color, if any, by pushing new color on a stack.
    .unhighlight(key)      Removes last/top highlighted color and reverts to
                           its previous color (if any)
    .midi(event)           MIDI message to interpret and perform

  GLOBALS::
    IBC: Keyboard will broadcast the physical press.  Listener will act on the
         message and set tick notes, high-light things, send audio to the DAC,
         etc.  Performance is a concern.  Audio stream related messages should
         avoid the IBC and manage private callback lists.
******************************************************************************/
var PianoKeyboard = function (id, keyStart, keyCount) {
  //// Private
  var self = this;
  var element = document.getElementById(id);
  var chanOut = 0;
  DB.check(element, "ERROR: PianoKeyboard: Element id=" + id + " not found in DOM.");

  var knobs = element.parentElement.previousElementSibling;
  let midi = CreateAppendChild('p', knobs, chanOut);
  midi.title = "CHANNEL OUT";
  midi.onmousedown = (e) => {
    if (e.button == 0) { 0<chanOut && --chanOut; };
    if (e.button == 2) { chanOut<15 && ++chanOut; };
    midi.innerText = chanOut;
  };

  var _keysDOM = []; // Keeps track of the DOM elements which represent the white and black keys in order.
  var _highlights = []; // Array of stacks.  An empty stack implies no high-light.
  var _highlightColor = "#f8f"
  var notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

  // Helpers to set/unset key highlight

  var keyPress = function(key) {
    self.highlight(key, _highlightColor); // Set current key high-light
    IBC([chanOut, key, 1.0]); // Notify listeners a note/key was pressed
  }

  var keyRelease = function(key) {
    self.unhighlight(key, _highlightColor);
    IBC([chanOut, key, 0]); // Notify listeners a note/key was released
  }

  RangeForEach(keyCount, (i) => {
    let key = keyStart + i;
    let newKey;
    // Sharp or natural key.
    if (2 == notes[key % 12].length) {
      newKey = CreateAppendChild('p', element);
    } else {
      newKey = CreateAppendChild('div', element)
      // Natural key gets a note/octave label
      var octave = Floor((key-12) / 12);
      let note = key % 12;
      newKey.innerText = notes[note] + (note==0?octave:'');
    }

    // Register mouse event handlers for every keyboard DOM element representing a key.
    newKey.onmouseover  = ()=>MouseIsDown && keyPress(key);
    newKey.onmousedown  = ()=>(MouseIsDown=true, keyPress(key));
    newKey.onmouseleave = ()=>MouseIsDown && keyRelease(key);
    newKey.onmouseup    = ()=>keyRelease(key);

    _keysDOM.push(newKey); // Keep track of each created key.
    _highlights.push([]);
  });

  self.highlight = function (key, color)  {
    //DB.post("PianoKeyboard", ["highlight", key, color])
    let i = key - keyStart;
    if ((0 <= i) && (i < keyCount)) {
      _highlights[i].push(color);
      _keysDOM[i].style.backgroundColor = color;
    }
  }

  self.unhighlight = function (key, color) {
    //DB.post("PianoKeyboard", ["unhighlight", key, color])
    let i = key - keyStart;
    let stk = _highlights[i];
    if (!stk) return; // Invalid key keys are ignored.
    if (color) { // Remove color from stack (could be anywhere)
      let s = stk.indexOf(color);
      if (-1 < s) { stk.splice(s, 1); }
    } else {
      stk.pop(); // If no color passed, pop last color
    }
    // Set the key's color to the top of the stack
    let l = stk.length;
    _keysDOM[i].style.backgroundColor = (0 < l) ? stk[l-1] : "";
  }

  /*
    Voice Message        octet 1         octet 2          octet 3
    -------------     ----------- ----------------- -----------------
    Note off                8x    Key number        Note off velocity
    Note on                 9x    Key number        Note on velocity (0 implies note off)
    Polyphonic Key Pressure Ax    Key number        Amount of pressure
    Control Change          Bx    Controller number Controller value
    Program Change          Cx    Program number    None
    Channel Pressure        Dx    Pressure value    None
    Pitch Bend              Ex    MSB               LSB
    The MIDI controller I use sends "note on" with 0 velocity as a "note off"
  */
  self.midi = function (msg) { // TODO This should not be here
    //DB.post("PianoKeyboard", msg.data);
    var d = msg.data;
    var cmd = d[0];
    var key = d[1];
    if ((0x90 + 0 <= cmd) && (cmd <= 0x90+15) // channel 0..15
        && (keyStart <= key) && (key < keyStart + keyCount)) {
      if (d[2] == 0) {
        keyRelease(key);
      } else {
        keyPress(key);
      }
    }
  }
} // PianoKeyboard


/******************************************************************************
//  CTX Destinations
//
//  Manage audio destinations including the main context and any filters.
//
//  Usage::
//    Destinations[0].input()    // Get main CTX input.
//    Destinations.push(filter)) // Add a new filter object
//    Destinations.cut())        // Add a new filter object
//
******************************************************************************/
var Destinations = (function (ctx) {
  let self = [];
  let vol = 0.5;

  var fuse = ctx.createGain();
  fuse.name = function () { return "ctx"; };
  fuse.input = function () { return fuse; };
  fuse.connect(ctx.destination);
  self.push(fuse);

  self.name = function (i) { return self[i].name(); }
  self.input = function (i) { return self[i].input(); }
  self.nextId = function (id) {
    let ret = (id+1) % self.length;
    return ret;
  }
  self.next = function (d) { // Return destination after d in array.
    var i = 1 + self.findIndex( function (v,i) { return d== v.input(); } )
    return self[i % self.length];
  }
  self.index = function (d) { // Return index of the destination object
    var i = self.findIndex( function (v,i) { return d==v || d==v.input(); } )
    return (0 <= i) ? i : 0;
  }
  self.cut = function () {
    let oldVol = fuse.gain.value;
    // Silence current gainf use
    fuse.gain.setValueAtTime(0, ctx.currentTime);
    fuse.disconnect(ctx.destination);

    // Create new fuse gain and connect to CTX
    fuse = self[0] = ctx.createGain();
    fuse.gain.value = oldVol;
    fuse.name = function () { return "ctx"; };
    fuse.input = function () { return fuse; };
    fuse.connect(ctx.destination);

    // Sweep through for any filters that are connected to a filter
    // that doesn't match the filter in this array.  Update them.  Repeat.
    // For a filter like delay which can continue to produce samples, a new
    // one needs to be created and the exisintg one replaced.  This algorithm
    // will run again and update any filters depending on it until all filters point
    // to a filter in this array.

    // get reconnected to new fuse;
    var updateCount = 0;
    while (updateCount < self.length) { // Sanity check: Don't expect to update more filters than exists
      var updated = false;
      self.slice(1).forEach( (filter, i) => {
        if (filter.connect()) { // Recreates this filter if it's not connected to something not in this destination object
          //DB(`Reconnected ${i} ${filter.name()} to ${filter.dest()}`);
          ++updateCount;
          updated = true;
        }
      });
      if (!updated) { break; }
    }
    DB.check(updateCount < self.length, "Updated more filters than exists");

  }

  return self;
})(ctx);

/******************************************************************************
  Database of Web Audio audio buffers.  It will download and convert raw audio
  files into ready to use AudioBuffers.

  USAGE::
    var noises = new AudioBuffers(filenames)

  METHODS::
    noises.length          Number of files specified.
    noises.fileName(i)     Get a filename.
    noises.audioBuffer(i)  Get an audio buffer or undefined.
******************************************************************************/
var AudioBuffers = function (ctx, filenames) {
  //// Private
  var _audioBuffers = [];

  function _Validate () {
    if (!DB.check(filenames && Array.isArray(filenames), "ERROR: AudioBuffersdb: Invalid filenames ary.")) {
      filenames = [];
    }
  }

  function _loadRawAudioFiles () {
    let count=0;
    filenames.forEach(function (fn, i) { // forEach passes in each ary element and the index.
      var client = new XMLHttpRequest();
      client.open('GET', fn);
      client.responseType = "arraybuffer";
      client.onreadystatechange = // Callback after remote file has been loaded
        function (e) {
          if (4 != client.readyState) { return; }
          var statusState = ((200 == client.status) || (0 == client.status) && (null != client.response)); // When loaded locally with --allow-file-access-from-files, status is 0 so must check client.response instead
          DB.check(statusState, "ERROR: AudioBuffers: " + client.status + " '" + (client.responseURL || fn) + "'");
          if (statusState) {
            //DB.post("AudioBuffers", `${i}/${filenames.length} ${fn}`);
            if (++count == filenames.length) {
              DB.post("AudioBuffers", `${count} files acquired`);
            }
            //DB.log("LOADED " + fn);
            var samples = new Int16Array(client.response); // Consider u8 ary as s16 ary.
            // Normalized each s16 sample to f32 between -1 and 1.
            var Noise =  new Float32Array(samples.length);
            for (var j=0; j<samples.length; ++j) {
              Noise[j] = samples[j]/32768;
            }
            // Create and set the audio buffer
            _audioBuffers[i] = ctx.createBuffer(1, samples.length, 44100);
            _audioBuffers[i].getChannelData(0).set(Noise);
          } // if
        } // function()
      client.send();
    }); // forEach function
  } // function

  //// Construct

  _Validate();
  _loadRawAudioFiles();

  //// Public

  this.length = filenames ? filenames.length : 0;
  this.fileName = function (i) { return filenames[i]; }
  this.fileNameCompact = function (i) {
    let fn = filenames[i].slice(0, -4); // Strip trailing ".raw"
    let firstDot = fn.indexOf(".");
    return (0 <= firstDot) ? fn.slice(firstDot+1) : fn;
  }
  this.audioBuffer = function (i) { return _audioBuffers[i]; }
} // AudioBuffers


/******************************************************************************
  Create a playable drumkit.  Expects a webaudio context and list of assets to
  acquire and cache into an AudioBuffer collection.

  USAGE::
    var dk = new Drumkit(ctx, color, keyStart, audioBuffers);

  CONSTRUCTOR PARAMETERS::
    ctx           An web audio context and audio buffers object.
    color         Highlight color
    keyStart      The first MIDI key/note the drumkit is mapped to
    audioBuffers  Playable sound samples

  METHODS::
    .length                    Number of reserved buffers
    .name(pad)                 String describing the pad.  Usually the drum sound.
    .color                     Color associated with this object
    .play(pad, vol, when)      Plays an audiobuffer sample specified by pad at
                               volume vol at time when or now if when==0.
    .connect(destination, idx) Set destination to destination
    .connected(idx)            Get destination to destination
******************************************************************************/
var Drums = []; // Array of instantiated drumkits.
var Drumkit = function (ctx, label, color, keyStart, filenames) {
  //// Local
  let self = this;
  let _name = label || ("Drumkit" + ++SynthGlobalCounter);
  let audioBuffers = new AudioBuffers(ctx, filenames)
  let bassRel = 1.0; // Release time in seconds for both the filter and gain.
  var destinations = Array(audioBuffers.length).fill(0); // Default destination of each sound to default
  var volumes = Array(audioBuffers.length).fill(1.0); // Default volumes
  var _ibcId = false;
  var chanIn = 3;

  // Element []
  var _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";
  ElementById('drums').appendChild(_element);

  // [Drumkit1]
  var _nameDOM = CreateAppendChild('div', _element); // [ Synth1 ]
  _nameDOM.style.background="";
  _nameDOM.innerText = _name;

  // [Drumkit1 []]
  var knobs = CreateAppendChild('div', _element); // [ Synth1 [ ] ]

  // [Drumkit1 [3]]
  let midi = CreateAppendChild('p', knobs, chanIn);
  midi.title = "CHANNEL IN";
  midi.className="actor";
  midi.onmousedown = (e) => {
    if (e.button == 0) { 0<chanIn && --chanIn; };
    if (e.button == 2) { chanIn<15 && ++chanIn; };
    midi.innerText = chanIn;
  };

  // [Drumkit1 [3]]
  // [            ]
  let buttons = CreateAppendChild('div', _element);
  buttons.className = "knobs";

  // [Drumkit1 [3]  ]
  // [ctx [vol] drum]
  // ...
  RangeForEach(audioBuffers.length, (k)=> {
    k = audioBuffers.length - k - 1;
    let _output = CreateAppendChild('p', buttons, Destinations.name(destinations[k]));
    _output.className = "volume"; // "actor"
    _output.innerText = Destinations.name(destinations[k]);
    _output.onmousedown = function (event) {
      if (++destinations[k] == Destinations.length) { destinations[k] = 0; }
      _output.innerText = Destinations.name(destinations[k]);
    };

    Knobify(CreateAppendChild('p', buttons, "VOL"), (v)=>(volumes[k]=v/100, Round(v)), volumes[k]*100).title="DRUM VOLUME";

    if (0==k) {
      Knobify(CreateAppendChild('p', buttons, "REL"), (v)=>(bassRel=v/100, Round(v)), volumes[k]*100).title="BASS DRUM RELEASE";
    }

    let drum = CreateAppendChild('p', buttons, audioBuffers.fileNameCompact(k));
    drum.className = "hit";
    drum.onmousedown = ()=> self.play(k+keyStart, 1.0, 0);

    CreateAppendChild('br', buttons);
  });

  // Behavior

  // Drumkit message handler:  play/stop a note [chan note vol time sus]
  let listenerIBC = (m) => m[0]==chanIn && self.play(m[1], m[2], m[3]);

  (_nameDOM.onmousedown = function () {
    if (_nameDOM.style.background == "") {
      _nameDOM.style.background="#880";
      _ibcId = IBC.addListener(listenerIBC);
    } else {
      _nameDOM.style.background="";
      _ibcId = IBC.delListener(_ibcId);
    }
  })(); // Toggle the synths on and listening to MIDI

  // Object
  Drums.push(this);
  this.length = audioBuffers.length;
  this.name = (key) => (undefined == key) ? "TR-808" : audioBuffers.fileNameCompact(key-keyStart);
  this.rowClass = (_key) => "drumkit";
  this.title = (key) => `${key} ${this.name(key)}`;
  this.color = color
  this.play = function (pad, vol, when) {
    let key = pad - keyStart;
    let audioBuffer = audioBuffers.audioBuffer(key);
    if (!audioBuffer) {
      DB.error(`Drumkit.play offset ${pad} expect ${keyStart}..${keyStart+this.length-1}`);
      return; // Do nothing if no audio buffer.
    }
    var source = ctx.createBufferSource();
    source.buffer = audioBuffer;
    source.onended = function() { source.disconnect(); } // When the audio stops, remove it from the graph.
    var gain = ctx.createGain(); // Ramp
    vol *= volumes[key]; // Combine incoming message note vol with drumkit's volume.
    if (key == 0) { // HACK: need to generalize a sound pipeline
      var now = (when || ctx.currentTime); // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
      // Loop the bass noise for one second with a LPF and gain ramp.
      source.playbackRate.setValueAtTime(0.39, now);
      source.playbackRate.linearRampToValueAtTime(0.38, now+bassRel);
      source.loop = true;
      source.start(when);
      source.stop(now + bassRel);

      var lp = ctx.createBiquadFilter(); // LPF
      lp.type = "lowpass";
      lp.frequency.value = 100;
      lp.Q.value = 0.5;

      gain.gain.setValueAtTime(vol, now);
      gain.gain.linearRampToValueAtTime(0, now+bassRel);

      source.connect(lp);
      lp.connect(gain);
    } else {
      gain.gain.value = vol;
      source.connect(gain);
      source.start(when);
    }

    gain.connect(Destinations.input(destinations[key]));
  }
  this.connect = function (dest, idx) { destinations[idx] = dest; }
  this.connected = function (idx) { return destinations[idx]; }

} // Drumkit


/* MIDI key and frequency manager

   Octaves begin at note C.  MIDI begins (key 0) on octave -1, note C
   88 key piano start at octave 0, note A (just 3 notes in octave 0: A A# B).
   Key 21 (A-natural sub-contra-octave) is set to the base frequency

  Key Note Freq            Key Note Freq
    0 C-1  8.1758             69 A4   440/Middle A
    9 A-1 13.75               81 A5   880
   21 A0  27.5 88PianoStart   93 A6  1760
   33 A1  55                 105 A7  3520
   45 A2 110                 108 C8  4186.0090 88PianoEnd
   57 A3 220                 117 A8  7040
   60 C4 261.6256/MidC       127 G9 12543.8540
*/
var KeyFreq = function (freqa0) {
  // Generate able of base frequency multipliers
  let keymult = RangeMap(128, (k) => Pow(2, (k-21)/12.0));
  let self = (k, f) => keymult[k] * (f || freqa0);// + Rnd()*0.5 - 0.25;
  self.setFreqA0 = (f) => freqa0=f;
  self.freq = () => freqa0;
  return self;
}(27.5);

DB.check( KeyFreq(21)==27.5, "KeyFreq frequency mismatch key 21 != 27.5Hz");
DB.check( KeyFreq(69)==440, "KeyFreq frequency mismatch key 69 != 440Hz");
DB.check( KeyFreq(105)==3520, "KeyFreq frequency mismatch key 105 != 3520Hz");
DB.check( KeyFreq(117)==7040, "KeyFreq frequency mismatch key 117 != 7040Hz");


/******************************************************************************
  Create a playable synthesizer.

  USAGE::
    var Synth = new Synthesizer(ctx, keyboard, color);

  CONSTRUCTOR PARAMETERS::
    ctx      A web audio context.
    keyboard An instantiated keyboard object
    color    DOM color

  METHODS::
    .element              This object's element
    .color                Color associated with this object
    .name(key)            Name associated with this key.  Default is the synth waveform name, each key.
    .adsr()               Get ADSR values in array
    .attSet(att)          Set new attack value 0.0-1.0.
    .susSet(sus)          Set new sustain value 0.0-1.0.
    .relSet(rel)          Set new release value 0.0-1.0.
    .play(key, vol, when) Plays a waveform at a freq determined by the Keyboard object at the
                          specified key, at webaudio context time 'when' or immediately if when==0.
    .wave()               Get current waveform index..
    .waveform()           Get current waveform string.
    .highlight(key)       Highlight the keyboard object's key with my color.  Used when playing a note.  TODO:  Is this smrt?
    .unhighlight()        Remove my highlight from the keyboard object.
    .destination()        Return output destination

  EVENTS::
    The name element will toggle receiving MIDI messages via IBC
******************************************************************************/
var SynthGlobalCounter = 0;
var Synthesizers = [];
var Synthesizer = function (ctx, label, type, keyboard, color) {
  //// Local
  var self = this;
  var _ibcId = false;
  var _name = label || ("Synth" + ++SynthGlobalCounter);
  var _att = 0.01; // Attack time in seconds.
  var _sus = 0.01;
  var _rel = 0.50; // Release time in seconds for both the filter and gain.
  var _waveforms = ["sine", "square", "sawtooth", "triangle"];
  var _waveformIdx = type;
  var _filterIdx = 0;
  var _volume = 0.5;
  var chanIn = 4;
  var _mouseMoved;
  var _freq=27.5;

  var _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";

  var _nameDOM = CreateAppendChild('div', _element); // [ Synth1 ]
  _nameDOM.style.background="";
  _nameDOM.innerText = _name;

  var knobs = CreateAppendChild('div', _element); // [ Synth1 [ ] ]

  let midi = CreateAppendChild('p', knobs, chanIn);
  midi.title = "CHANNEL IN";
  midi.className="actor";
  midi.onmousedown = (e) => {
    if (e.button == 0) { 0<chanIn && --chanIn; };
    if (e.button == 2) { chanIn<15 && ++chanIn; };
    midi.innerText = chanIn;
  };

  /*
  var _delSynth = CreateAppendChild('p', knobs);  // [ Synth1 [-] ]
  _delSynth.className="actor mustshift";
  _delSynth.innerText = "-";

  // Remove synth only if not not used in any of the synth parts in any of the phrses and not one of the original 4 synths.
  _delSynth.onmousedown = function () {
    // Never remove the first four synths as they are used when creating a new phrase. TODO: remove this dependency
    var count=0;
    var synthIndex = Synthesizers.indexOf(self);
    if (synthIndex < 4) { return; }
    // Count synth usage in all parts of all phrases.
    Sheet0.phrases.map(function(ph){ ph.parts.map(function(pt){ if (self == pt.playable) ++count; }); });
    if (0 < count) { return; }
    Synthesizers.splice(synthIndex, 1);
    document.getElementById('synths').removeChild(_element); // Remove myself from DOM
  }
  */

  var _body = CreateAppendChild('div', _element);//  [ Synth1 [-] ]
  _body.className = "knobs";                     //  [            ]


  // Waveform button
  // [ FREQ [sine] ]
  Knobify(
    CreateAppendChild('p', _body, "FREQ"),
    (v)=>(_freq=v, Trunc1(v)),
    _freq, .01, 1, 100,
    [440, 220, 110, 55, 27.5, 13.75]
  ).title = "BASE FREQ";
  var _waveformDOM = CreateAppendChild('p', _body)
  _waveformDOM.className = "actor";
  _waveformDOM.title = "OSCILLATOR";
  _waveformDOM.innerText = _waveforms[_waveformIdx];
  _waveformDOM.onmousedown = function () {
    if (_waveforms.length == ++_waveformIdx) _waveformIdx=0;
    _waveformDOM.innerText = _waveforms[_waveformIdx];
  }


  // Knobs
  // [ [27.5][sine][-]]
  // [ ATT SUS REL    ]
  // [ VOL [ctx]      ]
  CreateAppendChild('br', _body);
  Knobify(CreateAppendChild('p', _body, "ATT"), (v)=>(_att=v/100, Round(v)), _att*100).title="ATTACK";
  Knobify(CreateAppendChild('p', _body, "SUS"), (v)=>(_sus=v/100, Round(v)), _sus*100).title="SUSTAIN";
  Knobify(CreateAppendChild('p', _body, "REL"), (v)=>(_rel=v/100, Round(v)), _rel*100).title="RELEASE";
  CreateAppendChild('br', _body);
  Knobify(CreateAppendChild('p', _body, "VOL"), (v)=>(_volume=v/100, Round(v)), _volume*100, .1, 0, 100, [100, 80, 50, 20, 0]).title="VOLUME";

  // Destination
  // [ [27.5][sine][-]]
  // [ ATT SUS REL    ]
  // [ VOL [ctx]      ]
  var _output = CreateAppendChild('p', _body);
  _output.style.position = "relative"
  _output.className = "volume"
  _output.innerText = Destinations.name(_filterIdx);
  _output.onmousedown = function (event) {
    if (++_filterIdx == Destinations.length) { _filterIdx = 0; }
    _output.innerText = Destinations.name(_filterIdx);
  }

  var _play = function (key, vol, when, sustain) {
    //DB.post("_play", [key, vol, when, sustain]);
    // Depending on how this is called (when is either 0 or a time in the
    // future) now will be the current time or when
    var sus = _sus + (sustain ? sustain*TickerTimer.jiffy() : 0);
    var at = !when ? ctx.currentTime : when;
    var osc = ctx.createOscillator(); // Create and add to table if not already
    // Adding a random [0..1] value to the freq in an attempt to get rid of beating.
    // Ended up with a phaser effect when equal notes are played instead.
    osc.frequency.value = KeyFreq(key, _freq);
    osc.type = _waveforms[_waveformIdx];
    osc.onended = function(osc){ osc.disconnect(); }.bind(null, osc);
    osc.start(at);
    osc.stop(at + _att + sus + _rel);

    //DB.post("ASR", [_att, sus, _rel]);
    var gain = ctx.createGain();
    gain.gain.setValueAtTime(0, at);
    gain.gain.linearRampToValueAtTime(vol*_volume, at + _att);
    gain.gain.setValueAtTime         (vol*_volume, at + _att + sus);
    gain.gain.linearRampToValueAtTime(          0, at + _att + sus + _rel);

    osc.connect(gain);
    gain.connect(Destinations.input(_filterIdx));
  }

  var playing = [];
  var _playStart = function (key, vol) {
    var at = ctx.currentTime; // Start now
    var osc = ctx.createOscillator();
    osc.frequency.value = KeyFreq(key, _freq);
    osc.type = _waveforms[_waveformIdx];
    osc.start(at);
    osc.onended = function(osc){ osc.disconnect(); }.bind(null, osc);

    var gain = ctx.createGain();
    gain.gain.setValueAtTime(0, at);
    vol *= _volume;
    at += _att;
    gain.gain.linearRampToValueAtTime(vol, at);

    osc.connect(gain);
    gain.connect(Destinations.input(_filterIdx));

    playing[key] = [osc, gain, vol, at]; // Keep track of this oscillator and envelope
  }

  var _playStop = function (key) {
    if (playing[key] == undefined) { return; }

    var osc = playing[key][0]; // Recover osc and gain
    var gain = playing[key][1];
    var vol = playing[key][2];
    var at = Max(playing[key][3], ctx.currentTime);
    playing[key] = undefined;

    gain.gain.setValueAtTime(vol, at);
    at += _rel;
    gain.gain.linearRampToValueAtTime(0, at);
    osc.stop(at);
  }

  // Synthesizer message handler:  play/stop a note
  let listenerIBC = function (m) {
    let [chan, note, vol, time, sus] = m;
    if (chan != chanIn) { return; }
    if (sus != null) {
      _play(note, vol, time, sus); // One shot probably from sequencer to render entire ADSRd sound
    } else if (0===vol) {
      _playStop(note, vol);
    } else {
      _playStart(note, vol);
    }
  };

  (_nameDOM.onmousedown = function () {
    if (_nameDOM.style.background == "") {
      _nameDOM.style.background="#880";
      _ibcId = IBC.addListener(listenerIBC);
    } else {
      _nameDOM.style.background="";
      _ibcId = IBC.delListener(_ibcId);
    }
  })(); // Toggle the synths on and listening to MIDI

  Synthesizers.push(this);

  //// Public
  this.element = _element;
  this.color = color
  //this.name = function () { return _name; }
  this.adsr = function () { return [parseInt(_att*255), 0, parseInt(_sus*255), parseInt(_rel*255)]; }
  this.attSet = function (att) { _att = att/255.0; }
  this.susSet = function (sus) { _sus = sus/255.0; }
  this.relSet = function (rel) { _rel = rel/255.0; }
  this.play = _play;
  this.wave = function () { return _waveformIdx; }
  this.waveform = function () { return _waveforms[_waveformIdx]; }
  var _lastKey = -1;
  this.highlight = function (key) {
    keyboard.unhighlight(_lastKey, color); // Remove last high-light
    keyboard.highlight(key, color); // Set new high-light
    _lastKey = key
  };
  this.unhighlight = function () {
    keyboard.unhighlight(_lastKey, color); // Remove last high-light
  };
  this.destination = function () { return _filterIdx; };

  this.name = function (key) {
    let note = key%12;
    let octave = Floor((key-12)/12); // MIDI octaves start at C-1 up to G9
    let noteLabel = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'][note];
    let nat = 1 == noteLabel.length; // Natural notes are 1 char long
    return nat ? noteLabel + (0==note?octave:"") : NBSP;
  }
  this.rowClass = function (key) {
    let note = key%12;
    let noteLabel = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'][note];
    let nat = 1 == noteLabel.length; // Natural notes are 1 char long
    return noteLabel.charAt(0) + (nat ? " nat" : " shp");
  }
  this.title = function (key) {
    let note = key%12;
    let octave = Floor((key-12)/12); // MIDI octaves start at C-1 up to G9
    let noteLabel = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'][note];
    return `${Trunc2(KeyFreq(key))}Hz  ${key}  ${noteLabel}${octave}`;
  }

} // Synthesizer



/******************************************************************************
  Create a single channel delay filter

  USAGE::
    var delay = Delay();

  CONSTRUCTOR PARAMETERS::
    ctx      A web audio context.

  METHODS::
    [n]         Get nth delay object
    .element    This object's element
    .name(key)  This filter's name
    .input()    Get the input port
    .export()   Return byte aray representing this instance.
******************************************************************************/
var Delay = (function (ctx, destinations) {
  //// Local
  let _name = "delay";
  let _del = 0.40; // Delay time
  let _gai = 0.50; // Attenuation

  let _destId = 0;
  let _destination;
  let _delay;
  let _gain;

  let make = function () {
    _gain  = ctx.createGain();
    _delay = ctx.createDelay(1);
    _delay.connect(_gain);
    _delay.delayTime.value = _del;
    _gain.gain.value = _gai;
    _gain.connect(_delay);
    _destination = Destinations.input(_destId); // Initial destination is global destination
    _gain.connect(_destination);
  };

  make();

  var _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";
  //_element.style.width = "13ch";

  var _nameDOM = CreateAppendChild('div', _element); // [ Delay1 ]
  _nameDOM.style.background="";
  _nameDOM.innerText = _name;

  var knobs = CreateAppendChild('div', _element); // [ Delay1 [ ] ]

  var _delSynth = CreateAppendChild('p', knobs);  // [ Delay1 [-] ]
  _delSynth.className="actor mustshift";
  _delSynth.innerText = "-";

  var _body = CreateAppendChild('div', _element);//  [ Delay1 [-] ]
  _body.className = "knobs";                     //  [            ]

  // Delay button
  // [ [Delay1] [-] ]
  // [ [delay]      ]
  // [ DLY ATN      ]
  // [ [main]       ]
  Knobify(CreateAppendChild('p', _body, "DLY"), (v)=>(_del=v/100, _delay.delayTime.value=_del, Round(v)), _del*100).title="DELAY";
  Knobify(CreateAppendChild('p', _body, "ATN"), (v)=>(_gai=v/100, _gain.gain.value=_gai, Round(v)), _del*100).title="ATTENUATION";
  CreateAppendChild('br', _body);
  var _output = CreateAppendChild('p', _body);
  _output.style.position = "relative"
  _output.className = "volume"
  _output.innerText = "[ctx]"
  _output.onmousedown = (event)=>self.connect(Destinations.nextId(_destId));

  // Public
  let self = [];

  self.element = _element;
  self.name = function () { return _name; }
  self.input = function () { return _gain; }
  self.getParams = function () { return [_del, _gai]; }
  self.setParams = function (ps) {
    _delay.delayTime.value = _del = ps[0];
    _gain.gain.value = _gai = ps[1];
  }
  // NEW
  self.dest = function () { return _destId; }
  // Update destination to passed in filter index otherwise update destination
  // if it changed in the filter stack.  Return true if a change occurred.
  self.connect = function (d) {
    if (d == null) {
      if (_destination != Destinations.input(_destId)) {
        make();
        return true;
      }
    } else {
      _gain.disconnect(_destination); // Is this needed?
      _destId = d;
      _destination = Destinations.input(_destId);
      _gain.connect(_destination);
      _output.innerText = Destinations.name(_destId);
    }
    return false;
  }
  self.export = function () {
    var bytes = [0]; // TYPE
    bytes.push(_name.length); // NAME LEN
    //DB("LK3 Filter " + d.name());
    _name.split('').map(b=>bytes.push(b.charCodeAt(0))); // NAME
    bytes.push(0); // Fake filter type.  for now the static delay and lowpass filters
    //DB("Params to write:" + ps);
    bytes.push(2);
    bytes.push(parseInt(_del*255.0));
    bytes.push(parseInt(_gai*255.0));
    return bytes;
  }
  Destinations.push(self);
  return self;
}).bind(null, ctx, Destinations); // Delay


/******************************************************************************
  Create a single channel lowpass filter

  USAGE::
    var delay = new Lowpass(ctx);

  CONSTRUCTOR PARAMETERS::
    ctx      A web audio context.

  METHODS::
    .element    This object's element
    .name()     This filter's name
    .input()    Get the input port
******************************************************************************/
var Lowpass = function (ctx, destinations) {
  //// Local
  let _name = "lp";
  let _f = .9; // Frequency
  let _q = 0.0; // Q this just resonates annoyingly when not 0
  let _destId = 0;
  let _destination;
  let _lowpass;

  let make = function () {
    _lowpass = ctx.createBiquadFilter();
    _lowpass.frequency.value = 10000.0*(1.0-_f);
    _lowpass.Q.value = _q * 100.0;
    _destination = Destinations.input(_destId);
    _lowpass.connect(_destination); // New
  };
  make();

  var _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";
  //_element.style.width = "13ch";

  var _nameDOM = CreateAppendChild('div', _element); // [ lowpass ]
  _nameDOM.style.background="";
  _nameDOM.innerText = _name;

  var knobs = CreateAppendChild('div', _element); // [ lowpass [ ] ]

  var _delSynth = CreateAppendChild('p', knobs);  // [ lowpass [-] ]
  _delSynth.className="actor mustshift";
  _delSynth.innerText = "-";

  var _body = CreateAppendChild('div', _element);//  [ lowpass [-] ]
  _body.className = "knobs";                     //  [            ]

  // Lowpass Buttons
  // [ [lp] [-] ]
  // [ FRQ      ]
  Knobify(
    CreateAppendChild('p', _body, "FRQ"),
    (v)=>{
      var osc = ctx.createOscillator();
      osc.frequency.value = 0;
      osc.start(0);
      osc.stop(ctx.currentTime+.05);  // 1/20th of a sec should be long enough
      osc.onended = ()=>osc.disconnect();
      osc.connect(_lowpass);
      _f=v/100;
      _lowpass.frequency.value = 10000.0*(1.0-_f);
      return Round(v);
    },
    _f*100
  ).title="DELAY";

  //// Public
  let self = [];
  self.element = _element;
  self.name = function () { return _name; }
  self.input = function () { return _lowpass; }
  self.getParams = function () { return [_f, _q]; }
  self.setParams = function (ps) {
    _f = ps[0];
    _lowpass.frequency.value = 10000.0*(1.0-_f);
    _q = ps[1];
    _lowpass.Q.value = _q * 100.0;
  }
  // NEW
  self.dest = function () { return _destId; }
  // Update destination if it changed in the filter stack.  Return true if a change occurred.
  self.connect = function () {
    if (_destination != Destinations.input(_destId)) {
      _lowpass.disconnect(_destination); // Is this needed?
      make();
      return true;
    }
    return false;
  }
  self.export = function () {
    var bytes = [0]; // TYPE
    bytes.push(_name.length); // NAME LEN
    //DB("LK3 Filter " + d.name());
    _name.split('').map(b=>bytes.push(b.charCodeAt(0))); // NAME
    bytes.push(1); // Fake filter type.  for now the static delay and lowpass filters
    //DB("Params to write:" + ps);
    bytes.push(2);
    bytes.push(parseInt(_f*255.0));
    bytes.push(parseInt(_q*255.0));
    return bytes;
  }
  Destinations.push(self);
  return self;
}.bind(null, ctx, Destinations); // Lowpass


/******************************************************************************
  TickerTimer - Manage ticks and time

  The default behavior is to return [tick, time] representing the
  current tick to process and at what future time.

  Ticks represent periodic time units that need to be sequentially
  considered when creating and emitting audio on time.  This will
  make sure enough ticks have been processed so that there is at most
  1 second of audio processed.

  Start rendering just a bit after currentTime?  No, doesn't seem to be
  a problem and a delay before starting is annoying anyways.

     ...---------------------------...
           ^  ^=========^=========^======== <samples written
 currentTime  tick0time tick1time lastTime
              ^render0

  tickCued   =  0;  -1     -1     -1    -1      -1
  let tick   = -1;  0      1      2      3      3
  let time   = -1;  100.25 100.50 100.75 101.00 101.00   (time+jiffy) - CurrentTime should be a second

  renderedCued = 0
  tickRender = -1;  -1     -1     -1     -1     0

          calls                     ctx.currentTime
  tickNext() => [0, 100.25]             100.00
  tickNext() => [1, 100.50]             100.10
  tickNext() => [2, 100.75]             100.15
  tickNext() => [3, 101.00]             100.19
  tickNext() => false                   100.20  when currentTime is over
  tickRender() => 0                     100.21
  tickRender() => false                 100.30
  tickRender() => 1                     100.32
  tickNext() => [4, 101.25]             100.35

  Idea:  base tick on CurrentTime - Time of last "first" tick.  The math will be just a sub and div

  New Version:  Provides incremental beat ranges to process/render.

******************************************************************************/
var TickerTimer = (function (ctx) {
  let margin = 0.1; // seconds to start processing/sending audio (in case that's a problem)
  let lead  = 1.0; // Audio pre-buffer length in seconds

  let bpm   = 60;
  let subs  = 1; // beat subdivisions (in ticks)

  let start =  4; // start tick
  let end   = 12; // end tick (exclusive)
  let range = end - start; // range processed

  // Dynamic state
  let playCallback = null;
  let paused = true;

  let epoch = -1; // real time we started aligned with start tick
  let time  = -1; // last time (exclusive) processed, usually ahead of now()

  let tickCue = 0;
  let renderCue = 0;

  let render    = -1; // last time rendered

  let state = "reset"; // pause reset running

  /* Last emitted time +jiffy - CurrentTime / jiffy -> number of ticks back from tick the real time tick count is */
  var _pause = function (e) {
  }

  // Debugging message
  let self = function (f, r) {
    //DB.post("next Tick", `${paused} ${tickCue} ${tick} ${time}   ${now}   ${renderCue} ${render} => ${r} ${f?"RRRRRRR":"ttt"} `);
    return r;
  };
  self.registerPlayCallback = function (f) { playCallback = f; }

  // Request the next tick and time to render it.  False implies not ready.
  self.nextTick = function () {
    let now = ctx.currentTime;

    switch (state) {
    case "pause":
      time = now;
      return false;
    case "resume":
      epoch += now - time + margin; // adjust epoch by how long paused
      time = now + margin;
      state = "running";
      break;
    case "reset":
      epoch = now + margin;
      time = epoch;
      state = "running";
      break;
    }

    // case "running"

    if (now + lead <= time) { // Buffer full, skip rendering
      //ElementById("info").innerText = Trunc2(time-now);
      return false;
    }

    let tickDuration = 60 / bpm / subs; // 1/8
    //DB.log(`bpm:${bpm}  tickDurtion:${tickDuration}  time-epoch/tickDuration:${(time-epoch)/tickDuration}`);

    let timeCurrent = time - epoch;
    let tickCurrent = Round(timeCurrent / tickDuration);
//DB.log(`end:${end} tickCurrent:${tickCurrent}`);
    while (range <= tickCurrent) {
      tickCurrent -= range;
      epoch += range*tickDuration;
      timeCurrent = time - epoch;
    }
    let tickNext = tickCurrent + 1;
    let timeNext = tickNext * tickDuration;
    time = epoch + timeNext;
    return [start+timeCurrent, start+timeNext];
  }; // nextTick()


  // Request the next rendering tick.  False implies tick hasn't moved.
  self.nextRender = function () {
    let ret = false;  // Default return value
    if (renderCue != -1) { // Cued (running or paused)...
      if (renderCue != render) { // Update with cue.
        render = renderCue;
        ret = render;
      } // Skip, already on cue.
      renderCue = -1;
    } else if (!paused) { // Normal running...
      let currentTick = self.currentTick();
      if (currentTick != render) { // Update with new tick.
        ret = render = currentTick;
      } // Skip, on same tick
    } // Paused,..always skip.
    return ret;
  }

  self.tick = self;
  self.pause     = function (e)  {
    if (paused = !paused) { // Did we switch into pause mode?
      tickCue = renderCue = self.currentTick(); // Force next tick and render to current realtime.
      Destinations.cut(); // halt external sound immediately
    } else {
      playCallback();
    }
    blinkify(e, paused&&"#f00");
  };
  self.setBpm   = function (b) { bpm=b; return bpm;};
  self.setSubs  = function (d) { subs=d; return subs;};
  self.setStart  = function (b, s) { if (b<=end) { start = i; length=end-start+1; if (paused) { tickCue = renderCue = start; } } return self; };
  self.setStart  = function (b) { if (b<=end) { start = b; length=end-start+1; if (paused) { tickCue = renderCue = start; } } return self; };
  self.setEnd    = function (i) { if (start<=i) { end = i; length=end-start+1; } return self; };
  self.rewind = function (e, newTick) { // Reset state so next tick is 0 and next time will be nowish.
    // Rewind to specified tick or the usual start tick
    tickCue = renderCue = (newTick == undefined) ? start : newTick;
    if (paused) { self.pause(e); }
    return self;
  };
  self.now = () => ctx.currentTime;
  // Derive the actual current tick to render (which will most likely have already been processed)
  // When deriving the live beat for DOM highlighting, must do so within the current active beat range
  // So the distance between (BeatTime - currentTime) / beatDuration is how beats to subtract from Beat
  // to get the live beat.  But if this is less than BeatInitial, mod the BeatRange to compensate..
  self.currentTick = function (adj) {
    let now = ctx.currentTime + (adj||0);
    //               |4.00 now4.12 2|4.25    3|4.5    4|4.75  5|5.00=TIME 6|
    //   time - now  = .88 % .25 = 3.52 ceil=4  tick- = 2
    //                           tick- = 2.48
    let ticksAhead = Floor(tick - (time - now) / jiffy);
    return Mod(ticksAhead-start, length)+start;
  }
  self.isPaused = function () { return paused; }
  self.lastTime = function () { return time + jiffy; }
  self.jiffy = function () { return jiffy; }
  self.bpm = function () { return bpm; }
  self.subs = function () { return subs; }
  self.getRange = function () { return [start, end]; }
  return self;
})(ctx); // TickerTimer

/*
 @...|...|...
 @..|..|..|..

0   1   2  3   .3'*4 = 1.3'
0  .25 .5 .75  .8*4 = 3.2
-------------
      4

*/

/******************************************************************************
  Sheet - Manage parts on a dynamic phrase/sheet.

  METHODS

    .playAllTicks(tick, time)  Play all notes in each part on this tick.

******************************************************************************/
var Sheet = function (id, tickertimer) {
  let element = ElementById(id);
  let children = element.children;
  let knobs = element.previousElementSibling;
  let columns = []; // Array of columns [ [header part ... ] ... ]
  let parts = []; // List of all Part objects created.  Their elements will be scattered about the ticks.
  let tickLastRender = 0;
  let markedTick = null;
  let beats = 0; // count of beats
  let subs = 0;  // count of sub ticks for every beats
  let tickCount = 0; // TODO invariant should be beats*subs

  // Object

  var self = function () { };
  self.element = function () { return element; }
  self.partAdd = function (p) { parts.push(p); return self; }
  self.subs = ()=>subs;

  self.partsResetZ = function () {
    parts.forEach( p => p.element().style.zIndex="" );
  }
  self.refreshHeader = function () {
    let [start, end] = self.getRange();
    for (var i=0; i < tickCount; i++) {
      columns[i].firstChild.style.backgroundColor = (i<start || end<i) ? "#444" : "";
    }
  }
  self.getRange = function () { return tickertimer.getRange(); }
  self.setStart = function (b) { tickertimer.setStart(b); self.refreshHeader(); return self; }
  self.setEnd = function (i) { tickertimer.setEnd(i); self.refreshHeader(); return self; }
  self.playAllTicks = function (tick, time) {
    parts
      .filter((p)=>p.isOnTick(tick)) // Get list of Parts that lay on this tick.
      .forEach((p)=>p.play(tick, time)); // Play its notes along its tick
  }

  self.tickerTimer = () => tickertimer;
  self.pause = function (e) { tickertimer.pause(e); }
  self.isPaused = () => tickertimer.isPaused();
  self.rewind = function (e) { tickertimer.rewind(e); }
  self.jump   = function (e) { tickertimer.rewind(e, markedTick); }

  self.tickWidth = () => children[0].getBoundingClientRect().width;
  self.winTicks = function () {
    // Zooming in Chrome alters these so they must be dynamically queried
    let tickWidth = self.tickWidth();
    let windowWidth = element.getBoundingClientRect().width;
    let visibleTickCount = Round(windowWidth / tickWidth);
    let leftVisibleTick = Round((element.scrollLeft) / tickWidth);
    let rightVisibleTick = Min(leftVisibleTick + visibleTickCount, children.length) - 1;
    return [leftVisibleTick, rightVisibleTick];
  };

  // Scroll (maybe) the grid so current tick is visible
  let state = 1; // 0:reset  1:center  2:fixed  3:stick
  let winTicksLast = [0, 0]; // DEBUGGING mark left/right visible ticks in sheet window
  let fixedOffset = 0;
  //let markersLast = [0, 0];
  self.render = function (tick) {

    let visible = self.winTicks();
    let winwidth = visible[1] - visible[0];

    let [tickLeft, tickRight] = self.getRange();
    let tickwidth = tickRight - tickLeft;

    let userScrolledWin = winTicksLast.cmp(visible);
    let ticksInWin = visible[0]<=tickLeft && tickRight <=visible[1];

    if (!ticksInWin) {
      // Did the user scroll the window? (the visible ticks don't match last render)
      if (!userScrolledWin) {
        if (visible[0]<= tick && tick <= visible[1]) {
          state = 2; // Scrolling while the current tick is visible will reposition the tick's highlight
          fixedOffset = tick - visible[0];
        } else {
          state = 3; // Scrolling the tick outside the visible window will disable automatic scrolling
        }
      }

      let newWinLeft = undefined;
      if (1 == state) {
        newWinLeft = Max( tick-visibleTickCount/2, self.getRange()[0] );
      } else if (2 == state) {
        newWinLeft = Max( tick-fixedOffset, self.getRange()[0] );
      }

      //adjust newWinLeft so right side of window is at right tick
      if (tickRight < newWinLeft + winwidth) {
        newWinLeft = tickRight - winwidth;
      }

      element.scrollLeft = newWinLeft * self.tickWidth(); // Update window scroll position.
    }

    // Highlight the full vertical tick
    children[tickLastRender].className="";
    children[tick].className="phrasehighlight";

    // Remember state
    winTicksLast = self.winTicks();
    tickLastRender = tick;

    // DEBUGGING mark left/right visible ticks in sheet window
    //children[markersLast[0]].firstChild.style.textDecoration="";
    //children[markersLast[1]].firstChild.style.textDecoration="";
    //children[winTicksLast[0]].firstChild.style.textDecoration="underline";
    //children[winTicksLast[1]].firstChild.style.textDecoration="underline";
    //markersLast = winTicksLast;
    //DB.log("{a:\""+visible+"\", "); DB.log(" b:\""+visible+"\"}");
    // DEBUGGING
  }

  // Create a tick column and its top row tick mark. This is a dynamic placeholder for Parts.
  var lastHoverTick = 0;
  var hoverState = 0;
  self.createTick = function (beat, tick, label) {
    let column = document.createElement('div'); // Create the tick column
    column.className = "b"+beat+" t"+tick;

    let header = CreateAppendChild('p', column, label); // Add the tick header
    header.style.backgroundColor = "#444";

    // Hovering will play all ticks in each part.
    header.onmouseover = function () {
      if (tick == lastHoverTick) { hoverState=0; header.innerText = "*"; }
      else if (tick < lastHoverTick) { hoverState=-1; header.innerText = "<"; }
      else { hoverState=1; header.innerText = ">"; }
      lastHoverTick = tick;
      if (brushToPlay()) { self.playAllTicks(tick, 0); }
    };
    header.onmouseleave = function () {
      header.innerText = label;
    }

    header.onmousedown = function (e) { // Handle updating sheet's start/end playback ticks and repeat marker
      if (hoverState==1) { self.setEnd(tick); }
      else if (hoverState==0) {
        // Handle marked tick in phrase sheet's header
        if (markedTick != null) { columns[markedTick].firstChild.style.color = ""; }
        if (markedTick == tick) {
          markedTick = null;
        } else {
          columns[markedTick=tick].firstChild.style.color = "black";
        }
      } else {
        self.setStart(tick);
      }
    };
    tickCount++;
    return column;
  }; // self.createTick

  self.deleteSubbeats = function (cmd) {
    if (!subs) { return; }
    RangeForEach( beats, i=>{
      let tick = columns[i*subs+subs];
      tick.remove();
      columns.splice(i*subs+subs, 1);
    });
    subs--;
  }

  // [...document.styleSheets[0].cssRules].filter(e=>e.selectorText=='.sheet > div')[0].style.width = beatWidth + "ch";

  self.insertSubbeats = function (cmd) {
    let glyph = "-";
    //subs.push(splitCount); // subdivisions (initially 0)

    subs++;
    RangeForEach( beats, i=>{
      let tick = columns[i*(subs+1)+(subs-1)];

      //RangeForEach( splitCount-1, ii=>{
        let newTick = self.createTick(i, subs, glyph);

        tick.insertAdjacentElement('afterend', newTick);
        columns.splice(i*(subs+1)+subs, 0, newTick);
        //tick = newTick;
      //} );
    } );
  };

  self.beatWidth = function () { return subs+1; }

  self.appendBeat = function () {
    let tick = self.createTick(beats++, 0, 1+(beats-1)%8);
    columns.push(tick); // Keep track of the column
    element.appendChild(tick);
  };

  self.moveElement = (tick, element) => {
    while (!children[tick]) { self.appendBeat(); }
    children[tick].appendChild(element);
  };

  self.parts = () => parts;

  // Create new parts via button
  var _addpartdrum = document.getElementById('addpartdrum');
  _addpartdrum.children[1].onmouseup = function () { _addpartdrum.children[0].style.display=""; }
  _addpartdrum.children[0].onmouseleave = function () { _addpartdrum.children[0].style.display="none"; }
  document.getElementById('createphrasedrum').onmousedown = function () {
    DB("new drump part");
    var measures = document.getElementById('addmeasures').value;
    var beats    = document.getElementById('addbeats').value;
    var ticks    = document.getElementById('addticks').value;
    Part(self,  2, 2*20, 24, 16, measures*beats*ticks, Drums[0]);
    _addpartdrum.children[0].style.display="none";
  };

  var _addpartsynth = document.getElementById('addpartsynth');
  _addpartsynth.children[1].onmouseup = function () { _addpartsynth.children[0].style.display=""; }
  _addpartsynth.children[0].onmouseleave = function () { _addpartsynth.children[0].style.display="none"; }

  document.getElementById('createphrase').onmousedown = function () {
    DB("new synth part");
    var measures = document.getElementById('addmeasures').value;
    var beats    = document.getElementById('addbeats').value;
    var ticks    = document.getElementById('addticks').value;
    Part(self, 2, 2*20, 21, 88, measures*beats*ticks, Synthesizers[0]);
    _addpartsynth.children[0].style.display="none";
  };

  document.getElementById('zoom').onmousedown = function (a,b) {
    switch (event.target.innerText) {
      case "|": self.deleteSubbeats(); break;
      case "|-": self.insertSubbeats(); break;
    }
    parts.forEach(p=>p.updateBeatWidthInvariants());
  };

  // Add a brushToPlay toggle button
  let brushToPlay = AppendNewToggleActor(knobs, false, "actor",
    ()=>(columns.forEach(t=>t.firstChild.style.color=null), ")("),
    ()=>(columns.forEach(t=>t.firstChild.style.color="inherit"), "()"));
  brushToPlay.element().title="BRUSH PLAY";

  // Create a preliminary set of columns,
  // [ [[0]] [[1]] ... ]
  let extra = 8;
  RangeForEach(40+extra, self.appendBeat);

  // Reset the TickerTimer state object
  tickertimer
    .setStart(0)
    .setEnd(tickCount-1-extra);

  return self;
}; // Sheet


/******************************************************************************
  RefPart - References a Part.  Behaves the same as a part to a sheet.
******************************************************************************/
var RefPart = function (partObj, tickIdx, height) {
  let sheet = partObj.sheet();
  let sheetElement = sheet.element();
  let timer = sheet.tickerTimer();

  // Creat part window
  let ref = CreateAppendChild('div', sheetElement.children[tickIdx]);
  ref.className = "window";
  ref.style.top = Max(height, sheetElement.firstChild.firstChild.scrollHeight)+"px";

  // Header - left most cells of row
  let title = CreateAppendChild('div', ref, `*${partObj.titleName()}`);
  title.className = "actor";
  title.title = "MOVE,MINIMIZE";
  title.contentEditable = true;

  let knobs = CreateAppendChild('div', ref);
  knobs.className = "knobs";

  let body = CreateAppendChild('div', ref);
  body.className = "part";

  // Grid tick header
  let elHeaderTicks = CreateAppendChild('div', body);

  // Copy parent part's header
  RangeForEach( partObj.tickCount(), (tick) =>
    CreateAppendChild('p', elHeaderTicks, partObj.headerTick(tick))
      .onmouseover = () => brushToPlay() && partObj.playTick(tick, 0) );

  // Behavior

  // brushToPlay knob
  let brushToPlay = AppendNewToggleActor(knobs, false, "actor",
    () => (elHeaderTicks.style.color=null, ")("),
    () => (elHeaderTicks.style.color="inherit", "()"));
  brushToPlay.element().title="BRUSH PLAY";

  title.onmousedown = function (e) {
    if (e.button != 0) { return; }
    MouseIsDown = true; // Set global state

    self.focus();

    // Drag/Move part within sheet

    let tickHeight = sheetElement.firstChild.firstChild.scrollHeight+1;
    let tickWidth  = sheetElement.lastChild.offsetLeft / (sheetElement.childElementCount-1); // Tick width take average width of all ticks
    let leftMargin = sheetElement.offsetLeft-sheetElement.scrollLeft; // Account for element's margin and scrolled offset
    sheetElement.onmousemove = function (offset, e) {
       if (!MouseIsDown) { sheetElement.onmousemove = null; return; } // Maybe stop handling this event
       // Adjust ref's vertical position
       ref.style.top = Max(offset + e.y, tickHeight) + "px";
       // Adjust ref's horizontal position (Phrase's tick)
       let newTick = Floor((e.x-leftMargin+1) / tickWidth);
       if (newTick != tickIdx) {
         sheetElement.children[newTick].appendChild(ref);
         tickIdx = newTick;
       }
    }.bind(null, ref.offsetTop-e.y);
  };

  // Title editing.
  title.onkeydown = function (v) {
    event.stopPropagation(); // Don't bubble the event elsewhere (global controls),
    if (v.code == "Enter") {
      v.preventDefault(); // Prevent form element from adding a newline
    }
  }

  let self = ()=>{};

  self.element = () => ref;
  self.isOnTick = function (t) {
    return tickIdx <= t && t < tickIdx + partObj.tickCount();
  }
  self.play = (gtick, time) => {
    partObj.playTick(gtick - tickIdx, time);
  }
  self.focus = () => { // Raise/focus this element in sheet and reset others
    sheet.partsResetZ();
    ref.style.zIndex = 1;
  }

  sheet.partAdd(self);
  self.focus();

  return self;
}; // RefPart


/******************************************************************************
  Part

  Model a musical part which currently is a drawable grid of notes that are
  broadcast to anything listening on it's output channel.  It's basically a
  MIDI device.  It also has an input listener for similar note messages.

******************************************************************************/
var Part = function (sheetObj, tickIdx, height, keyBeg, keyCount, playable) {
  let chanIn  = 0;
  let chanOut = playable instanceof Synthesizer ? 4 : 3;
  let sheet = sheetObj.element(); // Parent object's element
  let timer = sheetObj.tickerTimer();
  let TickCount = 32;
  let divisions = [0]; // [beats, subdivisions...] IE [3 2 3] == @..-..@..-..@..-..

  // Creat part window
  // []
  let part = CreateAppendChild('div', sheet.children[tickIdx]); // The Part element
  part.className = "window";
  part.style.top = Max(height, sheet.firstChild.firstChild.scrollHeight)+"px";

  // Header - left most cells of row
  let title = CreateAppendChild('div', part, "Part");
  title.className = "actor";
  title.title="MOVE,MINIMIZE";
  title.contentEditable = true;

  let knobs = CreateAppendChild('div', part);
  knobs.className = "knobs";

  let body = CreateAppendChild('div', part);
  body.className="part";

  // Grid tick header IE  @.-.+.-.@.-.+.-.@.-.+.-.@.-.+.-.
  let elHeaderTicks = CreateAppendChild('div', body);

  elHeaderTicks.onmouseover = function () {
    if (brushToPlay()) {
      self.playTick(event.target.title, 0);
      //IBC([chanOut, key, 1.0, 0, 0]);
    }
  };

  // Container of voices containing a label and ticks
  let grid = CreateAppendChild('div', body);
  let rows = [];
  let recording = false;
  let drawCh = undefined;
  let drawHold = undefined;

  RangeForEach(keyCount, (y) => {
    let key = keyBeg + y;
    // [ ]
    let row = CreateInsertChild("div", grid)  // A row: Container of label and ticks
      .setClassAndTitle(playable.rowClass(key), playable.title(key));
    rows.push(row);
    // [ header ]
    let label = playable.name(key);
    let header = CreateAppendChild("p", row, label);

    // [ label [] ]
    let notes = CreateAppendChild("div", row); // Row of ticks initially empty

    notes.onmouseover = function () {
      if (MouseIsDown) {
        drawHold = false;
        event.target.innerText = drawCh; // Continue painting
      } else {
        if (event.target.innerText == "*" && brushToPlay()) {
          self.playNote(keyCount-y-1, event.target.title, 0);
          //IBC([chanOut, key, 1.0, 0, 0]);
        }
      }
    };

    header.onmousedown = function () {
      MouseIsDown = true;
      if (!sheetObj.isPaused() && recording ) { // Save note if label clicked and recording enabled
        row.children[1]
          .children[timer.currentTick() - tickIdx]
          .innerText = "*";
      }
      IBC([chanOut, key, 1.0]); // Broadcast note-down
    };
    header.onmouseup = ()=> IBC([chanOut, key, 0]); // Broadcast note-up
    header.onmouseover = ()=> MouseIsDown && IBC([chanOut, key, 1.0]);
    header.onmouseleave = ()=> MouseIsDown && IBC([chanOut, key, 0]);
  });

  let subToGlyph = function (depth) {
    return depth<=4 ? ['?', '|', '=', '+', '-'][depth] : '.';
  };

  let tickCount = function () {
    return divisions.reduce((p,n)=>p*n);
  }
  let subTickCount = function (upTo) {
    return divisions.slice(1, upTo&&++upTo).reduce((p,n)=>p*n);
  }

  let updateBeatWidthInvariants = function () {
    TickCount = tickCount();
    body.className="part";
    let width=1, sheetBeatWidth=sheetObj.beatWidth();
    RangeForEach([1, divisions.length-1], (div)=>{
      if (sheetBeatWidth < (width *= divisions[div])) { return; }
      body.className += ` d${++div}`;
    });
    elHeaderTicks.style.width = `${divisions[0]*sheetBeatWidth}ch`;

    RangeForEach(keyCount, (y) => {
      let notes = rows[y].children[1].style.width=`${divisions[0]*sheetBeatWidth}ch`;
    });

    addBeat.title = `[${divisions}]${tickCount()}`;
  }

  let insertSubbeats = function (subs) {
    if (0 == divisions[0]) { return; }
    insertHeaderSubbeats(subs);
    insertNotesSubbeats(subs);
  }

  let insertHeaderSubbeats = function (subs) {
    divisions.push(subs);
    updateBeatWidthInvariants();
    let divs = divisions.length;
    let glyph = subToGlyph(divs-1);
    let subTicks = subTickCount();
    let offset = 0;
    [...elHeaderTicks.children].forEach( (sibling)=>{
      ++offset;
      RangeForEach(subs-1, (n)=> {
        sibling = CreateAfterSibling('p', sibling, glyph)
          .setClassAndTitle(
            `d${divs}`,
            `${parseInt(sibling.title)}+${offset++%subTicks}/${subTicks}`
          );
      } );
    } );
  };

  let insertNotesSubbeats = function (subs) {
    let divs=divisions.length;
    let subTicks = subTickCount();
    let offset = 0;
    RangeForEach(keyCount, (y)=>{
      let notes = rows[y].children[1];
      [...notes.children].forEach( (sibling)=>{
        ++offset;
        RangeForEach(subs-1, ()=>{
          let el = CreateAfterSibling('p', sibling, NBSP)
            .setClassAndTitle(
              `d${divs}`,
              `${parseInt(sibling.title)}+${offset++%subTicks}/${subTicks}`);
          addTickAction(el);
          sibling = el;
        });
      });
    });
  };

  let appendBeat = function () {
    appendHeaderBeat();
    appendNotesBeat();
  }

  let appendHeaderBeat = function () {
    divisions[0]++;
    updateBeatWidthInvariants();
    CreateAppendChild('p', elHeaderTicks, "@")
      .setClassAndTitle("d1", `${divisions[0]-1}+0/1`);
    appendHeaderSubbeats_(1, 0);
  };

  let appendHeaderSubbeats_ = function (depth, offset) {
    if (divisions.length <= depth) return;
    let depthNext = depth+1;
    let nextDivision = divisions[depthNext];
    let beat = divisions[0]-1;
    let ticks = subTickCount(depth);
    let div = divisions[depth]-1;
    RangeForEach(div, (i)=>{
      let tick = offset + i;
      appendHeaderSubbeats_(depthNext, tick*nextDivision);
      CreateAppendChild('p', elHeaderTicks, subToGlyph(depth))
        .setClassAndTitle(
          `d${depthNext}`,
          `${beat}+${tick+1}/${ticks}`);
    });
    appendHeaderSubbeats_(depthNext, (offset+div)*nextDivision);
  };
 
  // Add beat to each voice's notes
  let appendNotesBeat = function () {
    RangeForEach(keyCount, (y) => {
      let notes = rows[y].children[1];
      let tick = CreateAppendChild('p', notes, NBSP).
        setClassAndTitle("d1", `${divisions[0]-1}+0/1`);
      addTickAction(tick);
      appendNotesSubbeats_(notes, y, 1, 0);
    });
  };

  let appendNotesSubbeats_ = function (notes, y, depth, offset) {
    if (divisions.length <= depth) return;
    let depthNext = depth+1;
    let nextDivision = divisions[depthNext];
    let beat = divisions[0]-1;
    let ticks = subTickCount(depth);
    let div = divisions[depth]-1;
    RangeForEach(div, (i)=>{
      let tick = offset + i;
      appendNotesSubbeats_(notes, y, depthNext, tick*nextDivision);
      let el = CreateAppendChild('p', notes, NBSP)
        .setClassAndTitle(
          `d${depthNext}`,
          `${beat}+${tick+1}/${ticks}`
        );
      addTickAction(el);
    });
    appendNotesSubbeats_(notes, y, depthNext, (offset+div)*nextDivision);
  };

  let addTickAction = function (elTick) {
    // Action Clicking
    elTick.onmousedown = function (e) {
      MouseIsDown = true; // Set global state
      let ch = e.target.innerText;
      if (NBSP == ch) {
        e.target.innerText = drawCh = '*';
        drawHold = true;
        setTimeout( ()=>(drawHold && (drawCh='-')), 250); // After 200ms draw dash if nothing drawn yet.
        self.playTick(elTick.title, 0); // When drawing a new note, play full tick (all notes)
      } else {
        drawCh= NBSP;
        e.target.innerText = NBSP;
      }
    }
  }

  // Part channel in listener handler: Like clicking a row label
  IBC.addListener( (m) => {
    let [chan, note, vol, when, sus] = m;
    if (chan != chanIn || note < keyBeg || keyBeg+keyCount <= note) { return; }
    // Record note if key-down, not paused, and recording enabled
    if (recording && vol && !sheetObj.isPaused()) {
      // Rows are in reverse order, also compensate for the first supported MIDI note
      let row = keyCount - (note - keyBeg) - 1;
      let tick = timer.currentTick( timer.jiffy()/2 )-tickIdx; // Adjust by half a jiffy so performing can be near the beat/tick instead of on or after it as is done by the tick highlighting renderer.
      grid.children[row].children[1].children[tick].innerText = "*";
    }
    // Broadcast the note
    IBC([chanOut, note, vol, when, sus]);
  });

  // Midi channel in number button
  let midiIn = CreateAppendChild('p', knobs, chanIn);
  midiIn.className = "actor";
  midiIn.title = "CHANNEL IN";
  midiIn.onmousedown = (e) => {
    if (e.button == 0) { 0<chanIn && --chanIn; };
    if (e.button == 2) { chanIn<15 && ++chanIn; };
    midiIn.innerText = chanIn;
  };

  let newRef = CreateAppendChild('p', knobs, "*");
  newRef.className = "actor";
  newRef.title = "NEW REF";
  newRef.onmousedown = () => RefPart(self, tickIdx, height+2*21);

  // Toggle brushToPlay knob
  let brushToPlay = AppendNewToggleActor(knobs, false, "actor",
    () => (elHeaderTicks.style.color=null, ")("),
    () => (elHeaderTicks.style.color="inherit", "()"));
  brushToPlay.element().title="BRUSH PLAY";

  // "Clear all ticks" button
  let clearKnob = CreateAppendChild('p', knobs, "X");
  clearKnob.className = "actor mustshift";
  clearKnob.title = "DELETE NOTES";
  clearKnob.onmousedown = function (e) {
    if (!e.shiftKey) { return; }
    RangeForEach(keyCount, (y) => {
      RangeForEach(tickCount(), (x) => {
        grid.children[y].children[1].children[x].innerText=NBSP;
      })
    })
  }

  // Toggle Recording
  let recordKnob = CreateAppendChild('p', knobs, "#");
  recordKnob.className = "actor";
  recordKnob.title = "RECORD";

  recordKnob.onmousedown = function () {
    if (recordKnob.style.background == "") {
      recordKnob.style.background="#800";
      recording = true;
    } else {
      recordKnob.style.background = "";
      recording = false;
    }
  };

  // Midi channel out number button
  let midiOut = CreateAppendChild('p', knobs, chanOut);
  midiOut.className = "actor";
  midiOut.title = "CHANNEL OUT";
  midiOut.onmousedown = (e) => {
    if (e.button == 0) { 0<chanOut && --chanOut; };
    if (e.button == 4) { chanOut<15 && ++chanOut; };
    midiOut.innerText = chanOut;
  };

  let addBeat = CreateAppendChild('p', knobs, '@');
  addBeat.onmousedown = appendBeat;
  addBeat.className = "actor";
  addBeat.title = "[]0";

  let subBeatByHalf = CreateAppendChild('p', knobs, '/2');
  subBeatByHalf.onmousedown = insertSubbeats.bind(null, 2);
  subBeatByHalf.className = "actor";

  let subBeatByThird = CreateAppendChild('p', knobs, '/3');
  subBeatByThird.onmousedown = insertSubbeats.bind(null, 3);
  subBeatByThird.className = "actor";


  // Clicking title will raise it.  Dragging title will move it around the sheet
  title.onmousedown = function (e) {
    // Right click on title toggle minimization but right button + meta bring up browser menu
    if (e.button == 2 && !e.metaKey) {
      ToggleElementDisplay(grid);
      event.stopPropagation(); // Keep event from elements
      return;
    }
    if (e.button != 0) { return; }
    MouseIsDown = true; // Set global state
    self.focus();
    // Drag/Move part within sheet
    let tickHeight = sheet.firstChild.firstChild.scrollHeight+1;
    let tickWidth  = sheet.lastChild.offsetLeft / (sheet.childElementCount-1); // Tick width take average width of all ticks
    let leftMargin = sheet.offsetLeft-sheet.scrollLeft; // Account for element's margin and scrolled offset
    sheet.onmousemove = function (offset, e) {
       if (!MouseIsDown) { sheet.onmousemove = null; return; } // Maybe stop handling this event
       // Adjust part's vertical position
       part.style.top = Max(offset + e.y, tickHeight) + "px";
       // Adjust part's horizontal position (Phrase's tick)
       let newTick = Floor((e.x-leftMargin+1) / tickWidth);
       if (newTick != tickIdx) {
         sheetObj.moveElement(tickIdx=newTick, part);
       }
    }.bind(null, part.offsetTop-e.y);
  };

  // Title editing.
  title.onkeydown = function (v) {
    event.stopPropagation(); // Don't bubble the event elsewhere (global controls),
    if (v.code == "Enter") {
      v.preventDefault(); // Prevent form element from adding a newline
    }
  }

  // The Object

  let self = function () { };
  sheetObj.partAdd(self); // Add to parent sheet

  self.element = () => part;
  self.titleName = () => title.innerText;
  self.tickCount = tickCount;
  self.headerTick = function (tick) {
    return elHeaderTicks.children[tick].innerText;
  };
  self.sheet = () => sheetObj;
  self.setStartTick = function (tick) { tickIdx = tick; }
  self.startTick = function () { return tickIdx; }
  self.divisions = ()=>divisions;

  self.isOnTick = function (t) {
    return tickIdx <= t && t < tickIdx + TickCount;
  }

  // Called by global conductor
  self.play = function (gtick, time) { self.playTick(gtick - tickIdx, time); }

  // Called by player/self
  self.playTick = function (tick, time) {
    if (tick < 0 || TickCount <= tick) {
      DB.error(`tick ${tick} out of range ${tickIdx}..${tickIdx+TickCount-1}`);
      return;
    }
    RangeForEach(keyCount, (y)=>self.playNote(y, tick, time));
  }
  /* NOTE [beat sub divs]
     DURATION [ NOTE sub div ]
     0/2  1/6 2/6  1/2  4/6 5/6
  */
  self.updateBeatWidthInvariants = updateBeatWidthInvariants;

  self.playNote = function (row, tick, time) {
    if (row < 0 || keyCount <= row) {
      DB.error(`row ${row} out of range 0..${keyCount-1}`);
      return;
    }
    let notes = rows[keyCount-row-1].children[1];
    let note = notes.querySelector(`p[title="${tick}"]`);
    if (!!note && note.innerText == "*") {
      IBC([chanOut, keyBeg + keyCount-row-1, 1.0, time, 0]) // chan note vol time sus
    }
  };
/*
  self.playNoteOld = function (row, tick, time) {
    if (tick < 0 || TickCount <= tick) {
      DB.error(`tick ${tick} out of range ${tickIdx}..${tickIdx+TickCount-1}`);
      return;
    }
    if (row < 0 || keyCount <= row) {
      DB.error(`row ${row} out of range 0..${keyCount-1}`);
      return;
    }
    //let notes = grid.children[row].children[1].children;
    let notes = rows[keyCount-row-1].children[1].children;
    let note = notes[tick];
    if (!!note && note.innerText == "*") {
      // Count subsequent "-" in grid for sustain
      let tickLast = tick+1;
      while (tickLast<TickCount && "-"==notes[tickLast].innerText) { ++tickLast; }
      // Send note message to those listening on chanOut
      IBC([chanOut, keyBeg + keyCount-row-1, 1.0, time, tickLast-tick-1]) // chan note vol time sus
    }
  };
*/

  self.focus = () => { // Raise/focus this element in sheet and reset others
    sheetObj.partsResetZ();
    part.style.zIndex = 1;
  }

  return self;
} // Part



/******************************************************************************
 Run Time
******************************************************************************/

var setupControls = function (keyboard, sheet) {

  Knobify("mainVolume",
    (v)=>{
      Destinations.input(0).gain.value = v / 100; // Unit-normalize the gain
      return Round(v);
    },
    50, .1, 0, 100,
    [100, 75, 50, 25, 0]);

  Knobify("bpm",
    (v)=>TickerTimer.setBpm(Trunc1(v)),
    60, .01, 1, 666,
    [190, 120, 90, 60, 30, 20, 10]);

  //document.getElementById('volume').oninput = (e) => Destinations.input(0).gain.value = e.target.value / 100.0; // HTML form slider element

  window.onmouseup = function () { MouseIsDown = false; }

  // Global hot keys
  window.onkeydown = function (v) {
    if (v.code == "Slash") DB.clear(); // Pressing '/' will clear the DB (debug console) element.
    let pauseElement = ElementById("pause");
    if (v.code == "KeyP") { sheet.pause(pauseElement); }
    else if (v.code == "KeyR") { sheet.rewind(pauseElement); } // Rewind the playback.
    else if (v.code == "Space") { // Pause or jump to mark
      sheet.isPaused()
        ? sheet.jump(pauseElement)
        : sheet.pause(pauseElement);
      v.preventDefault(); // Prevent space from scrolling browser window
    }
  }

  // Browser menu activated only with meta key.  The mouse event capture will
  // be stopped early if meta+mouse3 and the contextmenu bubble will only
  // bubble out if meta is active.
  window.addEventListener(
    "mousedown",
    (v) => v.metaKey && v.button==2 && v.stopPropagation(),
    true);
  window.oncontextmenu = (v) => v.metaKey || v.preventDefault();

  // Prevent tablets and phones from scrolling and resizing?
  document.body.addEventListener(
    'touchstart',
    function (event) {
      if (event.touches.length=='fack') {
        event.preventDefault();
      }
      DB(event.touches);
    },
    true);

}; //setupControls


var eventLoops = function (sheet) {
  (function processHandlerLoop () {
    let ticktime = TickerTimer.nextTick(); // [tick to process, time audio is written/buffered]
    if (ticktime !== false) {
      sheet.playAllTicks.apply(null, ticktime);
      setTimeout(processHandlerLoop, 1000 * TickerTimer.jiffy()/4); // Fill buffer within 4 jiffies
      //DB.post("event loop ctx", "!");
    } else if (!TickerTimer.isPaused()) {
      setTimeout(processHandlerLoop, 1000 * TickerTimer.jiffy());
      //DB.post("event loop ctx", "");
    }
    // else paused so allow event loop to end.
  })();

  (function renderHandlerLoop () {
    var tick = TickerTimer.nextRender();
    if (tick !== false ) {
      sheet.render(tick);
      setTimeout(renderHandlerLoop, 1000 * TickerTimer.jiffy()-10); // Next update in a jiffy
      //DB.post("event loop css", "!");
    } else if (!TickerTimer.isPaused()) {
      setTimeout(renderHandlerLoop, 10); // Try again very soon
      //DB.post("event loop css", "");
    }
  })();
}



/******************************************************************************
 MAIN

 CONCEPTS Musical Definitions

 Sheet........Arrangement of phrases
 Phrase.......Group of synchronized parts
 Part/Voice...A drum (drumkit?), voice, entire piano
 Measure/Bar..Logical division of parts
 Beat/1/4Note.Physical division of Parts
 Tick.........Physical division of Beats, denotes a note

******************************************************************************/
var Sheet0;
var Keyboard0;
var DrumKit0;
var Synthesizer0;
var Synthesizer1;
var Synthesizer2;
var Synthesizer3;
var DragOverTickState = 1;
var MouseIsDown = false; // It's nice to keep track of global mouse button state.  The window element will always catch this event and handle it.

var Start = function () {
  DB.post("Start", DB.status());

  DB.post("Start", "Buttons");
  document.getElementById('addsynth').onmousedown = function () {
    var s = new Synthesizer(ctx, false, 1, Keyboard0, "#84f");
    document.getElementById('synths').appendChild(s.element);
  }

  document.getElementById('addFilterDelay').onmousedown = function () {
    var d = new Delay(ctx);
    Destinations.push(d);
    document.getElementById('filters').appendChild(d.element);
  }

  document.getElementById('addFilterLowpass').onmousedown = function () {
    var filt = new Lowpass(ctx);
    Destinations.push(filt);
    document.getElementById('filters').appendChild(filt.element);
  }

  // Create a piano object and DOM element.  88 keys, starting at 21/A0.
  DB.post("Start", "Keyboard");
  Keyboard0 = new PianoKeyboard("piano1", 21, 88);
  //var keyboard2 = new PianoKeyboard("piano2",  21, 16, 0, 27.5); // 88-key piano: A0 A# B C1 C# D ...

  // MIDI fun
  DB.post("Start", "MIDI");
  function onMIDISuccess( m ) { // TODO Keyboard0 should not be receiving MIDI commands.
    m.inputs.forEach( e => {e.onmidimessage=function(e){Keyboard0.midi(e);};} );
  }

  function onMIDIFailure(msg) { DB.error("MIDI "+msg ); }

  if (navigator.requestMIDIAccess) {
    navigator
      .requestMIDIAccess({"sysex":true, "software":true})
      .then(onMIDISuccess, onMIDIFailure);
  }

  Sheet0 = Sheet("sheet", TickerTimer);

  DB.post("Start", "More Buttons");
  setupControls(Keyboard0, Sheet0); // Setup menus and moveable buttons.

  DB.post("Start", "Noises");

  // Load the audio asynchronously and create the default drumkit.
  DrumKit0 = new Drumkit(ctx, false, "orange", 24, ["808.bass.raw", "808.snare.drum.raw", "808.snare.noise.raw", "808.maracas.raw", "808.cowbell.raw", "808.rim.raw", "808.highhat.closed.raw", "808.claves.raw", "808.clap.raw", "808.highhat.opened.raw", "808.cymbal.raw", "909.thump.raw", "909.snare.noise.raw", "tsss.raw", "boots.raw", "cats.raw"]);

  Synthesizer0 = new Synthesizer(ctx, false, 1, Keyboard0, "#84f");
  Synthesizer1 = new Synthesizer(ctx, false, 2, Keyboard0, "#4f4");
  Synthesizer2 = new Synthesizer(ctx, false, 3, Keyboard0, "#f48");
  ElementById('synths').appendChild(Synthesizer0.element);
  ElementById('synths').appendChild(Synthesizer1.element);
  ElementById('synths').appendChild(Synthesizer2.element);

  // Effects
  ElementById('filters').appendChild(Delay().element);
  ElementById('filters').appendChild(Lowpass().element);

  DB.post("Start", "Sequences");
  Part(Sheet0, 8, 1*21, 24, 16, DrumKit0 );
  Part(Sheet0, 8,16*21, 21, 88, Synthesizer1 ); // startTick, verticalPos, keyCount <=61, tickCount

  Sheet0.setStart(8);//.setEnd(8+32-1);

  DB.post("Start", "Handlers");

  TickerTimer.registerPlayCallback(eventLoops.bind(null, Sheet0));

}; // Start


// Wait for a user gesture which will unblock the audio backend.
window.onload = function Main () {
  if (ctx.state == "suspended") {
    revealCenter("pauseicon", true)
    ctx.resume()
    setTimeout(Main, 200);
  } else {
    DB.post("Main", "Starting AudioContext!");
    // Slowly disappear the pause icon then remove the clip region so it no
    // longer looks like a play button.
    revealCenter("pauseicon", false)
    setTimeout( ()=>ElementById("pauseicon").style.clipPath="", 1100);
    Start();
  }
};

//IBC.debug();

//]]></script></body></html><!--
* Synth listener that crashes (key out of bounds) denies other synths from receiving.
* Moving part to another tick broken when moved beyond the last phrase grid column.
* copy/paste
* delete objects
* song save
* toggle sub quarter-note ticks
* Dragging Part draws ticks
* text-area parts (for notes, karaoke?)
* triggers, counters, maybe embedded scheme? (for phrase repeating, knob controlling)
* visual rendering doesn't synch right when BPM very low

5----5----5----5----5----5----5----5----5----5----5----5----5
4---4---4---4---4---4---4---4---4---4---4---4---4---4---4---4
3--3--3--3--3--3--3--3--3--3--3--3--3--3--3--3--3--3--3--3--3
2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2-2

1234
abcd
1 2 3 4
aabbccdd
1   2   3   4
aaaabbbbccccdddd

X--X--X--X--
x---x---x---

12
1-2-
1..2..
1.-.2.-.
1....3....
1.-.-.2..-..
1..-..2..-..
-->
