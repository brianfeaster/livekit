<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html version="-//W3C//DTD XHTML 1.1//EN"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xml:lang="en" lang="en"
      xsi:schemaLocation="http://www.w3.org/1999/xhtml http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd">
<head>
 <title>Liveka7 DAW</title>
 <link rel="stylesheet" href="daw2.css" type="text/css" media="screen" title="Shrewm"/>
</head>
<body>

<p id="xDB" style="width:48em; background:black; z-index:1; border:solid 1px green; white-space:pre; overflow:auto; max-height:10em; position:fixed; right:0; bottom:0"></p>

<div style="float:right">&#x2669; &#x266b; &#x266a; &#x266c; &#x266d; &#x266e; &#x266f;</div>

<h1>Liveka7 Digital Audio Workstation 2<span style="font-family:monospace">&#x03b1;</span></h1>
<hr/>
<div id="headerNav" class="headerNav">
 <a onmousedown="window.location.href=window.location.pathname+''">Clear</a>
 <a onmousedown="popupToggle('pauseicon')">Kitteh</a>
 <a onmousedown="popupToggle('djRefact0r')">DjRefact0r</a>
 <a onmousedown="window.location.href='https://shroom.dv8.org/daw'+window.location.search">DAW1.0</a>
 <a href="https://www.w3.org/TR/webaudio/">WebAudio</a>
</div>

      <!--div style="display:none; border:solid 1px #066; background:#000; white-space:nowrap; z-index:3"-->
<div class="window">
  <div>SHEET</div>
  <div class="knobs">
    <p id="mainVolume" title="MAIN VOLUME">VOL</p>
    <p id="bpm" title="BEATS PER MINUTE" style="width:5ch; text-align:center">BPM</p>
    <p class="actor reset" title="PLAY" onmousedown="TickerTimer.rewind(this)">|&gt;</p>
    <p id="pause" class="actor pause" title="PAUSE" onmousedown="TickerTimer.pause(this)">||</p>
    <div class="actor" title="NEW PART" onmouseleave="event.currentTarget.children[1].style.display='none'" onmousedown="event.currentTarget.children[1].style.display=''">
      <p>+</p>
      <div class="knobspresets" style="display:none">
        <p id="createphrasedrum">Drums</p>
        <p id="createphrasesynth">Synth</p>
      </div>
    </div>
    <div id="zoom">
      <p class="actor" title="UNZOOM<">|</p>
      <p class="actor" title="ZOOM<">|-</p>
    </div>
    <!--p style="border-radius:40%; font-weight:bold; color:black; background:yellow; border:dashed thick red" class="actor" title="THE DROP (USE SPARINGLY)">&gt!}=-<b style="background-color:red"> DrOp </b>-={!&lt;</p-->
  </div>
  <div id="sheet" class="sheet"></div>
</div>

<div class="window" style="float:left;margin:1pc;">
  <div>DRUMS</div>
  <div class="knobs"><p id="adddrum" class="actor">+</p></div>
  <div id="drums"></div>
</div>

<div class="window">
  <div>SYNTHS</div>
  <div class="knobs"><p id="addsynth" class="actor">+</p></div>
  <div id="synths"></div>
</div>

<div class="window">
  <div>FILTERS</div>
  <div class="knobs">
    <p id="addFilterDelay" class="actor">D</p>
    <p id="addFilterLowpass" class="actor">L</p>
  </div>
  <div id="filters"></div>
</div>

<div class="window">
  <div>KEYBOARD</div>
  <div class="knobs"></div>
  <div style="max-width:calc(100vw - 2ch); overflow:scroll">
    <div id="piano1" class="piano"></div>
  </div>
</div>

<p><img id="pauseicon" title="PSYCHEDELIC PAWS" alt="PSYCHEDELIC PAWS" style="display:none; border-radius:50%; clip-path: polygon(35% 0, 100% 55%,35% 100%);" src="catpause.jpg" onclick="ctx.resume()"/></p>
<p><img id="djRefact0r" title="DJ REFACT0R" alt="DJ REFACT0R" style="display:none; z-index:2; width:100%" src="djRefact0r.jpg" onclick="ctx.resume()"/></p>


<script type="text/javascript">//<![CDATA[
"use strict"

/******************************************************************************
  Debug message console and error checking

  DOM requirements::
    <p id="DB"></p>        -- If nonexistent, the DB object will revert to using the browser's console.

  Usage::
    DB("string")           -- Send string to info window.  Behaves like a pre element.
    DB.log("string")       -- Send string to console.log.
    DB.error("string")     -- Send string to console.log.
    DB.post(type, string)  -- Send string to info window band keeps track of type.  Subsequent typed messages replace the last.
    DB.clear()             -- Empty the entire DB element.
    DB.check(expr, string) -- If expr is false, send string to console.  status() will then always return false.
    DB.status()            -- Returns false if check ever failed.
******************************************************************************/
var DB = (function () {
  let consoleElement = document.getElementById('DB');
  let self;
  let status = true;
  let shouldNewline = true; // Want to prepend a newline when the last message was plain text.
  let lastPostType = false, lastPost = false;
  let repeatCount = 1;

  let setStyles = function (e) {
    return;
    e.style.border = "solid 1px green";
    e.style.whiteSpace = "pre";
    e.style.overflow = "auto";
    e.style.maxHeight = "20em";
  }

  // Create the instance which is a function.  Also create the clear function.
  if (!consoleElement) {
    self = function (s) { console.log([...arguments].join(' ')); return s; }
    self.log = self;
    self.error = function (s) { console.error(s);}
    self.post  = function (t, s) { // For the console, only the first post type is displayed.
      console.log("[" + t + "]" + s);
      return s;
    }
    self.clear = function () { lastPostType = false; }
  } else {
    setStyles(consoleElement);
    self = function () {
      let s = [...arguments].join(' ');
      if (lastPost == s) {
        ++repeatCount;
        s = `(${repeatCount})${s}`;
      } else {
        lastPost = s;
        repeatCount = 1;
      }
      consoleElement.innerHTML += (shouldNewline ? "" : "\n") + s;
      consoleElement.scrollTop = consoleElement.scrollHeight;
      shouldNewline = lastPostType = false;
    }
    self.log = function (s) { console.log(s); }
    self.error = function (s) { console.error(s); }
    self.post = function (t, s) {
      if (t == lastPostType) {
        if (lastPost == s) { ++repeatCount; }
        consoleElement.lastChild.innerText = (1<repeatCount ? repeatCount : "") + "[" + t + "]" + s;
      } else {
        consoleElement.appendChild(document.createElement('p')).innerText = "[" + t + "]" + s;
        consoleElement.scrollTop = consoleElement.scrollHeight;
        lastPostType = t;
        repeatCount = 1;
      }
      lastPost = s;
      shouldNewline = true;
      return s;
    }
    self.clear = function () {
       consoleElement.innerHTML = "";
      shouldNewline = lastPostType = true;
    }
  }

  self.check = function (expr, msg) {
    status = status && expr;
    return expr || self.error(msg) && false;
  }

  self.status = function () { return status; }

  return self;
})(); // DB


/******************************************************************************
  Useful objects
******************************************************************************/
var ctx = (window.AudioContext && new window.AudioContext()) ||
          (window.webkitAudioContext && new window.webkitAudioContext());
DB.check(ctx, "Missing window.AudioContext.  Use another browser.");
var $ = (s)=>document.querySelector(s);
var $$ = (s)=>[...document.querySelectorAll(s)];

/******************************************************************************
  Useful aliases and funtions
******************************************************************************/
var NBSP = "\u00a0";
var Floor = Math.floor;
var Round = Math.round;
var Ceil  = Math.ceil;
var Pow   = Math.pow;
var Abs   = Math.abs;
var Rnd   = Math.random;
var Max   = Math.max;
var Min   = Math.min;
var Mod   = function (n,d) { return n - d * Floor(n/d); };
var Trunc1 = function (f) { return f.toFixed(1); }
var Trunc2 = function (f) { return f.toFixed(2); }
var ElementById = function(id) { return document.getElementById(id); };
var $ = (s)=>document.querySelector(s);
var $$ = (s)=>[...document.querySelectorAll(s)];

// Simple Array compare
HTMLElement.prototype.setClassAndTitle = function (className, title) {
  this.className = className;
  this.title = title;
  return this;
}

HTMLElement.prototype.setEventListener = function () {
  this.addEventListener.apply(this, arguments);
  return this;
}

HTMLElement.prototype.setStyle = function (prop, value) {
  this.style.setProperty(prop, value)
  return this;
}

Array.prototype.cmp = function (that, len) {
  if ( (len=this.length) == that.length) {
    while (0<=--len && this[len] === that[len]);
  }
  return -1==len;
}

// Gen ary of ints: []  [0..--a]  [a..b]
var Range = (a, b) =>
  (f => Array.from(Array(f?b-a+1:a||0).keys(),f))
  (null==b ? b : n=>n+a);


var RangeMap = function (range, f) {
  return (range instanceof Array ? Range(...range) : Range(range)).map(f);
}

var RangeFilter = function (range, f) {
  return (range instanceof Array ? Range(...range) : Range(range)).filter(f);
}

var RangeForEach = function (range, f) {
  return (range instanceof Array ? Range(...range) : Range(range)).forEach(f);
}

var CreateAppendChild = function (tag, parent, text) {
  let e = parent.appendChild(document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

var CreateAfterSibling = function (tag, sibling, text) {
  let e = sibling.insertAdjacentElement('afterend', document.createElement(tag));
  if (text != undefined) {
    if (text===" ") { e.innerHTML="&nbsp;" } else { e.innerText=text }
  }
  return e;
};

var CreateInsertChild = function (tag, parent, text) {
  let e = parent.insertBefore(document.createElement(tag), parent.firstChild);
  if (text != undefined) { e.innerText = text; }
  return e;
};

var ToggleElementDisplay = function (e1, e2) {
  let off = e1.style.display == "none"; // 'none' implies not displayed.  '' implies the default CSS value.
  e1.style.display = off ? "" : "none"; // Toggle e1's display state.
  if (e2) { e2.style.display = off ? "none" : ""; } // e2's style is opposite e1.
};


// Reveal instantly an element in the center of the screen if 'show' == true,
// otherwise un-reveal it by slowly reducing opacity over time.
var revealCenter = function (id, show) {
  // Show, reset styles
  let e = ElementById(id);
  let style = e.style;
  style.opacity = style.display = "";
  style.position = "fixed";
  style.top      = (window.innerHeight/2 - e.height/2) + "px";
  style.left     = (window.innerWidth/2 - e.width/2) + "px";
  // Leave on
  if (show) { return; }
  // Slowly vanish
  (e.vanish = (opacity) => {
    if (opacity <= 0.0) {
      // Unshow, reset opacity
      style.display="none";
      style.opacity = ""
    } else {
      style.opacity = opacity;
      setTimeout(e.vanish.bind(null, opacity-0.05), 50);
    }
  })(1.0);
}


/*  Slowly reveal or hide a DOM element.
*/
var popupToggle = function (id) {
  let e = document.getElementById(id);
  let style = e.style;
  let op; // Opacity to start at
  if (style.display == "none") { // If off enable it and ramp opacity from 0 to 1
    style.display = "";
    style.position = "fixed";
    style.top = (window.innerHeight/2 - e.clientHeight/2) + "px"; // Always be centering
    style.left = (window.innerWidth/2 - e.clientWidth/2) + "px";
    op = style.opacity = -1; // Slowly reveal
  } else {
    op = 100; // Slowly disappear
  }
  (e.opacity = (o) =>
    o <= -100
      ? e.style.opacity=""
      : o == 0
        ? (style.opacity="", style.display="none")
        : (style.opacity = Abs(o/100),
           setTimeout( e.opacity.bind(null, o-5), 10))
  )(op);
  e.onmousedown = () => popupToggle(id);
}


// Blink element using color, stop blinking if color false
var blinkify = (e, color) => (
  e.blinker = color
    ? () => (setTimeout( ()=>e.blinker(), 400),
             e.style.backgroundColor = e.style.backgroundColor ? "" : color)
    : () => e.style.backgroundColor = ""
)();


/* A click-toggleable element object

   A DOM element is created and added to parent. When clicked, the appropriate
   handler will be called.  Each callback will receive the event and should
   return a string set to the innerText.  The current state and associated
   element have getters.

   USAGE::
   let a = AppendNewToggleActor(document.body, false, "myclass", ()=>"yes", ()=>"no");
   DB(`State ${a()}  Element ${a.element()}`);
*/
var AppendNewToggleActor = function (parent, state, className, callbackTrue, callbackFalse) {
  let element = CreateAppendChild('p', parent) // New Element
  if (className) { element.className = className; } // Maybe set the class
  // Call appropriate handler and update element's text
  let act = (event) => element.innerText = (state ? callbackTrue : callbackFalse)(event);
  // Event handler: toggle state
  element.onmousedown = (event) => (state = !state, act(event));
  // Call a handler at instantiation so everything is synched
  act();
  // Return state
  let self = () => state;
  // Return DOM element
  self.element = () => element;
  return self;
};


/******************************************************************************
  Create a slider object in the DOM.

  There will be one slider object that when activated will adjust wherever the
  mouse moves over it be set to the passed in value.  A call back will be
  provided that will be set to the final value.

  USAGE::
    var slider = new DOMSlider();

  CONSTRUCTOR PARAMETERS::
    na             N/A

  METHODS::
    default(e, i, c)  Activate slider in the DOM at the mouse position
                      using event e, initial value i, and setter
                      callback c.
******************************************************************************/
var Slider = function () {
  let callback;
  let mouseMoved = false,  mouseUp = false;
  let e = CreateAppendChild('p', document.body);
  e.style.position = "absolute"
  e.className = "knobs"
  e.style.width="13ch";
  e.style.border="solid 1px #066";
  e.innerHTML = "<p>|-----|-----|\n|-----|-----|</p><div>0</div>";
  e.style.display="none";
  e.style.background="black";
  e.style.zIndex=2;
  e.children[0].onmousemove = function (event) {
    mouseMoved = true;
    let box = event.target.getBoundingClientRect();
    let val = 1.0-((event.clientX - box.left) / box.width + .005)
    if (val < 0.0) val = 0.0;
    if (1.0 < val) val = 1.0;
    event.target.parentElement.children[1].innerText = val.toFixed(2);
    callback(val);
  }
  e.children[0].onmouseleave = function () {
    if (mouseMoved) { e.style.display = "none"; }
  }
  e.onmousedown = function (event) { event.stopPropagation(); }
  e.onmouseup = function (event) { // Handle clicking, releasing, then moving
    if (mouseMoved || mouseUp) { e.style.display="none"; }
    event.stopPropagation();
    mouseUp = true
  }
  return function(event, val, cb) {
    callback = cb;
    e.children[1].innerText = val.toFixed(2);
    mouseMoved = false;
    mouseUp = false;
    e.style.display="block";
    e.style.top = Floor(event.pageY - e.clientHeight/3.0) +"px" ;
    e.style.left = Floor(event.pageX - e.clientWidth*(0.995-val)) +"px" ;
  }
}() // DOMSlider


/******************************************************************************
  Knobify - Give an element a "knob" behavior

  A knob reveal its external value by hovering, the mouse wheel adjusts while
  the callback receives the new value, clicking reveals drop down of optional
  presets.

  USAGE::
    <p id="myknob">volume</p>
    Knobify("myknob", (v)=>(vol=v,Round(v)), 10, 0, 100, [100,75,50,25,0])

    element  - Element (or element's id) to knobify.
    set      - Function that sets the external value and returns value
               to display (which should handle rounding/truncating)
    get      - Function that gets the current (external) value.
    val      - Initial value (default max)
    inc      - Internal minimum decimal update offset.
    min      - min adjustable value (default 0)
    max      - max adjustable value (default 100)
******************************************************************************/
var Knobify = function (element, set, get, fac, min, max, presets) {
  fac = fac===undefined ? 0.1 : fac;
  min = min===undefined ? 0   : min;
  max = max===undefined ? 100 : max;

  element = element instanceof Element ? element : ElementById(element);
  element.className += " actor"; // Make sure actor style

  // Move all children into a new child parent.
  let label = element.innerHTML || "KNOB";
  element.innerHTML = "";

  let header = CreateAppendChild('p', element, label);
  header.contentEditable = true;

  let value;
  header.onmouseover = () => { // Mousing over reveals value
    header.focus();
    header.style.minWidth = element.clientWidth + "px";
    value = get();
    header.innerText = set(value);
  };

  // The presets dropdown element
  let epresets = undefined;
  if (presets) {
    epresets = CreateAppendChild('div', element);
    epresets.className = "knobspresets";
    epresets.style.display="none";

    element.onmousedown = ()=>epresets.style.display="";

    presets.forEach( (val)=>
      CreateAppendChild('p', epresets, val)
        .onmousedown=()=>header.innerText = set(val));
  }

  element.onmouseleave = ()=>{
    if (epresets) { epresets.style.display="none"; }
    header.blur();
    header.innerHTML=label; // Revert to label
  }

  element.onwheel = (e) => { // Scrolling mouse adjusts value
    value -= e.deltaY * fac;
    if (value < min) { value=min; }
    else if (max < value) { value=max; }
    header.innerText = set(value);
    e.preventDefault(); // So scrolling doesn't affect the browser
  };

  // TODO make sur ethis owrks
  header.onkeydown = function (event) {
    let val=value;
    if (event.code == "ArrowUp") {
      val += 1;
    } else if (event.code == "ArrowDown") {
      val -= 1;
    } else if (event.code == "Enter") {
      val = parseFloat(event.target.innerText);
      if (isNaN(val)) { val = value; }
    } else {
      event.stopPropagation(); // Stop any other key from propagating
      return;
    } 
    header.innerText = set(value = val<min ? min : max<val ? max : val);
    event.preventDefault(); // Prevent element's text receiving a newline
  };

  return element;
}; // Knobify

/*
var KnobifyOld = function (element, callback, val, inc, min, max, presets) {
  element = element instanceof Element ? element : ElementById(element);
  element.className += " actor"; // Make sure actor style

  let value = val===undefined ? max :val;
  let valueSet = (val)=>value=val;
  inc = inc===undefined ? 0.1 : inc;
  min = min===undefined ? 0   : min;
  max = max===undefined ? 100 : max;

  // Move all children into a new child parent.
  let label = element.innerHTML || "KNOB";
  element.innerHTML = "";

  let header = CreateAppendChild('p', element);
  header.innerHTML=label;
  header.contentEditable = true;

  // The presets dropdown element
  let epresets = undefined;
  if (presets) {
    epresets = CreateAppendChild('div', element);
    epresets.className = "knobspresets";
    epresets.style.display="none";

    element.onmousedown = ()=>epresets.style.display="";

    presets.forEach( (val)=>{
      let e = CreateAppendChild('p', epresets, val);
      e.onmousedown = ()=>header.innerText=callback(valueSet(val));
    });
  }

  header.onmouseover = () => { // Mousing over reveals value
    header.focus();
    header.style.minWidth = element.clientWidth + "px";
    header.innerText = callback(value);
  };

  element.onmouseleave = ()=>{
    if (epresets) { epresets.style.display="none"; }
    header.blur();
    header.innerHTML=label; // Revert to label
  }

  element.onwheel = (e) => { // Scrolling mouse adjusts value
    let v = value - e.deltaY * inc;
    if (v < min) { v=min; } else if (max < v) { v=max; }
    if (v != value) { header.innerText= callback(valueSet(v)); }
    e.preventDefault(); // So scrolling doesn't affect the browser
  };

  header.onkeydown = function (event) {
    let val;
    if (event.code == "ArrowUp") {
      val = value + 1;
    } else if (event.code == "ArrowDown") {
      val = value - 1;
    } else if (event.code == "Enter") {
      val = parseFloat(event.target.innerText);
      if (isNaN(val)) { val = value; }
    } else {
      event.stopPropagation(); // Stop any other key from propagating
      return;
    }
    if (val < min) { val=min; } else if (max < val) { val=max; }
    header.innerText = callback(valueSet(val));
    event.preventDefault(); // Prevent element's text receiving a newline
  };

  callback(value); // Make sure callback is synchronized
  element.set = function (v) { callback(valueSet(v)); };
  return element;
}; // Knobify
*/




/******************************************************************************
  Hyphen - WebSocket based Key/Value store

  USAGE::
    hyphen(msg)      Send message to Hyphen
******************************************************************************/
var hyphen = (function () {
   DB ("Connecting to Hyphen!");
   let server = new WebSocket( window.location.protocol=="https:" ? "wss://shroom.dv8.org:7179" : "ws://shroom.dv8.org:7180");
   let song = false;

   // Listener starts off waiting for "HYPHEN" hello message
   server.onmessage = function (e) {
      if (typeof(e.data) == "string") {
         if (e.data != "HYPHEN") {
            DB("hyphen Sent hot bars");
            song = e.data.split("&")[0];;
            window.location.href = window.location.pathname+"?"+song;
         } else {
             DB("hyphen text: " + e.data);
         }
      } else {
         DB("hyphen bin: " + e.data);
      }
   }

   let get = function (songid) {
      if (server.readyState != 1) {
         DB.post("hyphen", "Waiting for connection readyState...");
         setTimeout(get.bind(0, songid), 200);
      } else {
         DB("hyphen sending: get" + songid);
         let ret = server.send("get" + songid);
      }
   }

   let qstr = window.location.search.substring(1).split("&")[0];
   if ( qstr.length < 20) {
      get(qstr);
   }

   let self = get;

   self.server = function () { return server }
   self.song   = function () { return song }

   return self

})();


/******************************************************************************
  Base64 encoder and decoder

  USAGE::
    Base64([1,2,3])  Returns a base64 encoded string of the byte (0..255)
                     values in the array.
    Base64("0G83")   Returns a decoded base64 string as an array of bytes
                     values.
    Base64.test(ary) Runs an internal test.  Calls DB.check(ary) on the
                     comparision of the output of the encoding then decoding
                     of the passed byte array.
  ALGORITHM NOTES::
    An incomplete octet will be correctly created because:
    (emptyArray[0] >> num)   =>   (undefined >> num)   =>
******************************************************************************/
var Base64 = (function () {
  //// Private
  let self;
  let base64table = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',
                     'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
                     'W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l',
                     'm','n','o','p','q','r','s','t','u','v','w','x','y','z','-','_'];
  let _encode = function (ary) {
    let ary1 = ary.slice(0); // Copy the array since I shift the elements off.
    let octet=0;     // Which octet to create
    let str = ""; // The encoded string
    while (ary1.length) {
      str +=
        base64table[(0 == octet) ? ary1[0] >> 2 :                              // [000000..]
                    (1 == octet) ? ((ary1.shift() & 3) << 4) + (ary1[0] >> 4) :// [......00][1111....]
                    (2 == octet) ? ((ary1.shift() & 15) << 2) + (ary1[0] >> 6) //           [....1111][22......]
                   /*3 == octet*/: ary1.shift() & 63];                         //                     [..222222]
      octet = ++octet & 3;
    }
    return str;
  }

  let _decode = function (str) {
    let ary=[];
    let i=0, byte, stet0, stet1;
    while (i < str.length) {
      stet0 = base64table.indexOf(str[i]);
      if (!DB.check(0 <= stet0, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      stet1 = base64table.indexOf(byte=str[++i]);
      if (!DB.check(0 <= stet1, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      ary.push((stet0 << 2) + (stet1 >> 4)); // [000000][00....]
      if (++i == str.length) break;


      stet0 = base64table.indexOf(byte);
      if (!DB.check(0 <= stet0, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      stet1 = base64table.indexOf(byte=str[i]);
      if (!DB.check(0 <= stet1, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      ary.push(((stet0&15) << 4) + (stet1 >> 2));//         [..1111][1111..]
      if (++i == str.length) break;


      stet0 = base64table.indexOf(byte);
      if (!DB.check(0 <= stet0, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      stet1 = base64table.indexOf(str[i]);
      if (!DB.check(0 <= stet1, "Invalid Base64 chr:" + str[i] + " offset:" + i + " str:" + str.substr(i))) break;

      ary.push(((stet0&3) << 6) + (stet1));           //                 [....22][222222]
      if (++i == str.length) break;
    }
    return ary;
  }

  let _test1 = function (ary) {
    let str = Base64(ary);
    let ary2 = Base64(str);
    DB.check((ary.toString() == ary2.toString()), ary + " != " + ary2);
  }

  let _test = function () {
    _test1([]);
    _test1([0]);
    _test1([1]);
    _test1([2]);
    _test1([255]);
    _test1([1,255]);
    _test1([255,1]);
    _test1([255,1]);
    _test1([255,1,255]);
    _test1([255,1,255]);
    _test1([1,255,1]);
    _test1([0,0,0,0,0]);
    _test1([0,0,0,0,255]);
    _test1([255,0,0,0,0]);
    _test1([1,1,1,1,1]);
    _test1([255,255,255,255,255]);
  }

  //// Public
  self = function (o) {
    if (Array.isArray(o)) return _encode(o);
    else if (typeof o == "string") return _decode(o);
    else return false;
  }

  self.test = _test;

  return self;
})();

Base64.test();


/******************************************************************************
  GET string wrapper providing a stream object.

  USAGE::
    var gs = new GetStringBase64();

  METHODS::
    .reset           Reset the stream.
    .assertString(s) Match and consume the next bytes as characters to string s.
    .assertBytes(a)  Match and consume the next bytes as bytes to byte array a.
    .nextString(l)   Return next bytes as string of length l.
    .nextBools(c)    Consume and return next c bits as array of bytes.  Unused bits ignored.
    .nextByte()      Consume and return next byte as byte.
    .peekByte()      Return next byte as byte.
    .examine()       Return current internal unBased64 getstring.
    .length()        Return current length of decoded GET string.
******************************************************************************/
var GetStringBase64 = function (get) {
  //// PRIvate
  let self = this;
  let _gsb64 =
    get ||
    (window.location.search.substring(1).length < 20 // Using query as song filename as well
    ? ""
    : window.location.search.substring(1));
  let _gs = [];

  //// PUBLIC
  this.reset = function () {
    _gs = Base64(_gsb64);
  }

  this.assertString = function (str) {
    for (let i=0; i<str.length; ++i) {
      let a = _gs.shift();
      let b = str.charCodeAt(i);
      if (a != b) return false;
    }
    return true;
  }

  this.assertBytes = function (ba) {
    for (let i=0; i<ba.length; ++i) {
      let a = _gs.shift();
      let b = ba[i]
      if (a != b) return false;
    }
    return true;
  }

  this.nextString = function (len) {
    let ret = _gs.splice(0,len);
    return String.fromCharCode.apply(null, ret);
  }

  this.nextBools = function (len) {
    let i=0, b, m, bs=[];
    while (i<len) {
      m = i++%8;
      if (0 == m) {
        if (_gs.length < 1) { return bs; }
        b = _gs.shift();
      }
      bs.push(!!(b >> m&1));
    }
    return bs;
  }

  this.nextByte = function () {
   return (0 < _gs.length) ? _gs.splice(0,1)[0] : null;
  }

  this.peekByte = function () {
   return (0 < _gs.length) ? _gs[0] : null;
  }

  this.examine = function () { return _gs; }
  this.length  = function () { return _gs.length; }

  let _testAssert = function (a, b) { DB.check(a==b, a + " != " + b); }
  let _test = function () {
    let __gsb64 = _gsb64; // Save internal state
    let __gs = _gs;

    _gsb64 = "C34oCm";
    self.reset();
    _testAssert(self.nextByte(), 48);
    _testAssert(self.nextByte(), 49);
    _testAssert(self.nextByte(), 50);
    _testAssert(self.nextByte(), 51);
    _testAssert(self.nextByte(), null);

    _gsb64 = __gsb64; // Restore internal state
    _gs = __gs;
  }

  _test();
  this.reset();
}


/******************************************************************************
  Inter-Broadcast Communication message hyper-loop system.

  USAGE::

  METHODS::
    (m)
    .broadcast(m)    Send m to all listeners
    .listeners()     Get current set of listeners
    .addListener(f)  Add a listener callback which receives m.  Returns an id.
    .delListener(id) Remove aforementioned listener.
    .debug()         Toggle debug

******************************************************************************/
var IBC = function () {
  // Private
  let _debug = false;
  let _id = 0;
  let _listeners = []; // Array of [id, callback, messaged?]

  // Public

  self = function (m) { self.broadcast(m); }

  // Send m to all the listeners
  self.broadcast = function (m) {
    let ls = _listeners.filter( (l)=>!l[2] ); // Listeners we haven't messaged yet

    // Debug dump the message and the handler ID's who'll get it
    if (_debug) { DB(ls.reduce( ((r,l) => r += " " + l[0]), JSON.stringify(m) + " ->")); }

    ls.forEach((f)=>{
      f[2] = true; // Set handler messaged bool to prevent message cycles
      f[1](m);
      f[2] = false;
    });
  }

  self.listeners = function () { return _listeners; }
  self.addListener = function (f) { _listeners.push([++_id, f]);  return _id; }
  self.delListener = function (id) {
    let idx = _listeners.findIndex( (e)=>e[0]==id );
    if (0 <= idx) { _listeners.splice(idx, 1); }
  }
  self.debug = function () { _debug = !_debug; };
  // Test
  (function(){
    let l1, l2, a=0, b=0;
    DB.check(self.listeners().length==0, "ERROR:  There should be 0 listeners"); // Verify no listerns

    l1 = self.addListener(function (m) { a=m; }); // Register a listener
    self.broadcast(69);                      // Broadcast to listener 1
    DB.check(self.listeners().length==1, "ERROR:  There should be 1 listener, instead " + self.listeners().length);
    DB.check(a==69 && b==0, "ERROR:  Expect 69 and 0 after broadcast: " + a + " " + b);

    l2 = self.addListener(function (m) { b=m; });
    self.broadcast(42);                      // Broadcast to listener 1 and 2
    DB.check(self.listeners().length, 2);
    DB.check(a==42 && b==42, "ERROR:  Expect 42 and 42 after broadcast: " + a + " " + b);

    self.delListener(l1); // Remove listener 1
    self.broadcast(55);                      // Broadcast to listener 2
    DB.check(self.listeners().length==1, "ERROR:  There should be 1 listener"); // Verify no listerns
    DB.check(self.listeners().length, 2);
    DB.check(a==42 && b==55, "ERROR:  Expect 42 and 55 after broadcast: " + a + " " + b);

    self.delListener(l2);
    self.broadcast();
    DB.check(self.listeners().length==0, "ERROR:  There should be 0 listeners"); // Verify no listerns
  })();
  return self;
}(); // IBC


/******************************************************************************
  Skeuomorphic piano keyboard.  Implements the DOM element as well as the
  audio synthesis.

  USAGE::
    var kb = new PianoKeyboard(id, startKey, keyCount, startOctave);

  CONSTRUCTOR PARAMETERS::
    id             DOM element id to add the new piano element.
    startKey       Initial key using MIDI note values 0..127 == C-1..G9
    keyCount       Number of keys

  METHODS::
DEPREATED    .freq(key)             Frequency of key.
    .highlight(key, color) Highlight the key using color.  Overrides its last
                           color, if any, by pushing new color on a stack.
    .unhighlight(key)      Removes last/top highlighted color and reverts to
                           its previous color (if any)
    .midi(event)           MIDI message to interpret and perform

  GLOBALS::
    IBC: Keyboard will broadcast the physical press.  Listener will act on the
         message and set tick notes, high-light things, send audio to the DAC,
         etc.  Performance is a concern.  Audio stream related messages should
         avoid the IBC and manage private callback lists.
******************************************************************************/
var PianoKeyboard = function (id, keyStart, keyCount) {
  //// Private
  let self = this;
  let element = document.getElementById(id);
  let chanOut = 3;
  DB.check(element, "ERROR: PianoKeyboard: Element id=" + id + " not found in DOM.");

  let knobs = element.parentElement.previousElementSibling;
  let midi = CreateAppendChild('p', knobs, chanOut);
  midi.title = "CHANNEL OUT";
  midi.onmousedown = (e) => {
    if (e.button == 0) { 0<chanOut && --chanOut; };
    if (e.button == 2) { chanOut<15 && ++chanOut; };
    midi.innerText = chanOut;
  };

  let _keysDOM = []; // Keeps track of the DOM elements which represent the white and black keys in order.
  let _highlights = []; // Array of stacks.  An empty stack implies no high-light.
  let _highlightColor = "#f8f"
  let notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

  // Helpers to set/unset key highlight

  let keyPress = function(key) {
    self.highlight(key, _highlightColor); // Set current key high-light
    IBC([chanOut, key, 1.0]); // Notify listeners a note/key was pressed
  }

  let keyRelease = function(key) {
    self.unhighlight(key, _highlightColor);
    IBC([chanOut, key, 0]); // Notify listeners a note/key was released
  }

  RangeForEach(keyCount, (i) => {
    let key = keyStart + i;
    let newKey;
    // Sharp or natural key.
    if (2 == notes[key % 12].length) {
      newKey = CreateAppendChild('p', element);
    } else {
      newKey = CreateAppendChild('div', element)
      // Natural key gets a note/octave label
      let octave = Floor((key-12) / 12);
      let note = key % 12;
      newKey.innerText = notes[note] + (note==0?octave:'');
    }

    // Register mouse event handlers for every keyboard DOM element representing a key.
    newKey.onmouseover  = ()=>MouseIsDown && keyPress(key);
    newKey.onmousedown  = ()=>(MouseIsDown=true, keyPress(key));
    newKey.onmouseleave = ()=>MouseIsDown && keyRelease(key);
    newKey.onmouseup    = ()=>keyRelease(key);

    _keysDOM.push(newKey); // Keep track of each created key.
    _highlights.push([]);
  });

  self.highlight = function (key, color)  {
    //DB.post("PianoKeyboard", ["highlight", key, color])
    let i = key - keyStart;
    if ((0 <= i) && (i < keyCount)) {
      _highlights[i].push(color);
      _keysDOM[i].style.backgroundColor = color;
    }
  }

  self.unhighlight = function (key, color) {
    //DB.post("PianoKeyboard", ["unhighlight", key, color])
    let i = key - keyStart;
    let stk = _highlights[i];
    if (!stk) return; // Invalid key keys are ignored.
    if (color) { // Remove color from stack (could be anywhere)
      let s = stk.indexOf(color);
      if (-1 < s) { stk.splice(s, 1); }
    } else {
      stk.pop(); // If no color passed, pop last color
    }
    // Set the key's color to the top of the stack
    let l = stk.length;
    _keysDOM[i].style.backgroundColor = (0 < l) ? stk[l-1] : "";
  }

  /*
    Voice Message        octet 1         octet 2          octet 3
    -------------     ----------- ----------------- -----------------
    Note off                8x    Key number        Note off velocity
    Note on                 9x    Key number        Note on velocity (0 implies note off)
    Polyphonic Key Pressure Ax    Key number        Amount of pressure
    Control Change          Bx    Controller number Controller value
    Program Change          Cx    Program number    None
    Channel Pressure        Dx    Pressure value    None
    Pitch Bend              Ex    MSB               LSB
    The MIDI controller I use sends "note on" with 0 velocity as a "note off"
  */
  self.midi = function (msg) { // TODO This should not be here
    //DB.post("PianoKeyboard", msg.data);
    let d = msg.data;
    let cmd = d[0];
    let key = d[1];
    if ((0x90 + 0 <= cmd) && (cmd <= 0x90+15) // channel 0..15
        && (keyStart <= key) && (key < keyStart + keyCount)) {
      if (d[2] == 0) {
        keyRelease(key);
      } else {
        keyPress(key);
      }
    }
  }
} // PianoKeyboard


/******************************************************************************
//  CTX Destinations
//
//  Manage audio destinations including the main context and any filters.
//
//  Usage::
//    Destinations[0].input()    // Get main CTX input.
//    Destinations.push(filter)) // Add a new filter object
//    Destinations.cut())        // Add a new filter object
//
******************************************************************************/
var Destinations = (function (ctx) {
  let self = [];
  let vol = 0.5;

  let fuse = ctx.createGain();
  fuse.name = function () { return "ctx"; };
  fuse.input = function () { return fuse; };
  fuse.connect(ctx.destination);
  self.push(fuse);

  self.name = function (i) { return self[i].name(); }
  self.input = function (i) { return self[i].input(); }
  self.nextId = function (id) {
    let ret = (id+1) % self.length;
    return ret;
  }
  self.next = function (d) { // Return destination after d in array.
    let i = 1 + self.findIndex( function (v,i) { return d== v.input(); } )
    return self[i % self.length];
  }
  self.index = function (d) { // Return index of the destination object
    let i = self.findIndex( function (v,i) { return d==v || d==v.input(); } )
    return (0 <= i) ? i : 0;
  }
  self.cut = function () {
    let oldVol = fuse.gain.value;
    // Silence current gainf use
    fuse.gain.setValueAtTime(0, ctx.currentTime);
    fuse.disconnect(ctx.destination);

    // Create new fuse gain and connect to CTX
    fuse = self[0] = ctx.createGain();
    fuse.gain.value = oldVol;
    fuse.name = function () { return "ctx"; };
    fuse.input = function () { return fuse; };
    fuse.connect(ctx.destination);

    // Sweep through for any filters that are connected to a filter
    // that doesn't match the filter in this array.  Update them.  Repeat.
    // For a filter like delay which can continue to produce samples, a new
    // one needs to be created and the exisintg one replaced.  This algorithm
    // will run again and update any filters depending on it until all filters point
    // to a filter in this array.

    // get reconnected to new fuse;
    let updateCount = 0;
    while (updateCount < self.length) { // Sanity check: Don't expect to update more filters than exists
      let updated = false;
      self.slice(1).forEach( (filter, i) => {
        if (filter.connect()) { // Recreates this filter if it's not connected to something not in this destination object
          //DB(`Reconnected ${i} ${filter.name()} to ${filter.dest()}`);
          ++updateCount;
          updated = true;
        }
      });
      if (!updated) { break; }
    }
    DB.check(updateCount < self.length, "Updated more filters than exists");

  }

  return self;
})(ctx); // Destinations

/******************************************************************************
  Database of Web Audio audio buffers.  It will download and convert raw audio
  files into ready to use AudioBuffers.

  USAGE::
    var noises = new AudioBuffers(filenames)

  METHODS::
    noises.length          Number of files specified.
    noises.fileName(i)     Get a filename.
    noises.audioBuffer(i)  Get an audio buffer or undefined.
******************************************************************************/
var AudioBuffers = function (ctx, filenames) {
  //// Private
  let _audioBuffers = [];

  function _Validate () {
    if (!DB.check(filenames && Array.isArray(filenames), "ERROR: AudioBuffersdb: Invalid filenames ary.")) {
      filenames = [];
    }
  }

  function _loadRawAudioFiles () {
    let count=0;
    filenames.forEach(function (fn, i) { // forEach passes in each ary element and the index.
      let client = new XMLHttpRequest();
      client.open('GET', fn);
      client.responseType = "arraybuffer";
      client.onreadystatechange = // Callback after remote file has been loaded
        function (e) {
          if (4 != client.readyState) { return; }
          let statusState = ((200 == client.status) || (0 == client.status) && (null != client.response)); // When loaded locally with --allow-file-access-from-files, status is 0 so must check client.response instead
          DB.check(statusState, "ERROR: AudioBuffers: " + client.status + " '" + (client.responseURL || fn) + "'");
          if (statusState) {
//DB.post("AudioBuffers", `${i}/${filenames.length} ${fn}`);
            if (++count == filenames.length) {
              DB.post("AudioBuffers", `${count} files acquired`);
            }
//DB.log("LOADED " + fn);
            let samples = new Int16Array(client.response); // Consider u8 ary as s16 ary.
            // Normalized each s16 sample to f32 between -1 and 1.
            let Noise =  new Float32Array(samples.length);
            for (let j=0; j<samples.length; ++j) {
              Noise[j] = samples[j]/32768;
            }
            // Create and set the audio buffer
            _audioBuffers[i] = ctx.createBuffer(1, samples.length, 44100);
            _audioBuffers[i].getChannelData(0).set(Noise);
          } // if
        } // function()
      client.send();
    }); // forEach function
  } // function

  //// Construct

  _Validate();
  _loadRawAudioFiles();

  //// Public

  this.length = filenames ? filenames.length : 0;
  this.fileName = function (i) { return filenames[i]; }
  this.fileNameCompact = function (i) {
    let fn = filenames[i].slice(0, -4); // Strip trailing ".raw"
    let firstDot = fn.indexOf(".");
    return (0 <= firstDot) ? fn.slice(firstDot+1) : fn;
  }
  this.audioBuffer = function (i) { return _audioBuffers[i]; }
} // AudioBuffers


/******************************************************************************
  Create a playable drumkit.  Expects a webaudio context and list of assets to
  acquire and cache into an AudioBuffer collection.

  USAGE::
    var dk = new Drumkit(ctx, color, keyStart, audioBuffers);

  CONSTRUCTOR PARAMETERS::
    ctx           An web audio context and audio buffers object.
    color         Highlight color
    keyStart      The first MIDI key/note the drumkit is mapped to
    audioBuffers  Playable sound samples

  METHODS::
    .length                    Number of reserved buffers
    .name(pad)                 String describing the pad.  Usually the drum sound.
    .color                     Color associated with this object
    .play(pad, vol, when)      Plays an audiobuffer sample specified by pad at
                               volume vol at time when or now if when==0.
    .connect(destination, idx) Set destination to destination
    .connected(idx)            Get destination to destination
******************************************************************************/
var Drums = []; // Array of instantiated drumkits.
var Drumkit = function (ctx, label, color, keyStart, filenames) {
  //// Local
  let self = this;
  let _name = label || ("Drumkit" + ++SynthGlobalCounter);
  let audioBuffers = new AudioBuffers(ctx, filenames)
  let bassRel = 1.0; // Release time in seconds for both the filter and gain.
  let destinations = Array(audioBuffers.length).fill(0); // Default destination of each sound to default
  let volumes = Array(audioBuffers.length).fill(0.4); // Default volumes
  let _ibcId = false;
  let chanIn = 10;

  // Element []
  let _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";
  ElementById('drums').appendChild(_element);

  // [Drumkit1]
  let _nameDOM = CreateAppendChild('div', _element); // [ Synth1 ]
  _nameDOM.style.background="";
  _nameDOM.innerText = _name;

  // [Drumkit1 []]
  let knobs = CreateAppendChild('div', _element); // [ Synth1 [ ] ]

  // [Drumkit1 [3]]
  let midi = CreateAppendChild('p', knobs, chanIn);
  midi.title = "CHANNEL IN";
  midi.className="actor";
  midi.onmousedown = (e) => {
    if (e.button == 0) { 0<chanIn && --chanIn; };
    if (e.button == 2) { chanIn<15 && ++chanIn; };
    midi.innerText = chanIn;
  };

  // [Drumkit1 [3]]
  // [            ]
  let buttons = CreateAppendChild('div', _element);
  buttons.className = "knobs";

  // [Drumkit1 [3]  ]
  // [ctx [vol] drum]
  // ...
  RangeForEach(audioBuffers.length, (k)=> {
    k = audioBuffers.length - k - 1;
    let _output = CreateAppendChild('p', buttons, Destinations.name(destinations[k]));
    _output.className = "volume"; // "actor"
    _output.innerText = Destinations.name(destinations[k]);
    _output.onmousedown = function (event) {
      if (++destinations[k] == Destinations.length) { destinations[k] = 0; }
      _output.innerText = Destinations.name(destinations[k]);
    };

    Knobify(CreateAppendChild('p', buttons, "VOL"),
      (v)=>(volumes[k]=v/100, Round(v)),
      ()=>volumes[k]*100,
      .1, 0, 100, [100, 75, 50, 25, 10, 0]
    ).title="DRUM VOLUME";

    if (0==k) {
      Knobify(CreateAppendChild('p', buttons, "REL"), (v)=>(bassRel=v/100, Round(v)), ()=>bassRel*100).title="BASS DRUM RELEASE";
    }

    let drum = CreateAppendChild('p', buttons, audioBuffers.fileNameCompact(k));
    drum.className = "hit";
    drum.onmousedown = ()=> self.play(k+keyStart, 1.0, 0);

    CreateAppendChild('br', buttons);
  });

  // Behavior

  // Drumkit message handler:  play/stop a note [chan note vol time sus]
  let listenerIBC = (m) => m[0]==chanIn && self.play(m[1], m[2], m[3]);

  (_nameDOM.onmousedown = function () {
    if (_nameDOM.style.background == "") {
      _nameDOM.style.background="#880";
      _ibcId = IBC.addListener(listenerIBC);
    } else {
      _nameDOM.style.background="";
      _ibcId = IBC.delListener(_ibcId);
    }
  })(); // Toggle the synths on and listening to MIDI

  // Object
  Drums.push(this);
  this.length = audioBuffers.length;
  this.name = (key) => (undefined == key) ? "TR-808" : audioBuffers.fileNameCompact(key-keyStart);
  this.rowClass = (_key) => "drumkit";
  this.title = (key) => `${key} ${this.name(key)}`;
  this.color = color
  this.play = function (pad, vol, when) {
    let key = pad - keyStart;
    let audioBuffer = audioBuffers.audioBuffer(key);
    if (!audioBuffer) {
      DB.error(`Drumkit.play offset ${pad} expect ${keyStart}..${keyStart+this.length-1}`);
      return; // Do nothing if no audio buffer.
    }
    let source = ctx.createBufferSource();
    source.buffer = audioBuffer;
    source.onended = function() { source.disconnect(); } // When the audio stops, remove it from the graph.
    let gain = ctx.createGain(); // Ramp
    vol *= volumes[key]; // Combine incoming message note vol with drumkit's volume.
    if (key == 0) { // HACK: need to generalize a sound pipeline
      let now = (when || ctx.currentTime); // Depending on how this is called (when is either 0 or a real time in the future) now will be the current time or when
      // Loop the bass noise for one second with a LPF and gain ramp.
      source.playbackRate.setValueAtTime(0.39, now);
      source.playbackRate.linearRampToValueAtTime(0.38, now+bassRel);
      source.loop = true;
      source.start(when);
      source.stop(now + bassRel);

      let lp = ctx.createBiquadFilter(); // LPF
      lp.type = "lowpass";
      lp.frequency.value = 100;
      lp.Q.value = 0.5;

      gain.gain.setValueAtTime(vol, now);
      gain.gain.linearRampToValueAtTime(0, now+bassRel);

      source.connect(lp);
      lp.connect(gain);
    } else {
      gain.gain.value = vol;
      source.connect(gain);
      source.start(when);
    }

    gain.connect(Destinations.input(destinations[key]));
  }
  this.connect = function (dest, idx) { destinations[idx] = dest; }
  this.connected = function (idx) { return destinations[idx]; }
  this.chanIn = function (c) { midi.innerText=chanIn=c; return this; }
  this.chanIn = function () { return chanIn; }
  this.chanInSet = function (c) { midi.innerText=chanIn=c; return this; }
} // Drumkit


/* MIDI key and frequency manager

   Octaves begin at note C.  MIDI begins (key 0) on octave -1, note C
   88 key piano start at octave 0, note A (just 3 notes in octave 0: A A# B).
   Key 21 (A-natural sub-contra-octave) is set to the base frequency

  Key Note Freq            Key Note Freq
    0 C-1  8.1758             69 A4   440/Middle A
    9 A-1 13.75               81 A5   880
   21 A0  27.5 88PianoStart   93 A6  1760
   33 A1  55                 105 A7  3520
   45 A2 110                 108 C8  4186.0090 88PianoEnd
   57 A3 220                 117 A8  7040
   60 C4 261.6256/MidC       127 G9 12543.8540
*/
let KeyFreq = function (freqa0) {
  // Generate able of base frequency multipliers
  let keymult = RangeMap(128, (k) => Pow(2, (k-21)/12.0));
  let self = (k, f) => keymult[k] * (f || freqa0) + Rnd()*0.5 - 0.25;
  self.setFreqA0 = (f) => freqa0=f;
  self.freq = () => freqa0;
  return self;
}(27.5);

DB.check( KeyFreq(21)==27.5, `KeyFreq frequency mismatch key 21 ${KeyFreq(21)} != 27.5Hz`);
DB.check( KeyFreq(69)==440, `KeyFreq frequency mismatch key 69 ${KeyFreq(69)} != 440Hz`);
DB.check( KeyFreq(105)==3520, `KeyFreq frequency mismatch key 105 ${KeyFreq(105)} != 3520Hz`);
DB.check( KeyFreq(117)==7040, `KeyFreq frequency mismatch key 117 ${KeyFreq(117)} != 7040Hz`);


/******************************************************************************
  Create a playable synthesizer.

  USAGE::
    var synth = new Synthesizer(ctx, keyboard, color);

  CONSTRUCTOR PARAMETERS::
    ctx      A web audio context.
    keyboard An instantiated keyboard object
    color    DOM color

  METHODS::
    .element              This object's element
    .color                Color associated with this object
    .name(key)            Name associated with this key.  Default is the synth waveform name, each key.
    .adsr()               Get ADSR values in array
    .attSet(att)          Set new attack value 0.0-1.0.
    .susSet(sus)          Set new sustain value 0.0-1.0.
    .relSet(rel)          Set new release value 0.0-1.0.
    .play(key, vol, when) Plays a waveform at a freq determined by the Keyboard object at the
                          specified key, at webaudio context time 'when' or immediately if when==0.
    .wave()               Get current waveform index..
    .waveform()           Get current waveform string.
    .highlight(key)       Highlight the keyboard object's key with my color.  Used when playing a note.  TODO:  Is this smrt?
    .unhighlight()        Remove my highlight from the keyboard object.
    .destination()        Return output destination

  EVENTS::
    The name element will toggle receiving MIDI messages via IBC
******************************************************************************/
var SynthGlobalCounter = 0;
var Synthesizers = [];
var Synthesizer = function (ctx, label, type, keyboard, color) {
  label = label ||  ("Synth" + ++SynthGlobalCounter);
  //// Local
  let self = this;
  let _ibcId = false;
  let _att = 0.01; // Attack time in seconds.
  let _sus = 0.01;
  let _rel = 0.50; // Release time in seconds for both the filter and gain.
  let _waveforms = ["sine", "square", "sawtooth", "triangle"];
  let _waveformIdx = type;
  let _filterIdx = 0;
  let _volume = 0.5;
  let chanIn = 4;
  let _mouseMoved;
  let _freq=27.5;

  let _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";

  let _nameDOM = CreateAppendChild('div', _element); // [ Synth1 ]
  _nameDOM.style.background="";
  _nameDOM.innerText = label;

  let knobs = CreateAppendChild('div', _element); // [ Synth1 [ ] ]

  let midi = CreateAppendChild('p', knobs, chanIn);
  midi.title = "CHANNEL IN";
  midi.className="actor";
  midi.onmousedown = (e) => {
    if (e.button == 0) { 0<chanIn && --chanIn; };
    if (e.button == 2) { chanIn<15 && ++chanIn; };
    midi.innerText = chanIn;
  };

  /*
  let _delSynth = CreateAppendChild('p', knobs);  // [ Synth1 [-] ]
  _delSynth.className="actor mustshift";
  _delSynth.innerText = "-";

  // Remove synth only if not not used in any of the synth parts in any of the phrses and not one of the original 4 synths.
  _delSynth.onmousedown = function () {
    // Never remove the first four synths as they are used when creating a new phrase. TODO: remove this dependency
    let count=0;
    let synthIndex = Synthesizers.indexOf(self);
    if (synthIndex < 4) { return; }
    // Count synth usage in all parts of all phrases.
    Sheet0.phrases.map(function(ph){ ph.parts.map(function(pt){ if (self == pt.playable) ++count; }); });
    if (0 < count) { return; }
    Synthesizers.splice(synthIndex, 1);
    document.getElementById('synths').removeChild(_element); // Remove myself from DOM
  }
  */

  let _body = CreateAppendChild('div', _element);//  [ Synth1 [-] ]
  _body.className = "knobs";                     //  [            ]


  // Waveform button
  // [ FREQ [sine] ]
  Knobify(
    CreateAppendChild('p', _body, "FREQ"),
    (v)=>(_freq=v, Trunc1(v)),
    ()=>_freq,
    .01, 1, 440, [440, 220, 110, 55, 27.5, 13.75]
  ).title = "BASE FREQ";
  let _waveformDOM = CreateAppendChild('p', _body)
  _waveformDOM.className = "actor";
  _waveformDOM.title = "OSCILLATOR";
  _waveformDOM.innerText = _waveforms[_waveformIdx];
  _waveformDOM.onmousedown = function () {
    if (_waveforms.length == ++_waveformIdx) _waveformIdx=0;
    _waveformDOM.innerText = _waveforms[_waveformIdx];
  }


  // Knobs
  // [ [27.5][sine][-]]
  // [ ATT SUS REL    ]
  // [ VOL [ctx]      ]
  CreateAppendChild('br', _body);
  Knobify(CreateAppendChild('p', _body, "ATT"), (v)=>(_att=v/100, Round(v)), ()=>_att*100).title="ATTACK";
  Knobify(CreateAppendChild('p', _body, "SUS"), (v)=>(_sus=v/100, Round(v)), ()=>_sus*100).title="SUSTAIN";
  Knobify(CreateAppendChild('p', _body, "REL"), (v)=>(_rel=v/100, Round(v)), ()=>_rel*100).title="RELEASE";
  CreateAppendChild('br', _body);
  Knobify(CreateAppendChild('p', _body, "VOL"), (v)=>(_volume=v/100, Round(v)), ()=>_volume*100, .1, 0, 100, [100, 80, 50, 20, 0]).title="VOLUME";

  // Destination
  // [ [27.5][sine][-]]
  // [ ATT SUS REL    ]
  // [ VOL [ctx]      ]
  let _output = CreateAppendChild('p', _body);
  _output.style.position = "relative"
  _output.className = "volume"
  _output.innerText = Destinations.name(_filterIdx);
  _output.onmousedown = function (event) {
    if (++_filterIdx == Destinations.length) { _filterIdx = 0; }
    _output.innerText = Destinations.name(_filterIdx);
  }

  let _play = function (key, vol, when, sustain) {
    //DB.post("_play", [key, vol, when, sustain]);
    // Depending on how this is called (when is either 0 or a time in the
    // future) now will be the current time or when
    let sus = _sus + (sustain ? sustain : 0);
    let at = !when ? ctx.currentTime : when;
    let osc = ctx.createOscillator(); // Create and add to table if not already
    // Adding a random [0..1] value to the freq in an attempt to get rid of beating.
    // Ended up with a phaser effect when equal notes are played instead.
    osc.frequency.value = KeyFreq(key, _freq);
    osc.type = _waveforms[_waveformIdx];
    osc.onended = function(osc){ osc.disconnect(); }.bind(null, osc);
    osc.start(at);
    osc.stop(at + _att + sus + _rel);

    //DB.post("ASR", [_att, sus, _rel]);
    let gain = ctx.createGain();
    gain.gain.setValueAtTime(0, at);
    gain.gain.linearRampToValueAtTime(vol*_volume, at + _att);
    gain.gain.setValueAtTime         (vol*_volume, at + _att + sus);
    gain.gain.linearRampToValueAtTime(          0, at + _att + sus + _rel);

    osc.connect(gain);
    gain.connect(Destinations.input(_filterIdx));
  }

  let playing = [];
  let _playStart = function (key, vol) {
    let at = ctx.currentTime; // Start now
    let osc = ctx.createOscillator();
    osc.frequency.value = KeyFreq(key, _freq);
    osc.type = _waveforms[_waveformIdx];
    osc.start(at);
    osc.onended = function(osc){ osc.disconnect(); }.bind(null, osc);

    let gain = ctx.createGain();
    gain.gain.setValueAtTime(0, at);
    vol *= _volume;
    at += _att;
    gain.gain.linearRampToValueAtTime(vol, at);

    osc.connect(gain);
    gain.connect(Destinations.input(_filterIdx));

    playing[key] = [osc, gain, vol, at]; // Keep track of this oscillator and envelope
  }

  let _playStop = function (key) {
    if (playing[key] == undefined) { return; }

    let osc = playing[key][0]; // Recover osc and gain
    let gain = playing[key][1];
    let vol = playing[key][2];
    let at = Max(playing[key][3], ctx.currentTime);
    playing[key] = undefined;

    gain.gain.setValueAtTime(vol, at);
    at += _rel;
    gain.gain.linearRampToValueAtTime(0, at);
    osc.stop(at);
  }

  // Synthesizer message handler:  play/stop a note
  let listenerIBC = function (m) {
    let [chan, note, vol, time, sus] = m;
    if (chan != chanIn) { return; }
    if (sus != null) {
      _play(note, vol, time, sus); // One shot probably from sequencer to render entire ADSRd sound
    } else if (0===vol) {
      _playStop(note, vol);
    } else {
      _playStart(note, vol);
    }
  };

  (_nameDOM.onmousedown = function () {
    if (_nameDOM.style.background == "") {
      _nameDOM.style.background="#880";
      _ibcId = IBC.addListener(listenerIBC);
    } else {
      _nameDOM.style.background="";
      _ibcId = IBC.delListener(_ibcId);
    }
  })(); // Toggle the synths on and listening to MIDI

  Synthesizers.push(this);

  //// Public
  this.element = _element;
  this.color = color
  this.label = function () { return label; }
  this.chanIn = function () { return chanIn;  }
  this.adsr = function () { return [parseInt(_att*255), 0, parseInt(_sus*255), parseInt(_rel*255)]; }
  this.chanInSet = function (c) { midi.innerText=chanIn=c; return this; }
  this.attSet = function (att) { _att = att/255.0; }
  this.susSet = function (sus) { _sus = sus/255.0; }
  this.relSet = function (rel) { _rel = rel/255.0; }
  this.play = _play;
  this.wave = function () { return _waveformIdx; }
  this.waveform = function () { return _waveforms[_waveformIdx]; }
  var _lastKey = -1;
  this.highlight = function (key) {
    keyboard.unhighlight(_lastKey, color); // Remove last high-light
    keyboard.highlight(key, color); // Set new high-light
    _lastKey = key
  };
  this.unhighlight = function () {
    keyboard.unhighlight(_lastKey, color); // Remove last high-light
  };
  this.connect = function(d) {
    _filterIdx = d;
    _output.innerText = Destinations.name(d);
  };
  this.destination = function () { return _filterIdx; };

  this.name = function (key) {
    let note = key%12;
    let octave = Floor((key-12)/12); // MIDI octaves start at C-1 up to G9
    let noteLabel = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'][note];
    let nat = 1 == noteLabel.length; // Natural notes are 1 char long
    return nat ? noteLabel + (0==note?octave:"") : NBSP;
  }
  this.rowClass = function (key) {
    let note = key%12;
    let noteLabel = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'][note];
    let nat = 1 == noteLabel.length; // Natural notes are 1 char long
    return noteLabel.charAt(0) + (nat ? " nat" : " shp");
  }
  this.title = function (key) {
    let note = key%12;
    let octave = Floor((key-12)/12); // MIDI octaves start at C-1 up to G9
    let noteLabel = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'][note];
    return `${Trunc2(KeyFreq(key))}Hz  ${key}  ${noteLabel}${octave}`;
  }

} // Synthesizer



/******************************************************************************
  Create a single channel delay filter

  USAGE::
    var delay = Delay();

  CONSTRUCTOR PARAMETERS::
    ctx      A web audio context.

  METHODS::
    [n]         Get nth delay object
    .element    This object's element
    .name(key)  This filter's name
    .input()    Get the input port
    .export()   Return byte aray representing this instance.
******************************************************************************/
var Delay = (function (ctx, destinations) {
  //// Local
  let _name = "delay";
  let _del = 0.40; // Delay time
  let _gai = 0.50; // Attenuation

  let _destId = 0;
  let _destination;
  let _delay;
  let _gain;

  let make = function () {
    _gain  = ctx.createGain();
    _delay = ctx.createDelay(1);
    _delay.connect(_gain);
    _delay.delayTime.value = _del;
    _gain.gain.value = _gai;
    _gain.connect(_delay);
    _destination = Destinations.input(_destId); // Initial destination is global destination
    _gain.connect(_destination);
  };

  make();

  let _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";
  //_element.style.width = "13ch";

  let _nameDOM = CreateAppendChild('div', _element); // [ Delay1 ]
  _nameDOM.style.background="";
  _nameDOM.innerText = _name;

  let knobs = CreateAppendChild('div', _element); // [ Delay1 [ ] ]

  let _delSynth = CreateAppendChild('p', knobs);  // [ Delay1 [-] ]
  _delSynth.className="actor mustshift";
  _delSynth.innerText = "-";

  let _body = CreateAppendChild('div', _element);//  [ Delay1 [-] ]
  _body.className = "knobs";                     //  [            ]

  // Delay button
  // [ [Delay1] [-] ]
  // [ [delay]      ]
  // [ DLY ATN      ]
  // [ [main]       ]
  Knobify(CreateAppendChild('p', _body, "DLY"), (v)=>(_delay.delayTime.value=_del=v/100, Round(v)), ()=>_del*100).title="DELAY";
  Knobify(CreateAppendChild('p', _body, "ATN"), (v)=>(_gain.gain.value=_gai=v/100, Round(v)), ()=>_gai*100).title="ATTENUATION";
  CreateAppendChild('br', _body);
  let _output = CreateAppendChild('p', _body);
  _output.style.position = "relative"
  _output.className = "volume"
  _output.innerText = "[ctx]"
  _output.onmousedown = (event)=>self.connect(Destinations.nextId(_destId));

  // Public
  let self = [];

  self.element = _element;
  self.name = function () { return _name; }
  self.input = function () { return _gain; }
  self.getParams = function () { return [_del, _gai]; }
  self.setParams = function (ps) {
    _delay.delayTime.value = _del = ps[0];
    _gain.gain.value = _gai = ps[1];
  }
  // NEW
  self.dest = function () { return _destId; }
  // Update destination to passed in filter index otherwise update destination
  // if it changed in the filter stack.  Return true if a change occurred.
  self.connect = function (d) {
    if (d == null) {
      if (_destination != Destinations.input(_destId)) {
        make();
        return true;
      }
    } else {
      _gain.disconnect(_destination); // Is this needed?
      _destId = d;
      _destination = Destinations.input(_destId);
      _gain.connect(_destination);
      _output.innerText = Destinations.name(_destId);
    }
    return false;
  }
  self.export = function () {
    let bytes = [0]; // TYPE
    bytes.push(_name.length); // NAME LEN
    //DB("LK3 Filter " + d.name());
    _name.split('').map(b=>bytes.push(b.charCodeAt(0))); // NAME
    bytes.push(0); // Fake filter type.  for now the static delay and lowpass filters
    //DB("Params to write:" + ps);
    bytes.push(2);
    bytes.push(parseInt(_del*255.0));
    bytes.push(parseInt(_gai*255.0));
    return bytes;
  }
  Destinations.push(self);
  return self;
}).bind(null, ctx, Destinations); // Delay


/******************************************************************************
  Create a single channel lowpass filter

  USAGE::
    var delay = new Lowpass(ctx);

  CONSTRUCTOR PARAMETERS::
    ctx      A web audio context.

  METHODS::
    .element    This object's element
    .name()     This filter's name
    .input()    Get the input port
******************************************************************************/
var Lowpass = function (ctx, destinations) {
  //// Local
  let _name = "lp";
  let _f = .9; // Frequency
  let _q = 0.0; // Q this just resonates annoyingly when not. TODO: 0 Q always set to 0
  let _destId = 0;
  let _destination;
  let _lowpass;

  let make = function () {
    _lowpass = ctx.createBiquadFilter();
    _lowpass.frequency.value = 10000.0*(1.0-_f);
    _lowpass.Q.value = _q * 100.0;
    _destination = Destinations.input(_destId);
    _lowpass.connect(_destination); // New
  };
  make();

  let _element = document.createElement('div'); // [ ]
  _element.className = "windowmini";
  //_element.style.width = "13ch";

  let _nameDOM = CreateAppendChild('div', _element); // [ lowpass ]
  _nameDOM.style.background="";
  _nameDOM.innerText = _name;

  let knobs = CreateAppendChild('div', _element); // [ lowpass [ ] ]

  let _delSynth = CreateAppendChild('p', knobs);  // [ lowpass [-] ]
  _delSynth.className="actor mustshift";
  _delSynth.innerText = "-";

  let _body = CreateAppendChild('div', _element);//  [ lowpass [-] ]
  _body.className = "knobs";                     //  [            ]

  // Lowpass Buttons
  // [ [lp] [-] ]
  // [ FRQ      ]
  Knobify(
    CreateAppendChild('p', _body, "FRQ"),
    (v)=>{
      let osc = ctx.createOscillator();
      osc.frequency.value = 0;
      osc.start(0);
      osc.stop(ctx.currentTime+.05);  // 1/20th of a sec should be long enough
      osc.onended = ()=>osc.disconnect();
      osc.connect(_lowpass);
      _f=v/100;
      _lowpass.frequency.value = 10000.0*(1.0-_f);
      return Round(v);
    },
    (v)=>_f*100
  ).title="DELAY";

  //// Public
  let self = [];
  self.element = _element;
  self.name = function () { return _name; }
  self.input = function () { return _lowpass; }
  self.getParams = function () { return [_f, _q]; }
  self.setParams = function (ps) {
    _f = ps[0];
    _lowpass.frequency.value = 10000.0*(1.0-_f);
    // Q always set to 0
    //_q = ps[1];
    //_lowpass.Q.value = _q * 100.0;
  }
  // NEW
  self.dest = function () { return _destId; }
  // Update destination if it changed in the filter stack.  Return true if a change occurred.
  self.connect = function () {
    if (_destination != Destinations.input(_destId)) {
      _lowpass.disconnect(_destination); // Is this needed?
      make();
      return true;
    }
    return false;
  }
  self.export = function () {
    let bytes = [0]; // TYPE
    bytes.push(_name.length); // NAME LEN
    //DB("LK3 Filter " + d.name());
    _name.split('').map(b=>bytes.push(b.charCodeAt(0))); // NAME
    bytes.push(1); // Fake filter type.  for now the static delay and lowpass filters
    //DB("Params to write:" + ps);
    bytes.push(2);
    bytes.push(parseInt(_f*255.0));
    bytes.push(parseInt(_q*255.0));
    return bytes;
  }
  Destinations.push(self);
  return self;
}.bind(null, ctx, Destinations); // Lowpass


/******************************************************************************
  TickerTimer - Manage playback time

  Produce a beat range and time [from, to, time] representing the
  current beat range to process and at what (usually future) time.

  Ticks represent periodic time units that need to be sequentially
  considered when creating and emitting audio on time.  This will
  make sure enough ticks have been processed so that there is at most
  1 second of audio processed.

  Start rendering just a bit after currentTime?  No, doesn't seem to be
  a problem and a delay before starting is annoying anyways.

     ...---------------------------...
           ^  ^=========^=========^======== <samples written
 currentTime  tick0time tick1time lastTime
              ^render0

  tickCued   =  0;  -1     -1     -1    -1      -1
  let tick   = -1;  0      1      2      3      3
  let time   = -1;  100.25 100.50 100.75 101.00 101.00   (time+jiffy) - CurrentTime should be a second

  renderedCued = 0
  tickRender = -1;  -1     -1     -1     -1     0

          calls                     ctx.currentTime
  tickNext() => [0, 100.25]             100.00
  tickNext() => [1, 100.50]             100.10
  tickNext() => [2, 100.75]             100.15
  tickNext() => [3, 101.00]             100.19
  tickNext() => false                   100.20  when currentTime is over
  tickRender() => 0                     100.21
  tickRender() => false                 100.30
  tickRender() => 1                     100.32
  tickNext() => [4, 101.25]             100.35

  Idea:  base tick on CurrentTime - Time of last "first" tick.  The math will be just a sub and div

  New:
    Provides incremental beat ranges to process/render.
    Next start time to play is dynamic and based on last played.
    Current tick determined and used to calculate end time to play

  ClockDomain
    continuous increment of everything, epoch advances when cue rewinds
    
   EPOCH1-v   v-NOW  v-time  v-EPOCH2
      ----|---#------*--------

  BeatDomain
    cue cycles between cueStart and cueEnd.  cue and time align the two ranges

     cueStart-v    cue-v      v-cueEnd
      0---=---1---=---2---=---3
                        ^-cueNext


  Timer just increments from 0 to cueEnd-cueStart which is dynamic as cueEnd could change
  whereas cueStart won't change but cueStartNext can change.
  When end reached, resets to 0 and resets cueStart to 
******************************************************************************/
var TickerTimer = (function (ctx) {

  let lead_time = 0.0;  // seconds in the future to write/process audio (in case that's a problem)
  let buff_time = 1.0; // Output buffer in seconds

  let bps = 1;
  let subs = 1; // beat subdivisions, 1 or more, AKA ticks

  // tick domain
  let tickBeg = 0;
  let tickEnd = 0; // number of ticks to cycle over, 1 tick = 1/(bps*subs) seconds = 1/subs beats

  // beat domain
  let cueBeg = 0; // Timer beat start
  let cue = 0; // next beat to render at, cue2tick => floor(cue*subs)       cue2time => cue/bps
  let cueEnd = 0; // Timer beat end

  // real time domain
  let epoch = 0; // real time range began playing
  let time  = 0; // real time (possibly future) to play/process next, aligned with cue

  let playCallback = null; // Called when unpaused/resumed TODO: incorporate the scheduler into this object?

  let state = "pause"; // jause reset running

  // Debugging message
  var self = function () { };

  // TODO when bpm changes, epoch can change but it should be relative to realtime
  self.setBpm   = function (b) { bps=b/60;  epoch=time-cue/bps; return b; }
  self.bpm = function () { return bps*60; }
  self.setSubs = function (s)  {
    let orig = subs;
    tickBeg = Floor((tickBeg/orig)*subs);
    tickEnd = Ceil((tickEnd/orig)*subs)
    cueEnd = tickEnd/subs;
    return subs=s;
  }
  self.jiffy = function () { return 1 / bps / subs; }

  self.setBeg  = function (t) {
    if (t < tickEnd) { tickBeg = t; }
    return self;
  };

  self.setEnd  = function (t) {
    if (tickBeg<=t) {
      tickEnd = t+1; 
      cueEnd = tickEnd/subs;
    }
    return self;
  };

  self.getRange  = function () { return [tickBeg, tickEnd]; }
  self.tickRange = function () { return (tickEnd-tickBeg); }


  self.registerPlayCallback = function (f) { playCallback = f; }

  // Request the next beat range and time to render it, false implies pre buffer full.
  self.nextTick = function () {
    let now = ctx.currentTime;
    switch (state) {
    case "pause":
      cue = (now - epoch) * bps;
      time = now;
      return false;
    case "reset":
      cueBeg = cue = tickBeg / subs;
      cueEnd = tickEnd / subs;
      time = now + lead_time;
      epoch = time - cueBeg/bps;
      state = "running";
      break;
    case "resume":
      time = now + lead_time;
      epoch = time - cue/bps ;
      state = "running";
      break;
    case "running":
      break;
    default:
    }

    if (now+buff_time <= time) { return false; } // Buffer full, skip rendering

    let tick = Floor(cue * subs);
    let cueNext = (tick+1) / subs;
    if (cueNext <= cue) { cueNext = (tick+2) / subs; }
    let rewind = false;

    if (cueEnd <= cueNext) {
      cueNext = cueEnd;
      rewind = true;
    }

//DB(`${state} ${subs} [${tickBeg} ${tick} ${tickEnd}]\t[${cueBeg} ${cue} ${cueEnd} ${cueNext}]\t{${Trunc2(epoch)} ${Trunc2(time)}}`);

    let res = [cue, cueNext, time]

    if (rewind) {
      epoch += (cueEnd-cueBeg) / bps; // Advance epoch
      cueBeg = cue = tickBeg / subs;   // Reset cue beginning
    } else {
      cue = cueNext;
    }

    time = epoch + cue/bps

    return res; // make sure progress is made in case of rounding error

  }; // TickerTimer.nextTick()


  // Request the next rendering tick.  False implies tick hasn't moved. BF TODO this is outdated, parts might be misaligned
  self.nextRender = function () {
    return state=="pause" ? false : self.currentTick();
  }

  self.tick = self;
  self.pause = function (e)  {
    if (state != "pause") { // Switch into pause mode?
      state = "pause";
      Destinations.cut(); // halt external sound immediately
    } else {
      state = "resume";
      playCallback();
    }
    blinkify(e, (state=="pause")&&"#f00");
  };
  self.rewind = function (e, newTick) {
    if ("pause" == state) {
      state = "reset";
      playCallback();
    } else {
      state = "reset";
    }
    return self;
  };

  self.now = () => ctx.currentTime;

  self.currentTick = function (adj) {
    let now = ctx.currentTime + (adj||0);
    let ticks = tickEnd - tickBeg;
    return (Floor((now - epoch) * bps * subs) - tickBeg + ticks) % ticks + tickBeg;
  }
  self.isPaused = function () { return state=="pause"; }
  self.lastTime = function () { return time + self.jiffy(); }
  self.bpm = function () { return bps*60; }
  self.bps = function () { return bps; }
  self.subs = function () { return subs; }
  return self;
})(ctx); // TickerTimer


/******************************************************************************
  Sheet - Manage parts on a dynamic phrase/sheet.

  METHODS

    .playTicksAt(tick, time)  Play all notes in each part on this tick.

******************************************************************************/
var Sheet = function (id, tickertimer) {
  let element = ElementById(id);
  let children = element.children;
  let knobs = element.previousElementSibling;
  let columns = []; // Array of columns [ [header part ... ] ... ]
  let parts = []; // List of all Part objects created.  Their elements will be scattered about the ticks.
  let markedTick = null;
  let beats = 0; // total beat count
  let subs = 0;  // beat subdivisions (changes with zoom)

  // Object

  let self = function () { };
  self.element = function () { return element; }
  self.columns = function () { return columns; }
  self.partAdd = function (p) { parts.push(p); return self; }
  self.subs = ()=>subs;
  self.tickCount = function () { return beats * (subs+1); }

  self.partsResetZ = function () {
    parts.forEach( p => p.element().style.zIndex="" );
  }
  self.refreshHeader = function () {
    let [start, end] = self.getRange();
    for (let i=0; i < self.tickCount(); i++) {
      columns[i].firstChild.style.backgroundColor = (i<start || (end-1)<i) ? "#444" : "";
    }
  }
  self.setBeg = function (t) { tickertimer.setBeg(t); self.refreshHeader(); return self; }
  self.setEnd = function (t) { tickertimer.setEnd(t); self.refreshHeader(); return self; }

  self.getRange = function () {
    let ret = tickertimer.getRange();
    return ret;
  }

  // Called for a sheet tick/column either by the timer or mouseover.
  self.playTicksAt = function (tick, time) {
    parts.forEach((p)=>{
      let a = eval(tick);
      let b = a+1/(subs+1);
      p.playRange(a, b, time); // Play its notes along its tick
    });
  }

  self.playRange = function (range) {
    let [from, to, time] = range;
    parts.forEach((p)=>{
      p.playRange(from, to, time); // Play its notes along its tick
    });
  }

  self.tickerTimer = () => tickertimer;
  self.pause = function (e) { tickertimer.pause(e); }
  self.isPaused = () => tickertimer.isPaused();
  self.rewind = function (e) { tickertimer.rewind(e); }
  self.jump   = function (e) { tickertimer.rewind(e, markedTick); }

  self.tickWidth = () => children[0].getBoundingClientRect().width;

  self.winTicks = function () {
    // Zooming in Chrome alters these so they must be dynamically queried
    let tickWidth = self.tickWidth();
    let windowWidth = element.getBoundingClientRect().width;
    let visibleTickCount = Round(windowWidth / tickWidth);

    let leftVisibleTick = Round((element.scrollLeft) / tickWidth);
    let rightVisibleTick = Min(leftVisibleTick + visibleTickCount, children.length) - 1;
    return [leftVisibleTick, rightVisibleTick];
  };

  // Scroll (maybe) the grid so current tick is visible
  let state = 1; // 0:reset  1:center  2:fixed  3:stick
  let winTicksLast = [0, 0]; // DEBUGGING mark left/right visible ticks in sheet window
  let fixedOffset = 0;
  let lastTickElementRendered = false;
  self.render = function (tick) {

    let visible = self.winTicks();
    let winwidth = visible[1] - visible[0];

    let [tickLeft, tickRight] = self.getRange();
    let tickwidth = tickRight - tickLeft;

    let userScrolledWin = winTicksLast.cmp(visible);
    let ticksInWin = visible[0]<=tickLeft && tickRight <=visible[1];

    if (!ticksInWin) {
      // Did the user scroll the window? (the visible ticks don't match last render)
      if (!userScrolledWin) {
        if (visible[0]<= tick && tick <= visible[1]) {
          state = 2; // Scrolling while the current tick is visible will reposition the tick's highlight
          fixedOffset = tick - visible[0];
        } else {
          state = 3; // Scrolling the tick outside the visible window will disable automatic scrolling
        }
      }

      let newWinLeft = undefined;
      if (1 == state) {
        let tickWidth = self.tickWidth(); // Added this
        let windowWidth = element.getBoundingClientRect().width; // Added this
        let visibleTickCount = Round(windowWidth / tickWidth); // Added this
        newWinLeft = Max( tick-visibleTickCount/2, self.getRange()[0] );
      } else if (2 == state) {
        newWinLeft = Max( tick-fixedOffset, self.getRange()[0] );
      }

      //adjust newWinLeft so right side of window is at right tick
      if (tickRight < newWinLeft + winwidth) {
        newWinLeft = tickRight - winwidth;
      }

      element.scrollLeft = newWinLeft * self.tickWidth(); // Update window scroll position.
    }

    // Highlight the full vertical tick
    if (lastTickElementRendered) { lastTickElementRendered.className=""; }

    (lastTickElementRendered=children[tick]).className="phrasehighlight";
    // Remember state
    winTicksLast = self.winTicks();
  } // Sheet.render(tick)

  // Create a tick column and its top row tick mark. This is a dynamic placeholder for Parts.
  let lastHoverTick = 0;
  let hoverState = 0;
  self.createTickColumn = function (beat, tick, label) {
    let column = document.createElement('div'); // Create the tick column

    // Tick column's header
    let header = CreateAppendChild('p', column, label).setStyle("background-color", "#444");

    // Hovering will play all ticks in each part.
    header.onmouseover = function () {
      let t = beat*(subs+1)+tick;
      if (t == lastHoverTick) { hoverState=0; header.innerText = "*"; }
      else if (t < lastHoverTick) { hoverState=-1; header.innerText = "<"; }
      else { hoverState=1; header.innerText = ">"; }
      lastHoverTick = t;
      if (brushToPlay()) { self.playTicksAt(header.title, 0); }
    };
    header.onmouseleave = function () {
      header.innerText = label;
    }

    header.onmousedown = function (e) { // Handle updating sheet's start/end playback ticks and repeat marker
      let t = Floor(beat*(subs+1)+tick);
      if (hoverState==1) { self.setEnd(t); }
      else if (hoverState==0) {
        // Handle marked tick in phrase sheet's header
        if (markedTick != null) { columns[markedTick].firstChild.style.color = ""; }
        if (markedTick == t) {
          markedTick = null;
        } else {
          columns[markedTick=t].firstChild.style.color = "black";
        }
      } else {
        self.setBeg(t);
      }
    };
    return column;
  }; // Sheet.createTickColumn(beat, tick, label)

  let fixTickTimes = function () {
    let beat = 0;
    let sub = 0;
    columns.forEach( (column)=>{
      column.firstChild.title = `${beat}+${sub}/${subs+1}`;
      if (sub++==subs) { sub=0; ++beat; }
    } );
    tickertimer.setSubs(subs+1);
  }

  let updatePartsBeatWidthInvariants = function () {
    parts.forEach( p=>p.updateBeatWidthInvariants() ); // BF TODO FIX FOR REFS
  }

  let countLastSubsWithPart = function () {
    return columns.filter( (c,i) => !((1+i)%(subs+1)) && 1<c.childElementCount ).length
  }

  self.deleteSubbeats = function () {
    let rangeOriginal = self.getRange();
    if (!subs || countLastSubsWithPart()) return;


    RangeForEach( beats, beat=>{
      let tick = columns[beat*subs+subs];
      tick.remove();
      columns.splice(beat*subs+subs, 1);
    });

    subs--;
    fixTickTimes();
    updatePartsBeatWidthInvariants();
    self.setBeg(Floor(rangeOriginal[0]*(subs+1)/(subs+2)));
    self.setEnd(Floor(rangeOriginal[1]*(subs+1)/(subs+2)));
  }

  self.insertSubbeats = function () {
    let rangeOriginal = self.getRange();

    let glyph = "-";
    //subs.push(splitCount); // subdivisions (initially 0)

    subs++;
    RangeForEach(beats, beatIdx=>{
      let tick = columns[beatIdx*(subs+1)+(subs-1)];
      let newTick = self.createTickColumn(beatIdx, subs, glyph);
      tick.insertAdjacentElement('afterend', newTick);
      columns.splice(beatIdx*(subs+1)+subs, 0, newTick);
    });
    fixTickTimes();
    updatePartsBeatWidthInvariants();

    self.setBeg(Floor(rangeOriginal[0]*(subs+1)/(subs)));
    self.setEnd(Floor(rangeOriginal[1]*(subs+1)/(subs)));
  };

  self.beatWidth = function () { return subs+1; }

  self.appendBeat = function () {
    let tick = self.createTickColumn(beats++, 0, (beats-1)%8);
    columns.push(tick); // Keep track of the column
    element.appendChild(tick);

    RangeForEach(subs, (subIdx, idx)=>{
      let tick = self.createTickColumn(beats-1, idx+1, '-');
      element.appendChild(tick);
      columns.push(tick); // Keep track of the column
    });

    fixTickTimes();
  };

  self.moveElement = (tick, element) => {
    while (!children[tick]) { self.appendBeat(); }
    children[tick].appendChild(element);
  };

  self.parts = () => parts;

  document.getElementById('createphrasedrum')
    .onmousedown = function () { Part(self,  subs*2, 2*20, 24, 16, Drums[0]); };

  document.getElementById('createphrasesynth')
    .onmousedown = function () { Part(self, subs*2, 2*20, 21, 88, Synthesizers[0]); };

  document.getElementById('zoom').onmousedown = function (a,b) {
    switch (event.target.innerText) {
      case "|": self.deleteSubbeats(); break;
      case "|-": self.insertSubbeats(); break;
    }
  };

  // Add a brushToPlay toggle button
  let brushToPlay = AppendNewToggleActor(knobs, false, "actor",
    ()=>(columns.forEach(t=>t.firstChild.style.color="#8ff"), ")("),
    ()=>(columns.forEach(t=>t.firstChild.style.color="inherit"), "()"));
  brushToPlay.element().title="BRUSH PLAY";

  // Reset the TickerTimer state object
  tickertimer
    .setEnd(self.tickCount()-1)
    .setBeg(0);

  return self;
}; // Sheet


/******************************************************************************
  RefPart - References a Part.  Behaves the same as a part to a sheet.
******************************************************************************/
var RefPart = function (partObj, tickIdx, height) {
  let sheet = partObj.sheet();
  let sheetElement = sheet.element();
  let timer = sheet.tickerTimer();

  // Creat part window
  let ref = CreateAppendChild('div', sheetElement.children[tickIdx]);
  ref.className = "window";
  ref.style.top = Max(height, sheetElement.firstChild.firstChild.scrollHeight)+"px";

  // Header - left most cells of row
  let title = CreateAppendChild('div', ref, `*${partObj.titleName()}`);
  title.className = "actor";
  title.title = "MOVE,MINIMIZE";
  title.contentEditable = true;

  let knobs = CreateAppendChild('div', ref);
  knobs.className = "knobs";

  let body = CreateAppendChild('div', ref);
  body.className = "part";

  // Grid tick header
  let elHeaderTicks = CreateAppendChild('div', body);

  // BF TODO parent part should update the ref's header on demand
  // Copy parent part's header
  RangeForEach( partObj.tickCount(), (tick)=> {
    let headerTick = partObj.headerTick(tick);
    CreateAppendChild('p', elHeaderTicks, headerTick.innerText)
      .onmouseover = ()=> brushToPlay() && partObj.playTick(headerTick.title, 0);
  } );

  // Behavior

  // brushToPlay knob
  let brushToPlay = AppendNewToggleActor(knobs, false, "actor",
    () => (elHeaderTicks.style.color=null, ")("),
    () => (elHeaderTicks.style.color="", "()"));
  brushToPlay.element().title="BRUSH PLAY";

  title.onmousedown = function (e) {
    if (e.button != 0) { return; }
    MouseIsDown = true; // Set global state

    self.focus();

    // Drag/Move part within sheet

    let tickHeight = sheetElement.firstChild.firstChild.scrollHeight+1;
    let tickWidth  = sheetElement.lastChild.offsetLeft / (sheetElement.childElementCount-1); // Tick width take average width of all ticks
    let leftMargin = sheetElement.offsetLeft-sheetElement.scrollLeft; // Account for element's margin and scrolled offset
    sheetElement.onmousemove = function (offset, e) {
       if (!MouseIsDown) { sheetElement.onmousemove = null; return; } // Maybe stop handling this event
       // Adjust ref's vertical position
       ref.style.top = Max(offset + e.y, tickHeight) + "px";
       // Adjust ref's horizontal position (Phrase's tick)
       let newTick = Floor((e.x-leftMargin+1) / tickWidth);
       if (newTick != tickIdx) {
         sheetElement.children[newTick].appendChild(ref);
         tickIdx = newTick;
       }
    }.bind(null, ref.offsetTop-e.y);
  };

  // Title editing.
  title.onkeydown = function (v) {
    event.stopPropagation(); // Don't bubble the event elsewhere (global controls),
    if (v.code == "Enter") {
      v.preventDefault(); // Prevent form element from adding a newline
    }
  }

  let self = ()=>{};

  self.element = () => ref;
  self.isInRange = function (t) { // BF TODO FIX
    return tickIdx <= t && t < tickIdx + partObj.tickCount();
  }
  self.play = (gtick, time) => {
    partObj.playTick(gtick - tickIdx, time);
  }
  self.focus = () => { // Raise/focus this element in sheet and reset others
    sheet.partsResetZ();
    ref.style.zIndex = 1;
  }

  self.playRange = function (from, to, time) {
    let via = eval(ref.parentElement.firstChild.title);
    partObj.playRangeVia(via, from, to, time);
  }

  self.updateBeatWidthInvariants = function () {
    DB("RefPart.updateBeatWidthInvariants ignored");
  }

  sheet.partAdd(self);
  self.focus();

  return self;
}; // RefPart


/******************************************************************************
  Part

  Model a musical part which currently is a drawable grid of notes that are
  broadcast to anything listening on it's output channel.  It's basically a
  MIDI device.  It also has an input listener for similar note messages.

******************************************************************************/
var Part = function (sheetObj, tickIdx, height, keyBeg, keyCount, playable) {
  let chanIn  = 0;
  let volume = 1.0;
  let chanOut = playable instanceof Synthesizer ? 4 : 3;
  let sheet = sheetObj.element(); // Parent object's element
  let timer = sheetObj.tickerTimer();
  //let TickCount = 0; // TODO outdated concept
  let divisions = [0]; // [beats, subdivisions...] IE [3 2 3] == @..-..@..-..@..-..

  // Creat part window
  // []
  let part = CreateAppendChild('div', sheet.children[tickIdx]); // The Part element
  part.className = "window";
  part.style.top = Max(height, sheet.firstChild.firstChild.scrollHeight)+"px";

  // Header - left most cells of row
  let title = CreateAppendChild('div', part, "Part");
  title.className = "actor";
  title.title="MOVE,MINIMIZE";
  title.contentEditable = true;

  let knobs = CreateAppendChild('div', part);
  knobs.className = "knobs";

  let body = CreateAppendChild('div', part);
  body.className="part";

  // Grid tick header IE  @.-.+.-.@.-.+.-.@.-.+.-.@.-.+.-.
  let elHeaderTicks = CreateAppendChild('div', body);

  elHeaderTicks.onmouseover = function () {
    if (brushToPlay()) {
      self.playTick(event.target.title, 0);
      //IBC([chanOut, key, 1.0, 0, 0]);
    }
  };

  // Container of voices containing a label and ticks
  let grid = CreateAppendChild('div', body);
  let rows = [];
  let recording = false;
  let drawCh = undefined;
  let drawHold = undefined;

  RangeForEach(keyCount, (y) => {
    let key = keyBeg + y;
    // [ ]
    let row = CreateInsertChild("div", grid)  // A row: Container of label and ticks
      .setClassAndTitle(playable.rowClass(key), playable.title(key));
    rows.push(row);
    // [ header ]
    let label = playable.name(key);
    let header = CreateAppendChild("p", row, label);

    // [ label [] ]
    let notes = CreateAppendChild("div", row); // Row of ticks initially empty

    notes.onmouseover = function () {
      if (MouseIsDown) {
        drawHold = false;
        event.target.innerText = drawCh; // Continue painting
      } else {
        if (event.target.innerText == "*" && brushToPlay()) {
          self.playNote(keyCount-y-1, event.target.title, 0);
          //IBC([chanOut, key, 1.0, 0, 0]);
        }
      }
    };

    // Save note if label clicked and recording enabled
    header.onmousedown = ()=>{
      MouseIsDown = true;
      if (!sheetObj.isPaused() && recording) {
        row.children[1]
          .children[timer.currentTick() - sheetTick()]
          .innerText = "*";
      }
      IBC([chanOut, key, 1.0]); // Broadcast note-down
    };
    header.onmouseup = ()=> IBC([chanOut, key, 0]); // Broadcast note-up
    header.onmouseover = ()=> MouseIsDown && IBC([chanOut, key, 1.0]);
    header.onmouseleave = ()=> MouseIsDown && IBC([chanOut, key, 0]);
  });

  let beatToTick = function (tick) {
    let [beat, sub, divs] = tick.split(/[+/]/).map(n=>parseInt(n));
    return beat*divs + sub;
  }

  let sheetTick = function () {
    return beatToTick(part.parentElement.children[0].title);
  }

  let subToGlyph = function (depth) {
    return depth<=4 ? ['?', '|', '=', '+', '-'][depth] : '.';
  };

  let tickCount = function () {
    return divisions.reduce((p,n)=>p*n);
  }
  let subTickCount = function (upTo) {
    let s = divisions.slice(1, upTo&&++upTo);
    return s.length ? s.reduce((p,n)=>p*n) : 1;
  }

  // Adjust CSS to view visible part ticks based on sheet tick "zoom" level
  let updateBeatWidthInvariants = function () {
    let sheetBeatWidth=sheetObj.beatWidth();
    let beats = divisions[0];

    let width=1;
    body.className="part"; // visible beats added to this "part d2 d3..."
    RangeForEach([1, divisions.length-1], (div)=>{
      if (sheetBeatWidth < (width *= divisions[div])) { return; }
      body.className += ` d${++div}`;
    });
    elHeaderTicks.style.width = `${beats*sheetBeatWidth}ch`;

    RangeForEach(keyCount, (y) => {
      rows[y].children[1].style.width=`${beats*sheetBeatWidth}ch`;
    });

    addBeat.title = `[${divisions}]${tickCount()}`;
  }

  let insertSubbeats = function (subs) {
    if (0 == divisions[0]) { return; }
    insertHeaderSubbeats(subs);
    insertNotesSubbeats(subs);
    recalculateBeatValues();
  }

  let insertHeaderSubbeats = function (subs) {
    divisions.push(subs);
    updateBeatWidthInvariants();
    let divs = divisions.length;
    let glyph = subToGlyph(divs-1);
    let subTicks = subTickCount();
    let offset = 0;
    [...elHeaderTicks.children].forEach( (sibling)=>{
      ++offset; // adjust for existing tick
      RangeForEach(subs-1, (n)=> {
        sibling = CreateAfterSibling('p', sibling, glyph)
          .setClassAndTitle(
            `d${divs}`,
            `${parseInt(sibling.title)}+${offset++%subTicks}/${subTicks}`
          );
      } );
    } );
  };

  let insertNotesSubbeats = function (subs) {
    let divs = divisions.length;
    let subTicks = subTickCount();
    let offset = 0;
    RangeForEach(keyCount, (y)=>{
      let notes = rows[y].children[1];
      [...notes.children].forEach( (sibling)=>{
        ++offset; // adjust for existing tick
        RangeForEach(subs-1, ()=>{
          let el = CreateAfterSibling('p', sibling, NBSP)
            .setClassAndTitle(
              `d${divs}`,
              `${parseInt(sibling.title)}+${offset++%subTicks}/${subTicks}`
          );
          addTickAction(el);
          sibling = el;
        });
      });
    });
  };

  let recalculateBeatValues = function () {
    RangeForEach(keyCount, (y)=>{
      let beat = 0;
      let sub = 0;
      let subs = subTickCount();
      [...rows[y].children[1].children].forEach((t,i)=>{
        elHeaderTicks.children[i].title = t.title = `${beat}+${sub}/${subs}`;
        if (++sub == subs) { beat++; sub=0; }
      });
    });
  }

  let appendBeat = function () {
    appendHeaderBeat();
    appendNotesBeat();
    recalculateBeatValues();
  }

  let appendHeaderBeat = function () {
    divisions[0]++;
    updateBeatWidthInvariants();
    CreateAppendChild('p', elHeaderTicks, "@")
      .setClassAndTitle("d1", `${divisions[0]-1}+0/1`);
    appendHeaderSubbeats_(1, 0);
  };

  let appendHeaderSubbeats_ = function (depth, offset) {
    if (divisions.length <= depth) return;
    let depthNext = depth+1;
    let nextDivision = divisions[depthNext];
    let beat = divisions[0]-1;
    let ticks = subTickCount(depth);
    let div = divisions[depth]-1;
    RangeForEach(div, (i)=>{
      let tick = offset + i;
      appendHeaderSubbeats_(depthNext, tick*nextDivision);
      CreateAppendChild('p', elHeaderTicks, subToGlyph(depth))
        .setClassAndTitle(
          `d${depthNext}`,
          `${beat}+${tick+1}/${ticks}`);
    });
    appendHeaderSubbeats_(depthNext, (offset+div)*nextDivision);
  };
 
  // Add beat to each voice's notes
  let appendNotesBeat = function () {
    RangeForEach(keyCount, (y) => {
      let notes = rows[y].children[1];
      let tick = CreateAppendChild('p', notes, NBSP)
        .setClassAndTitle("d1", `${divisions[0]-1}+0/1`);
      addTickAction(tick);
      appendNotesSubbeats_(notes, y, 1, 0);
    });
  };

  let appendNotesSubbeats_ = function (notes, y, depth, offset) {
    if (divisions.length <= depth) return;
    let depthNext = depth+1;
    let nextDivision = divisions[depthNext];
    let beat = divisions[0]-1;
    let ticks = subTickCount(depth);
    let div = divisions[depth]-1;
    RangeForEach(div, (i)=>{
      let tick = offset + i;
      appendNotesSubbeats_(notes, y, depthNext, tick*nextDivision);
      let el = CreateAppendChild('p', notes, NBSP)
        .setClassAndTitle(
          `d${depthNext}`,
          `${beat}+${tick+1}/${ticks}`
        );
      addTickAction(el);
    });
    appendNotesSubbeats_(notes, y, depthNext, (offset+div)*nextDivision);
  };

  let addTickAction = function (elTick) {
    // Action Clicking
    elTick.onmousedown = function (e) {
      MouseIsDown = true; // Set global state
      let ch = e.target.innerText;
      if (NBSP == ch) {
        e.target.innerText = drawCh = '*';
        drawHold = true;
        setTimeout( ()=>(drawHold && (drawCh='-')), 250); // After 200ms draw dash if nothing drawn yet.
        self.playTick(elTick.title, 0); // When drawing a new note, play full tick (all notes)
      } else {
        drawCh= NBSP;
        e.target.innerText = NBSP;
      }
    }
  }

  // Part channel in listener handler: Like clicking a row label
  IBC.addListener( (m) => {
    let [chan, note, vol, when, sus] = m;
    if (chan != chanIn || note < keyBeg || keyBeg+keyCount <= note) { return; }
    // Record note if key-down, not paused, and recording enabled
    if (recording && vol && !sheetObj.isPaused()) {
      // Rows are in reverse order, also compensate for the first supported MIDI note
      let row = keyCount - (note - keyBeg) - 1;
      let tick = timer.currentTick( timer.jiffy()/2 )-tickIdx; // Adjust by half a jiffy so performing can be near the beat/tick instead of on or after it as is done by the tick highlighting renderer.
      grid.children[row].children[1].children[tick].innerText = "*";
    }
    // Broadcast the note
    IBC([chanOut, note, vol, when, sus]);
  });

  // Volume/Velocity value
  Knobify(CreateAppendChild('p', knobs, "VOL"), (v)=>(volume=v/100, Round(v)), ()=>volume*100, .1, 0, 100, [100, 80, 50, 20, 0]).title="VOLUME";

  // Midi channel in number button
  let midiIn = CreateAppendChild('p', knobs, chanIn);
  midiIn.className = "actor";
  midiIn.title = "CHANNEL IN";
  midiIn.onmousedown = (e) => {
    if (e.button == 0) { 0<chanIn && --chanIn; };
    if (e.button == 2) { chanIn<15 && ++chanIn; };
    midiIn.innerText = chanIn;
  };

  let newRef = CreateAppendChild('p', knobs, "*");
  newRef.className = "actor";
  newRef.title = "NEW REF";
  newRef.onmousedown = () => RefPart(self, tickIdx, height+2*21);

  // Toggle brushToPlay knob
  let brushToPlay = AppendNewToggleActor(knobs, false, "actor",
    () => (elHeaderTicks.style.color=null, ")("),
    () => (elHeaderTicks.style.color="inherit", "()"));
  brushToPlay.element().title="BRUSH PLAY";

  // "Clear all ticks" button
  let clearKnob = CreateAppendChild('p', knobs, "X");
  clearKnob.className = "actor mustshift";
  clearKnob.title = "DELETE NOTES";
  clearKnob.onmousedown = function (e) {
    if (!e.shiftKey) { return; }
    RangeForEach(keyCount, (y) => {
      RangeForEach(tickCount(), (x) => {
        grid.children[y].children[1].children[x].innerText=NBSP;
      })
    })
  }

  // Toggle recording button
  CreateAppendChild('p', knobs, "#")
    .setClassAndTitle("actor", "RECORD")
    .setEventListener("mousedown", function(){
      this.style.background = (recording ^= true) ? "#800" : ""
    });

  // Midi channel out number button
  let midiOut = CreateAppendChild('p', knobs, chanOut);
  midiOut.className = "actor";
  midiOut.title = "CHANNEL OUT";
  midiOut.onmousedown = (e) => {
    if (e.button == 0) { 0<chanOut && --chanOut; };
    if (e.button == 2) { chanOut<15 && ++chanOut; };
    midiOut.innerText = chanOut;
  };

  let addBeat = CreateAppendChild('p', knobs, '@')
    .setClassAndTitle("actor", "[]0")
    .setEventListener("mousedown", appendBeat);

  let subBeatByHalf = CreateAppendChild('p', knobs, '/2');
  subBeatByHalf.onmousedown = insertSubbeats.bind(null, 2);
  subBeatByHalf.className = "actor";

  let subBeatByThird = CreateAppendChild('p', knobs, '/3');
  subBeatByThird.onmousedown = insertSubbeats.bind(null, 3);
  subBeatByThird.className = "actor";

  // Clicking title will raise it.  Dragging title will move it around the sheet
  title.onmousedown = function (e) {
    // Right click on title toggle minimization but right button + meta bring up browser menu
    if (e.button == 2 && !e.metaKey) {
      ToggleElementDisplay(grid);
      event.stopPropagation(); // Keep event from elements
      return;
    }
    if (e.button != 0) { return; }
    MouseIsDown = true; // Set global state
    self.focus();
    // Drag/Move part within sheet
    let tickHeight = sheet.firstChild.firstChild.scrollHeight+1;
    let tickWidth  = sheet.lastChild.offsetLeft / (sheet.childElementCount-1); // Tick width take average width of all ticks
    let leftMargin = sheet.offsetLeft-sheet.scrollLeft; // Account for element's margin and scrolled offset
    sheet.onmousemove = function (offset, e) {
       if (!MouseIsDown) { sheet.onmousemove = null; return; } // Maybe stop handling this event
       // Adjust part's vertical position
       part.style.top = Max(offset + e.y, tickHeight) + "px";
       // Adjust part's horizontal position (Phrase's tick)
       let newTick = Floor((e.x-leftMargin+1) / tickWidth);
       if (newTick != tickIdx) {
         sheetObj.moveElement(tickIdx=newTick, part);
       }
    }.bind(null, part.offsetTop-e.y);
  };

  // Title editing.
  title.onkeydown = function (v) {
    event.stopPropagation(); // Don't bubble the event elsewhere (global controls),
    if (v.code == "Enter") {
      v.preventDefault(); // Prevent form element from adding a newline
    }
  }

  // The Object

  let self = function () { };
  sheetObj.partAdd(self); // Add to parent sheet

  self.element = ()=> part;
  self.titleName = ()=> title.innerText;
  self.tickCount = tickCount;
  self.headerTicks = function () { return elHeaderTicks; };
  self.headerTick = function (tick) { return elHeaderTicks.children[tick]; };
  self.sheet = ()=> sheetObj;
  self.setVolume = function (v) { volume=v; return self; }
  self.setStartTick = function (tick) { tickIdx = tick; }
  self.startTick = function () { return tickIdx; }
  self.divisions = ()=>divisions;
  self.appendBeat = appendBeat;
  self.insertSubbeats = insertSubbeats;
  self.isInRange = function (a, b) {
    let start = eval(part.parentElement.firstChild.title);
    let end = start + divisions[0];
    return start<b && a<=end && [start, end];
  }

  self.playRangeVia = function (via, from, to, time) {
    time = time || ctx.currentTime; //0 indicates play immediately
    let start = via;
    let end = start + divisions[0];
    if (to<start || end<=from) { return; } // return if play range does't overlap part
    [...elHeaderTicks.children].forEach( (note)=>{ // over each part tick...
      let t = eval(note.title) + start; // consider tick's sheet beat time
      if (from<=t && t<to) {
        self.playTick(note.title, time+(t-from)/TickerTimer.bps()); // adjust play time if not aligned on tick
      }
    });
  }

  self.playRange = function (from, to, time) {
    let via = eval(part.parentElement.firstChild.title);
    self.playRangeVia(via, from, to, time);
  }

  // Called by global conductor
  self.play = function (gtick, time) { self.playTick(gtick - tickIdx, time); }

  // Called by player/self
  self.playTick = function (tick, time) {
    RangeForEach(keyCount, (y)=>self.playNote(y, tick, time));
  }

  self.updateBeatWidthInvariants = updateBeatWidthInvariants;

  self.playNote = function (row, tick, time) {
    if (row < 0 || keyCount <= row) {
      DB.error(`row ${row} out of range 0..${keyCount-1}`);
      return;
    }
    let notes = rows[keyCount-row-1].children[1];

    let idx = beatToTick(tick);
    let note = notes.children[idx];
    if (!note || note.innerText != "*") { return; }

    let tickCount = self.tickCount();
    let tickNext = idx+1;
    while (tickNext<tickCount && "-"==notes.children[tickNext].innerText) { ++tickNext; }
    let sustain = (tickNext-idx-1)/(subTickCount()*TickerTimer.bps());
    IBC([chanOut, keyBeg + keyCount-row-1, volume, time, sustain]) // chan note vol time sus
  };

  self.focus = () => { // Raise/focus this element in sheet and reset others
    sheetObj.partsResetZ();
    part.style.zIndex = 1;
  }

  self.setTick = function (row, tick) {
    rows[row].children[1].children[tick].innerText = '*';
  }

  self.chanOutSet = function (c) { midiOut.innerText=chanOut=c; return this; }

  self.toggleDisplay = function () { ToggleElementDisplay(grid); }

  return self;
} // Part



/******************************************************************************
 Runtime
******************************************************************************/
var knobVolume;
var knobBpm;

var setupControls = function (keyboard, sheet) {

  knobVolume = Knobify("mainVolume",
    (v)=>((Destinations.input(0).gain.value=v/100),Round(v)), // Unit-normalize the gain
    ()=>Destinations.input(0).gain.value*100,
    .1, 0, 100,
    [100, 75, 50, 25, 0]);

  knobBpm = Knobify("bpm",
    (v)=>TickerTimer.setBpm(Trunc1(v)),
    ()=>TickerTimer.bpm(),
    .01, 1, 666,
    [190, 120, 90, 60, 30, 20, 10]);


  window.onmouseup = function () { MouseIsDown = false; }

  // Global hot keys
  window.onkeydown = function (v) {
    if (v.code == "Slash") DB.clear(); // Pressing '/' will clear the DB (debug console) element.
    let pauseElement = ElementById("pause");
    if (v.code == "KeyP") { sheet.pause(pauseElement); }
    else if (v.code == "KeyR") { sheet.rewind(pauseElement); } // Rewind the playback.
    else if (v.code == "Space") { // Pause or jump to mark
      sheet.isPaused()
        ? sheet.jump(pauseElement)
        : sheet.pause(pauseElement);
      v.preventDefault(); // Prevent space from scrolling browser window
    }
  }

  // Browser menu activated only with meta key.  The mouse event capture will
  // be stopped early if meta+mouse3 and the contextmenu bubble will only
  // bubble out if meta is active.
  window.addEventListener(
    "mousedown",
    (v) => v.metaKey && v.button==2 && v.stopPropagation(),
    true);
  window.oncontextmenu = (v) => v.metaKey || v.preventDefault();

  // Prevent tablets and phones from scrolling and resizing?
  document.body.addEventListener(
    'touchstart',
    function (event) {
      if (event.touches.length=='fack') {
        event.preventDefault();
      }
      DB(event.touches);
    },
    true);

}; //setupControls


var eventLoops = function (sheet) {
  (function processHandlerLoop () {
//DB.log("eventLoops", sheet);
    let ticktime = TickerTimer.nextTick(); // [tick to process, time audio is written/buffered]
    if (ticktime !== false) {
      sheet.playRange(ticktime);
      setTimeout(processHandlerLoop, 1000 * TickerTimer.jiffy()/4); // Fill buffer within 4 jiffies TODO BF is /4 still usefull?
    } else if (!TickerTimer.isPaused()) {
      setTimeout(processHandlerLoop, 1000 * TickerTimer.jiffy());
    }
    // else paused, loop ends
  })();
  (function renderHandlerLoop () {
    var tick = TickerTimer.nextRender();
    if (tick !== false ) {
      sheet.render(tick);
      setTimeout(renderHandlerLoop, 1000 * TickerTimer.jiffy()-10); // Next update in a jiffy
    } else if (!TickerTimer.isPaused()) {
      setTimeout(renderHandlerLoop, 10); // Try again very soon
    }
    // else paused, loop ends
  })();
}


var restoreSongLK3 = function (keyboard, drumKit, encodedSong) {
  let gs = new GetStringBase64(encodedSong);
  let next, b, label, d;
  let synthCount = 0;
  let sheetBeatOffset = 2;
  let sheetPartOffset = 1;
  if (!gs.assertString("LK") || !gs.assertBytes([3])) {
    DB("Not LK3")
    return false;
  }

  DB("Decoding LK3...")

  Sheet0.insertSubbeats()
  Sheet0.insertSubbeats()
  Sheet0.insertSubbeats()

  b = gs.nextByte();
  Destinations.input(0).gain.value = b/255;
  // knobVolume.set(b/255.0*100); // normalize then centify

  b = (gs.nextByte() + (gs.nextByte()<<8))/100.0;
  TickerTimer.setBpm(b);

  while (null != (next = gs.nextByte()))
  if (0 == next) { // FILTER / DESTINATION
    DB("LK3 new filter");
    label = gs.nextString(gs.nextByte()); // NAME LENGTH, NAME
    let t = gs.nextByte(); // TYPE
    b = gs.nextByte(); // PARAM COUNT
    let ps=[]
    RangeForEach(b, ()=>ps.push(gs.nextByte() / 255.0)); // PARAMS
    if (t==0) {
      d = new Delay(ctx);
    } else if (t==1) {
      d = new Lowpass(ctx);
    } else { t==-1; }

    if (-1 != t) {
      document.getElementById('filters').appendChild(d.element);
      d.setParams(ps);
    }
  } else if (1 == next) { // Synthesizer
    DB("LK3 new synth");
    label = gs.nextString(gs.nextByte());
    var synth;
    if (!Synthesizer0) Synthesizer0 = synth = new Synthesizer(ctx, label, gs.nextByte(), keyboard, "#44f");
    else if (!Synthesizer1) Synthesizer1 = synth = new Synthesizer(ctx, label, gs.nextByte(), keyboard, "#4f4");
    else if (!Synthesizer2) Synthesizer2 = synth = new Synthesizer(ctx, label, gs.nextByte(), keyboard, "#f44");
    else if (!Synthesizer3) Synthesizer3 = synth = new Synthesizer(ctx, label, gs.nextByte(), keyboard, "#4ff");
    else synth = new Synthesizer(ctx, label, gs.nextByte(), keyboard, "#ff4");
    synth.chanInSet(++synthCount);

    document.getElementById('synths').appendChild(synth.element);
    gs.nextByte(); // Ignore volume for now
    synth.attSet(gs.nextByte());
    synth.susSet(gs.nextByte());
    synth.relSet(gs.nextByte());
    var i = gs.nextByte();
    synth.connect(i);
  } else if (2 == next) { // Phrase...extract into parts
    label = gs.nextString(gs.nextByte());
    var partDrums = false;
    var measures = gs.nextByte();
    var beatsper = gs.nextByte();
    var ticksper = gs.nextByte();
    var tickCount = measures*beatsper*ticksper;
    var partCount = gs.nextByte();

    //var phrase = new Part(label, measures, beatsper, ticksper, keyboard); // BF
    //Sheet0.add(new PhraseReference(phrase));  // BF old method was sheet contained only references

    sheetPartOffset = 30;
    RangeForEach(measures*beatsper, Sheet0.appendBeat);
    for (var i=0; i<partCount; ++i) {
      var part;
      label = gs.nextString(gs.nextByte());
      var vol = gs.nextByte()/255;
      var dst = gs.nextByte(); // Destination (set below if drumkit track)
      var bools = gs.nextBools(tickCount);

      if (gs.peekByte() & 128) {
        var fixedNote = gs.nextByte() & 127;
        if (!partDrums) { // Create the drum part for aggregating the individual DAW1 drum parts
          //              (sheetObj,                         tickIdx, height,      keyBeg, keyCount, playable)
          partDrums = Part(Sheet0, sheetBeatOffset*(Sheet0.subs()+1), sheetPartOffset, 24, 16, DrumKit0);
          RangeForEach(measures*beatsper, partDrums.appendBeat);
          partDrums.insertSubbeats(ticksper);
          partDrums.chanOutSet(DrumKit0.chanIn());
          sheetPartOffset += 50;
          partDrums.toggleDisplay();
        }
        bools.map((n,i)=>n&&partDrums.setTick(fixedNote,i));
        //drumKit.connect(Destinations.input(dst), fixedNote); // DESTINATION/FILTER
        //part.elementFilter.innerText = Destinations.name(dst);
      } else {
        let tickCount = bools.reduce( (res,v)=>v?res+1:res );
        if (0==vol || !tickCount) {
          bools.map((n)=>n&&gs.nextByte());
        } else {
          Synthesizers.map(function(s) { // Lookup synth
            if (s.label() == label) {
              //part = phrase.createPart(s);
              part = new Part(Sheet0, sheetBeatOffset*(Sheet0.subs()+1), sheetPartOffset, 21,           88, Synthesizer1); // BF
              RangeForEach(measures*beatsper, part.appendBeat);
              part.insertSubbeats(ticksper);
              part.chanOutSet(s.chanIn());
              part.setVolume(vol);
            }
          });
          DB.check(part, `part was not created for ${label}`);
          bools.map(function(n,i){if (n) { part.setTick(15+gs.nextByte(), i);}});
          sheetPartOffset += 60;
          part.toggleDisplay();
        }
      }
      //part.setVol(vol/255.0); // Volume
    }
    sheetBeatOffset += measures*beatsper;
  } else if (3 == next) { // Phrase reference TODO: this is tricky since phrases are now individual parts.
    label = gs.nextString(gs.nextByte()); // Look-up existing phrase id and create a new ref using it.
/*
    for (var i=0; i<Sheet0.length(); ++i) {
      var phrase = Sheet0.phrase(i)
      if (phrase.id == label) { // Found it
        var refPhrase = new PhraseReference(phrase);
        Sheet0.add(refPhrase);
        DB(label + " reference");
        break;
      }
    }
*/
  }
  Sheet0
    .setEnd(sheetBeatOffset*(Sheet0.subs()+1)-1)
    .setBeg(2*(Sheet0.subs()+1));
  return true;
} // restoreSongLK3

/******************************************************************************
 MAIN

 CONCEPTS Musical Definitions

 Sheet........Arrangement of phrases
 Phrase.......Group of synchronized parts
 Part/Voice...A drum (drumkit?), voice, entire piano
 Measure/Bar..Logical division of parts
 Beat/1/4Note.Physical division of Parts
 Tick.........Physical division of Beats, denotes a note

******************************************************************************/
var Sheet0;
var Keyboard0;
var DrumKit0;
var Synthesizer0;
var Synthesizer1;
var Synthesizer2;
var Synthesizer3;
var Part0;
var DragOverTickState = 1;
var MouseIsDown = false; // It's nice to keep track of global mouse button state.  The window element will always catch this event and handle it.

var Setup = function () {
  DB.post("Setup", DB.status());

  DB.post("Setup", "Buttons");
  document.getElementById('addsynth').onmousedown = function () {
    var s = new Synthesizer(ctx, false, 1, Keyboard0, "#84f");
    document.getElementById('synths').appendChild(s.element);
  }

  document.getElementById('addFilterDelay').onmousedown = function () {
    var d = new Delay(ctx);
    Destinations.push(d);
    document.getElementById('filters').appendChild(d.element);
  }

  document.getElementById('addFilterLowpass').onmousedown = function () {
    var filt = new Lowpass(ctx);
    Destinations.push(filt);
    document.getElementById('filters').appendChild(filt.element);
  }

  // Create a piano object and DOM element.  88 keys, starting at 21/A0.
  DB.post("Setup", "Keyboard");
  Keyboard0 = new PianoKeyboard("piano1", 21, 88);
  //var keyboard2 = new PianoKeyboard("piano2",  21, 16, 0, 27.5); // 88-key piano: A0 A# B C1 C# D ...

  // MIDI fun
  DB.post("Setup", "MIDI");
  function onMIDISuccess( m ) { // TODO Keyboard0 should not be receiving MIDI commands.
    m.inputs.forEach( e => {e.onmidimessage=function(e){Keyboard0.midi(e);};} );
  }

  function onMIDIFailure(msg) { DB.error("MIDI "+msg ); }

  if (navigator.requestMIDIAccess) {
    navigator
      .requestMIDIAccess({"sysex":true, "software":true})
      .then(onMIDISuccess, onMIDIFailure);
  }

  Sheet0 = Sheet("sheet", TickerTimer);
  RangeForEach(8, Sheet0.appendBeat);

  DB.post("Setup", "More Buttons");
  setupControls(Keyboard0, Sheet0); // Setup menus and moveable buttons.

  DB.post("Setup", "Noises");

  // Load the audio asynchronously and create the default drumkit.
  DrumKit0 = new Drumkit(ctx, false, "orange", 24, ["808.bass.raw", "808.snare.drum.raw", "808.snare.noise.raw", "808.maracas.raw", "808.cowbell.raw", "808.rim.raw", "808.highhat.closed.raw", "808.claves.raw", "808.clap.raw", "808.highhat.opened.raw", "808.cymbal.raw", "909.thump.raw", "909.snare.noise.raw", "tsss.raw", "boots.raw", "cats.raw"]);

  if (restoreSongLK3(Keyboard0, DrumKit0, hyphen.song())) {
    setTimeout(TickerTimer.rewind, 1000);
  } else {
    DrumKit0.chanInSet(3);
    Synthesizer0 = new Synthesizer(ctx, false, 1, Keyboard0, "#84f");
    Synthesizer1 = new Synthesizer(ctx, false, 2, Keyboard0, "#4f4");
    Synthesizer2 = new Synthesizer(ctx, false, 3, Keyboard0, "#f48");
    ElementById('synths').appendChild(Synthesizer0.element);
    ElementById('synths').appendChild(Synthesizer1.element);
    ElementById('synths').appendChild(Synthesizer2.element);

    // Effects
    ElementById('filters').appendChild(Delay().element);
    ElementById('filters').appendChild(Lowpass().element);

    DB.post("Start", "Parts");
    Part0 = Part(Sheet0, 2, 1*21, 24, 16, DrumKit0 );
    Part(Sheet0,         2,16*21, 21, 88, Synthesizer1 ); // startTick, verticalPos, keyCount <=61, tickCount

    Sheet0.setBeg(2).setEnd(6);

    updatePartsSlowly();
  }
}; // Start


function updatePartsSlowly() {
  DB.post("Start", "UpdatePartsSlowly");
  [
    Sheet0.insertSubbeats,
    Sheet0.insertSubbeats,
    Sheet0.insertSubbeats,
    Part0.appendBeat,
    Part0.appendBeat,
    Part0.appendBeat,
    Part0.appendBeat,
    Part0.insertSubbeats.bind(0,2),
    Part0.insertSubbeats.bind(0,2),
    ()=>{Sheet0.setBeg(2*2 * 2).setEnd(2*2 * 6 - 1);},
    TickerTimer.rewind,
    Part0.setTick.bind(0, 11, 0),
    Part0.setTick.bind(0, 11, 4),
    Part0.setTick.bind(0, 11, 8),
    Part0.setTick.bind(0, 11, 12),
    Part0.setTick.bind(0, 2, 2),
    Part0.setTick.bind(0, 2, 6),
    Part0.setTick.bind(0, 2, 10),
    Part0.setTick.bind(0, 2, 14),
    Part0.setTick.bind(0, 3, 0),
    Part0.setTick.bind(0, 3, 1),
    Part0.setTick.bind(0, 3, 2),
    Part0.setTick.bind(0, 3, 3),
    Part0.setTick.bind(0, 3, 4),
    Part0.setTick.bind(0, 3, 5),
    Part0.setTick.bind(0, 3, 6),
    Part0.setTick.bind(0, 3, 7),
    Part0.setTick.bind(0, 3, 8),
    Part0.setTick.bind(0, 3, 9),
    Part0.setTick.bind(0, 3, 10),
    Part0.setTick.bind(0, 3, 11),
    Part0.setTick.bind(0, 3, 12),
    Part0.setTick.bind(0, 3, 13),
    Part0.setTick.bind(0, 3, 14),
    Part0.setTick.bind(0, 3, 15),
  ].forEach((f,i)=>setTimeout(f, i*50));
}


// Wait for a user gesture which will unblock the audio backend.
window.onload = function Main () {
  if (ctx.state == "suspended") {
    revealCenter("pauseicon", true)
    ctx.resume()
    setTimeout(Main, 200);
  } else {
    DB.post("Main", "Starting AudioContext!");
    // Slowly disappear the pause icon then remove the clip region so it no
    // longer looks like a play button.
    revealCenter("pauseicon", false)
    setTimeout( ()=>ElementById("pauseicon").style.clipPath="", 1100);
    Setup();

    DB.post("Start", "CallbackHandlers");
    TickerTimer.registerPlayCallback(eventLoops.bind(null, Sheet0));
  }
};

//IBC.debug();

//]]></script></body></html><!--
* Synth listener that crashes (key out of bounds) denies other synths from receiving.
* Moving part to another tick broken when moved beyond the last phrase grid column.
* copy/paste
* delete objects
* song save
* Dragging Part draws ticks
* text-area parts (for notes, karaoke?)
* triggers, counters, maybe embedded scheme? (for phrase repeating, knob controlling)
* visual rendering doesn't synch right when BPM very low

[...document.styleSheets[0].cssRules]
  .filter(e=>e.selectorText=='.sheet > div')[0]
  .style.width = `${beatWidth}ch`;

<input id="volume" type="range" max="100" value="50" min="0" style="width:6ch" title="VOLUME"/>
document.getElementById('volume').oninput=(e)=>Destinations.input(0).gain.value=e.target.value/100;
-->
